<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>STL Assembly Studio – Full</title>

<!-- THREE.JS & UTILS -->
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/DragControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/loaders/STLLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/exporters/STLExporter.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

<style>
/* —— GENERAL RESET & STYLES —— */
body { margin: 0; padding: 0; font-family: sans-serif; background: #0a0e17; color: #e8edf4; overflow: hidden; }
button, input, select { font-family: sans-serif; }
#canvas-container { width: 100%; height: 100vh; display: block; }

/* —— SIDEBAR —— */
#sidebar {
  position: absolute; left: 0; top: 0; bottom: 0; width: 320px;
  background: #141922; overflow-y: auto; border-right: 2px solid rgba(0,245,255,0.15);
  padding: 16px;
}
#sidebar h2 { margin: 8px 0; color: #00f5ff; font-size: 18px; }
.section { margin-bottom: 16px; }

/* BUTTON STYLES */
.btn { display: block; width: 100%; padding: 8px 0; margin: 4px 0; cursor: pointer; background: #1e2530; border: 1px solid #0f1520; color: #e8edf4; text-align:center; }
.btn:hover { background: #080b10; border-color: #00f5ff; color: #00f5ff; }

.part-card { background:#1e2530; border:1px solid rgba(0,245,255,0.15); margin-bottom:8px; padding:8px; border-radius:6px; }

/* COLOR PREVIEW */
.color-preview-small { width:20px;height:20px;display:inline-block;border:1px solid #444;vertical-align:middle;margin-right:4px; }
</style>
</head>
<body>

<div id="sidebar">
  <h2>STL Assembly Studio</h2>

  <div class="section">
    <input type="file" id="file-input" accept=".stl,.stlproject" multiple />
    <button class="btn" onclick="clearAll()">Clear All</button>
    <button class="btn" onclick="exportAssembly()">Export Assembly .STL</button>
    <button class="btn" onclick="exportImage()">Export Image</button>
  </div>

  <!-- GROUP MANAGEMENT -->
  <div class="section">
    <h3>Group Management</h3>
    <input type="text" id="new-group-name" placeholder="Group Name" style="width:100%;padding:6px;">
    <button class="btn" onclick="createGroup()">Create Group</button>

    <select id="group-selector" style="width:100%;padding:6px;margin:6px 0;" onchange="selectGroup(this.value)">
      <option value="">Select Group</option>
    </select>

    <input type="color" id="group-color-picker" value="#ff006b">
    <button class="btn" id="apply-group-color-btn" onclick="applyColorToGroup()">Apply Color to Group</button>
    <button class="btn" onclick="randomizeGroupColors()">Randomize Group Colors</button>
  </div>

  <!-- PARTS -->
  <div class="section">
    <h3>Parts</h3>
    <div id="parts-container"></div>
  </div>

  <!-- INFO -->
  <div class="section">
    <div><strong>Bounding Box:</strong></div>
    <div id="bounding-info"></div>
  </div>

</div>

<div id="canvas-container"></div>

<script>

// ============================
// == GLOBAL STATE ============
let scene, camera, renderer, controls, raycaster, mouse;
let parts = [], selectedParts = new Set(), groups = [], selectedGroup = null;
let animationFrameId = null;
let loader, exporter;

// ============================
// == INIT SCENE ============
function init() {
  // Scene
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 2000);
  camera.position.set(0,50,150);

  // Renderer
  renderer = new THREE.WebGLRenderer({ antialias:true, preserveDrawingBuffer:true });
  renderer.setSize(window.innerWidth - 320, window.innerHeight);
  document.getElementById('canvas-container').append(renderer.domElement);

  // Controls
  controls = new THREE.OrbitControls(camera, renderer.domElement);

  // Lights
  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const d = 120;
  const light = new THREE.DirectionalLight(0xffffff,0.8);
  light.position.set(d,d,d);
  scene.add(light);

  // Raycaster
  raycaster = new THREE.Raycaster();
  mouse = new THREE.Vector2();

  loader = new THREE.STLLoader();
  exporter = new THREE.STLExporter();

  window.addEventListener('resize', onWindowResize);

  animate();
}

function onWindowResize() {
  camera.aspect = (window.innerWidth - 320)/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth -320, window.innerHeight);
}

// ============================
// == FILE UPLOAD ============
document.getElementById('file-input').addEventListener('change', (e)=>{
  handleFiles(e.target.files);
});

async function handleFiles(files) {
  for (let f of files) {
    if (f.name.match(/\.stl$/i)) {
      await loadSTL(f);
    } else if (f.name.match(/\.stlproject$/i)) {
      await loadProjectFile(f);
    }
  }
}

// ============================
// == LOAD STL ================
function loadSTL(file) {
  return new Promise(resolve => {
    const reader = new FileReader();
    reader.onload = (e) => {
      const geom = loader.parse(e.target.result);
      const color = '#'+Math.floor(Math.random()*16777215).toString(16).padStart(6,'0');
      const mat = new THREE.MeshStandardMaterial({ color });
      const mesh = new THREE.Mesh(geom, mat);
      mesh.userData = { name: file.name.replace('.stl',''), color, visible:true };
      scene.add(mesh);
      parts.push(mesh);
      addPartCard(parts.length -1);
      updateBoundingBox();
      resolve();
    };
    reader.readAsArrayBuffer(file);
  });
}

// ============================
// == PART UI ================
function addPartCard(i) {
  const container = document.getElementById('parts-container');
  const part = parts[i];

  const card = document.createElement('div'); card.className='part-card'; card.id = 'part-card-'+i;

  card.innerHTML = `
    <input type="checkbox" id="partsel-${i}" onchange="togglePartSelection(${i}, this.checked)">
    <span class="color-preview-small" style="background:${part.userData.color}"></span>
    <strong>${part.userData.name}</strong><br>

    <input type="color" value="${part.userData.color}" onchange="updatePartColor(${i}, this.value)">
    <span id="hex-${i}">${part.userData.color}</span>
  `;

  container.append(card);
}

function togglePartSelection(idx, checked) {
  if (checked) selectedParts.add(idx); else selectedParts.delete(idx);
}

function updatePartColor(idx, color) {
  if (!parts[idx]) return;
  parts[idx].material.color.set(color);
  parts[idx].userData.color = color;
  document.getElementById('hex-'+idx).textContent = color;
}

// ============================
// == GROUP MANAGEMENT ========
function createGroup() {
  const name = document.getElementById('new-group-name').value.trim();
  if (!name) return alert('Enter group name');
  groups.push({ name, parts: new Set(selectedParts), color:document.getElementById('group-color-picker').value });
  renderGroupSelector();
}

function renderGroupSelector() {
  const sel = document.getElementById('group-selector'); sel.innerHTML='<option value="">Select Group</option>';
  groups.forEach((g,i) => {
    const opt = document.createElement('option');
    opt.value = i;
    opt.textContent = `${g.name} (${g.parts.size})`;
    opt.style.color = g.color;
    sel.append(opt);
  });
}

function selectGroup(val) {
  if (val==='') { selectedGroup=null; return; }
  selectedGroup = groups[val];
}

function applyColorToGroup() {
  if (!selectedGroup) return;
  const color = document.getElementById('group-color-picker').value;
  selectedGroup.color = color;
  selectedGroup.parts.forEach(idx => {
    if (parts[idx]) updatePartColor(idx, color);
  });
  renderGroupSelector();
}

function randomizeGroupColors() {
  for (let g of groups) {
    const rand = '#'+Math.floor(Math.random()*16777215).toString(16).padStart(6,'0');
    g.color = rand;
    g.parts.forEach(idx => { if (parts[idx]) updatePartColor(idx, rand); });
  }
  renderGroupSelector();
}

// ============================
// == SAVE / LOAD PROJECT ========
async function saveProject() {
  if (!parts.length) return;
  const zip = new JSZip();
  const stlFolder = zip.folder("stl_files");
  const proj = { parts:[], groups };

  // save STLs
  for (let p of parts) {
    const geom = p.geometry.clone(), mesh = new THREE.Mesh(geom);
    const data = exporter.parse(mesh,{binary:true});
    stlFolder.file(p.userData.name+".stl", data, {binary:true});
    proj.parts.push({
      name:p.userData.name,
      color:p.userData.color
    });
  }
  zip.file("project.json", JSON.stringify(proj,null,2));
  const blob = await zip.generateAsync({type:'blob'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download="project.stlproject"; a.click();
}

async function loadProjectFile(file) {
  const zip = await JSZip.loadAsync(file);
  const projText = await zip.file("project.json").async("text");
  const data = JSON.parse(projText);
  clearScene();
  for (let partData of data.parts) {
    const stl = zip.file("stl_files/"+partData.name+".stl");
    if (stl) {
      const buffer = await stl.async("arraybuffer");
      parts.push(loader.parse(buffer));
    }
  }
  groups = data.groups || [];
  renderGroupSelector();
}

// ============================
// == EXPORT & CLEAR ============
function exportAssembly() {
  const visibleParts = parts.filter(p=>p.userData.visible!==false);
  if (!visibleParts.length) return alert("No visible parts!");
  const grp = new THREE.Group();
  visibleParts.forEach(p => {
    const clone = p.clone(); clone.updateMatrixWorld();
    grp.add(clone);
  });
  const res = exporter.parse(grp,{binary:true});
  const blob = new Blob([res],{type:"application/octet-stream"});
  const a = document.createElement('a');
  a.href=URL.createObjectURL(blob);
  a.download="assembly.stl"; a.click();
}

function exportImage() {
  renderer.render(scene,camera);
  const a=document.createElement('a');
  a.href=renderer.domElement.toDataURL("image/png");
  a.download="snapshot.png"; a.click();
}

function clearAll() {
  if (!confirm("Clear all parts?")) return;
  clearScene();
  document.getElementById("parts-container").innerHTML='';
  parts=[]; selectedParts.clear(); groups=[]; selectedGroup=null;
  renderGroupSelector(); updateBoundingBox();
}

function clearScene() {
  parts.forEach(p => {
    p.geometry.dispose(); p.material.dispose(); scene.remove(p);
  });
}

// ============================
// == BOUNDING BOX ============
function updateBoundingBox() {
  if (!parts.length) return;
  const box = new THREE.Box3();
  parts.forEach(p => box.expandByObject(p));
  const size = box.getSize(new THREE.Vector3());
  document.getElementById('bounding-info').textContent=
    `X:${size.x.toFixed(1)}, Y:${size.y.toFixed(1)}, Z:${size.z.toFixed(1)}`;
}

// ============================
// == ANIMATE LOOP ============
function animate() {
  animationFrameId = requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene,camera);
}

init();
</script>

</body>
</html>
