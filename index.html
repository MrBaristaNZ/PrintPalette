<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Print Palette - 3D Print Colour Preview Studio</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@300;500;700&family=Azeret+Mono:wght@400;600&display=swap');

        :root {
            --bg-primary: #0a0e17;
            --bg-secondary: #141922;
            --bg-tertiary: #1e2530;
            --accent-cyan: #00f5ff;
            --accent-magenta: #ff006b;
            --accent-yellow: #ffd700;
            --accent-green: #00ff88;
            --accent-orange: #ff6b35;
            --accent-purple: #a855f7;
            --text-primary: #e8edf4;
            --text-secondary: #8b95a8;
            --border: rgba(0, 245, 255, 0.15);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
        }

        .container {
            display: grid;
            grid-template-columns: 400px 1fr;
            height: 100vh;
            gap: 0;
        }

        /* Sidebar */
        .sidebar {
            background: var(--bg-secondary);
            border-right: 2px solid var(--border);
            padding: 24px;
            overflow-y: auto;
            position: relative;
        }

        .sidebar::before {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 1px;
            height: 100%;
            background: linear-gradient(180deg, 
                transparent 0%, 
                var(--accent-cyan) 30%, 
                var(--accent-cyan) 70%, 
                transparent 100%);
            opacity: 0.3;
        }

        .logo {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 8px;
            letter-spacing: -0.5px;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-magenta));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-family: 'Azeret Mono', monospace;
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 24px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .project-name-section {
            margin-bottom: 24px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px;
        }

        .project-label {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 8px;
            font-family: 'Azeret Mono', monospace;
            text-transform: uppercase;
        }

        .project-name-input {
            width: 100%;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 10px 12px;
            border-radius: 6px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 16px;
            font-weight: 600;
        }

        .project-name-input:focus {
            outline: none;
            border-color: var(--accent-cyan);
        }

        /* Upload Section */
        .upload-section {
            margin-bottom: 24px;
        }

        .upload-zone {
            border: 2px dashed var(--border);
            border-radius: 8px;
            padding: 32px 16px;
            text-align: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .upload-zone::before {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at center, rgba(0, 245, 255, 0.1) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .upload-zone:hover::before {
            opacity: 1;
        }

        .upload-zone:hover {
            border-color: var(--accent-cyan);
            background: rgba(0, 245, 255, 0.05);
        }

        .upload-zone.drag-over {
            border-color: var(--accent-magenta);
            background: rgba(255, 0, 107, 0.1);
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: 12px;
            opacity: 0.6;
        }

        .upload-text {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .upload-hint {
            font-family: 'Azeret Mono', monospace;
            font-size: 10px;
            color: var(--text-secondary);
            opacity: 0.6;
        }

        #file-input {
            display: none;
        }

        .action-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 12px;
        }

        .action-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 0.5px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
        }

        .action-btn:hover {
            background: rgba(0, 245, 255, 0.1);
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        .action-btn.secondary {
            background: transparent;
        }

        .action-btn.project {
            background: rgba(168, 85, 247, 0.1);
            border-color: var(--accent-purple);
            color: var(--accent-purple);
            grid-column: 1 / -1;
        }

        .action-btn.project:hover {
            background: rgba(168, 85, 247, 0.2);
        }

        .action-btn.export-stl {
            background: rgba(255, 215, 0, 0.1);
            border-color: var(--accent-yellow);
            color: var(--accent-yellow);
        }

        .action-btn.export-stl:hover {
            background: rgba(255, 215, 0, 0.2);
        }

        .action-btn.arrangement {
            background: rgba(0, 255, 136, 0.1);
            border-color: var(--accent-green);
            color: var(--accent-green);
            font-size: 11px;
        }

        .action-btn.arrangement:hover {
            background: rgba(0, 255, 136, 0.2);
        }

        /* Group Management */
        .group-management {
            margin-bottom: 24px;
        }

        #group-color-dropdown {
            transition: all 0.2s;
            color: white;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }

        #group-color-dropdown:hover {
            border-color: var(--accent-cyan);
            transform: scale(1.02);
        }

        #group-color-dropdown option {
            padding: 8px;
            font-weight: 600;
        }

        .apply-multi-btn {
            flex: 1;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid var(--accent-green);
            color: var(--accent-green);
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        .apply-multi-btn:hover:not(:disabled) {
            background: rgba(0, 255, 136, 0.2);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 255, 136, 0.3);
        }

        .apply-multi-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* Color Management */
        .color-management {
            margin-bottom: 24px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px;
        }

        .color-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            user-select: none;
        }

        .color-title {
            font-size: 13px;
            font-weight: 600;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .collapse-btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-size: 12px;
        }

        .collapse-btn:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        .color-content {
            max-height: 500px;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .color-content.collapsed {
            max-height: 0;
        }

        .color-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            margin-bottom: 12px;
        }

        .color-item {
            position: relative;
            aspect-ratio: 1;
            border-radius: 6px;
            border: 2px solid var(--border);
            cursor: pointer;
            transition: all 0.2s;
        }

        .color-item:hover {
            border-color: var(--accent-cyan);
            transform: scale(1.05);
        }

        .color-item.selected {
            border-color: var(--accent-green);
            border-width: 3px;
            box-shadow: 0 0 0 3px rgba(0, 255, 136, 0.3), 0 0 20px rgba(0, 255, 136, 0.5);
            transform: scale(1.1);
        }
        
        .color-item.selected::after {
            content: '‚úì';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.8), 0 0 8px rgba(0, 0, 0, 0.5);
            pointer-events: none;
        }

        .color-remove {
            position: absolute;
            top: -6px;
            right: -6px;
            background: var(--accent-magenta);
            border: 2px solid var(--bg-tertiary);
            color: white;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            z-index: 10;
        }

        .color-item:hover .color-remove {
            display: flex;
        }

        .color-add-section {
            display: flex;
            gap: 12px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border);
            align-items: flex-start;
        }

        .color-input-new {
            flex: 1;
            height: 36px;
            border-radius: 6px;
            border: 2px solid var(--border);
            cursor: pointer;
        }

        .add-color-btn {
            background: rgba(255, 0, 107, 0.1);
            border: 1px solid var(--accent-magenta);
            color: var(--accent-magenta);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-size: 11px;
            font-weight: 600;
            transition: all 0.2s;
            white-space: nowrap;
            align-self: flex-end;
            margin-top: 18px;
        }

        .add-color-btn:hover {
            background: rgba(255, 0, 107, 0.2);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(255, 0, 107, 0.3);
            border-color: var(--accent-magenta);
        }

        .group-color-section {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border);
        }

        .group-label {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 8px;
            font-family: 'Azeret Mono', monospace;
        }

        .apply-to-selected-btn {
            width: 100%;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid var(--accent-green);
            color: var(--accent-green);
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        .apply-to-selected-btn:hover {
            background: rgba(0, 255, 136, 0.2);
        }

        .apply-to-selected-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Parts Section - keeping styles minimal for brevity */
        .section-header {
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .section-header-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .section-header-left::before {
            content: '';
            width: 3px;
            height: 12px;
            background: var(--accent-cyan);
            border-radius: 2px;
        }

        .section-actions {
            display: flex;
            gap: 8px;
        }

        .section-btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-size: 10px;
            font-weight: 600;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        .section-btn:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        .selection-info {
            font-size: 11px;
            color: var(--accent-green);
            font-weight: 600;
        }

        .part-section {
            margin-bottom: 24px;
        }

        .empty-state {
            text-align: center;
            padding: 32px 16px;
            color: var(--text-secondary);
            font-size: 13px;
            opacity: 0.6;
        }

        .part-card {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .part-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 3px;
            height: 100%;
            background: var(--accent-cyan);
            transform: scaleY(0);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .part-card:hover {
            border-color: var(--accent-cyan);
            box-shadow: 0 4px 20px rgba(0, 245, 255, 0.1);
        }

        .part-card:hover::before {
            transform: scaleY(1);
        }

        .part-card.expanded {
            border-color: var(--accent-cyan);
        }

        .part-card.hidden-part {
            opacity: 0.5;
        }

        .part-card.selected {
            border-color: var(--accent-green);
            background: rgba(0, 255, 136, 0.05);
        }

        .part-card.locked {
            border-color: var(--accent-orange);
            background: rgba(255, 107, 53, 0.05);
        }

        .part-card.minimized .part-content {
            max-height: 0;
            opacity: 0;
            margin-top: 0;
        }

        .part-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .part-name-section {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
        }

        .select-checkbox {
            width: 24px;
            height: 24px;
            border: 2px solid var(--border);
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-size: 14px;
            font-weight: bold;
            background: var(--bg-primary);
            flex-shrink: 0;
        }

        .select-checkbox:hover {
            border-color: var(--accent-green);
            background: rgba(0, 255, 136, 0.1);
        }

        .select-checkbox.checked {
            background: var(--accent-green);
            border-color: var(--accent-green);
            color: var(--bg-primary);
        }

        .part-name {
            font-size: 15px;
            font-weight: 600;
            letter-spacing: 0.3px;
        }

        .part-actions {
            display: flex;
            gap: 8px;
        }

        .icon-btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            width: 32px;
            height: 32px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-size: 14px;
            font-weight: 600;
        }

        .icon-btn:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        .icon-btn.danger:hover {
            border-color: var(--accent-magenta);
            color: var(--accent-magenta);
        }

        .icon-btn.active {
            background: rgba(0, 245, 255, 0.1);
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        .icon-btn.visibility {
            background: rgba(0, 255, 136, 0.1);
            border-color: var(--accent-green);
            color: var(--accent-green);
        }

        .icon-btn.visibility.hidden-btn {
            background: rgba(255, 0, 107, 0.1);
            border-color: var(--accent-magenta);
            color: var(--accent-magenta);
        }

        .icon-btn.lock-btn {
            background: rgba(255, 107, 53, 0.1);
            border-color: var(--accent-orange);
            color: var(--accent-orange);
        }

        .icon-btn.lock-btn.locked {
            background: rgba(255, 107, 53, 0.2);
        }

        .part-content {
            max-height: 2000px;
            opacity: 1;
            overflow: hidden;
            transition: all 0.3s ease;
            margin-top: 12px;
        }

        /* Coordinate Display */
        .coordinate-display {
            background: rgba(0, 245, 255, 0.05);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 12px;
            font-family: 'Azeret Mono', monospace;
            font-size: 11px;
        }

        .coord-title {
            color: var(--accent-cyan);
            font-weight: 600;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .coord-values {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .coord-item {
            text-align: center;
        }

        .coord-label {
            color: var(--text-secondary);
            font-size: 9px;
            margin-bottom: 2px;
        }

        .coord-value {
            color: var(--text-primary);
            font-weight: 600;
        }

        .color-picker-container {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .color-input-wrapper {
            position: relative;
            flex: 1;
        }

        .color-preview {
            width: 100%;
            height: 40px;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid var(--border);
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }

        .color-preview::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, transparent 0%, rgba(255, 255, 255, 0.1) 100%);
            pointer-events: none;
        }

        .color-preview:hover {
            border-color: var(--accent-cyan);
            transform: scale(1.02);
        }

        input[type="color"] {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .color-hex {
            font-family: 'Azeret Mono', monospace;
            font-size: 11px;
            color: var(--text-secondary);
            text-align: center;
            margin-top: 6px;
            letter-spacing: 0.5px;
        }

        .preset-colors {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 6px;
            margin-top: 12px;
        }

        .preset-color {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .preset-color:hover {
            border-color: var(--accent-cyan);
            transform: scale(1.1);
        }

        /* Transform Controls - minimal for space */
        .transform-controls {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border);
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .transform-controls.show {
            max-height: 800px;
        }

        .transform-controls.disabled {
            pointer-events: none;
            opacity: 0.3;
        }

        .transform-section {
            margin-bottom: 16px;
        }

        .transform-label {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 8px;
            font-family: 'Azeret Mono', monospace;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .transform-label::before {
            content: '';
            width: 2px;
            height: 10px;
            background: var(--accent-cyan);
        }

        .transform-sliders {
            display: grid;
            gap: 10px;
        }

        .slider-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .slider-label {
            font-family: 'Azeret Mono', monospace;
            font-size: 11px;
            color: var(--accent-cyan);
            width: 12px;
            font-weight: 600;
        }

        .slider-label.rotation {
            color: var(--accent-magenta);
        }

        .slider-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: var(--bg-primary);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--accent-cyan);
            cursor: pointer;
        }

        input[type="range"].rotation::-webkit-slider-thumb {
            background: var(--accent-magenta);
        }

        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--accent-cyan);
            cursor: pointer;
            border: none;
        }

        input[type="range"].rotation::-moz-range-thumb {
            background: var(--accent-magenta);
        }

        .input-controls {
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .number-input {
            flex: 1;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 4px 8px;
            border-radius: 4px;
            font-family: 'Azeret Mono', monospace;
            font-size: 11px;
            text-align: center;
        }

        .number-input:focus {
            outline: none;
            border-color: var(--accent-cyan);
        }

        .arrow-btn {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-size: 12px;
            font-weight: 600;
        }

        .arrow-btn:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
            background: rgba(0, 245, 255, 0.1);
        }

        .arrow-btn:active {
            transform: scale(0.95);
        }

        .transform-reset {
            margin-top: 12px;
            width: 100%;
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        .transform-reset:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        /* Viewer */
        .viewer {
            position: relative;
            background: radial-gradient(ellipse at center, #1a2030 0%, var(--bg-primary) 100%);
        }

        #canvas-container {
            width: 100%;
            height: 100%;
        }

        .viewer-controls {
            position: absolute;
            top: 24px;
            right: 24px;
            display: flex;
            gap: 12px;
        }

        .control-btn {
            background: rgba(20, 25, 34, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 10px 18px;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-size: 13px;
            font-weight: 600;
            letter-spacing: 0.5px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
        }

        .control-btn:hover {
            background: rgba(0, 245, 255, 0.1);
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
            box-shadow: 0 4px 20px rgba(0, 245, 255, 0.2);
        }

        .control-btn.active {
            background: rgba(255, 215, 0, 0.2);
            border-color: var(--accent-yellow);
            color: var(--accent-yellow);
        }

        .info-overlay {
            position: absolute;
            bottom: 24px;
            left: 24px;
            background: rgba(20, 25, 34, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px 20px;
            font-family: 'Azeret Mono', monospace;
            font-size: 11px;
            color: var(--text-secondary);
        }

        .info-overlay div {
            margin-bottom: 4px;
        }

        .info-overlay div:last-child {
            margin-bottom: 0;
        }

        .info-label {
            color: var(--accent-cyan);
            margin-right: 8px;
        }

        /* Measurement Overlay */
        .measurement-overlay {
            position: absolute;
            top: 24px;
            left: 24px;
            background: rgba(20, 25, 34, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid var(--accent-yellow);
            border-radius: 8px;
            padding: 16px 20px;
            font-family: 'Azeret Mono', monospace;
            font-size: 11px;
            color: var(--text-primary);
            display: none;
        }

        .measurement-overlay.active {
            display: block;
        }

        .measurement-title {
            color: var(--accent-yellow);
            font-weight: 600;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .measurement-value {
            font-size: 18px;
            color: var(--accent-yellow);
            margin: 8px 0;
            font-weight: 600;
        }

        .measurement-hint {
            color: var(--text-secondary);
            font-size: 10px;
            margin-top: 8px;
        }

        /* Animations */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .part-card {
            animation: fadeInUp 0.5s cubic-bezier(0.4, 0, 0.2, 1) backwards;
        }

        /* Custom Scrollbar */
        .sidebar::-webkit-scrollbar {
            width: 6px;
        }

        .sidebar::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }

        .sidebar::-webkit-scrollbar-thumb {
            background: var(--accent-cyan);
            border-radius: 3px;
        }

        .sidebar::-webkit-scrollbar-thumb:hover {
            background: var(--accent-magenta);
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: 24px;
            right: 24px;
            background: rgba(20, 25, 34, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid var(--accent-cyan);
            border-radius: 8px;
            padding: 16px 20px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            transform: translateY(150%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1000;
            box-shadow: 0 8px 32px rgba(0, 245, 255, 0.2);
        }

        .toast.show {
            transform: translateY(0);
        }

        /* Measurement Line */
        .measurement-line {
            position: absolute;
            height: 2px;
            background: var(--accent-yellow);
            transform-origin: 0 0;
            pointer-events: none;
            z-index: 100;
        }

        .measurement-point {
            position: absolute;
            width: 8px;
            height: 8px;
            background: var(--accent-yellow);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 101;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <div class="logo">PRINT PALETTE</div>
            <div class="subtitle">3D Print Colour Preview</div>
            
            <!-- Project Name Section -->
            <div class="project-name-section">
                <div class="project-label">Project Name</div>
                <input type="text" class="project-name-input" id="project-name" placeholder="My Blaster Assembly" value="Untitled Project">
            </div>

            <!-- Upload Section -->
            <div class="upload-section">
                <div class="upload-zone" id="upload-zone" onclick="document.getElementById('file-input').click()">
                    <div class="upload-icon">üì¶</div>
                    <div class="upload-text">Load STL Parts</div>
                    <div class="upload-hint">Or load a project file (.stlproject)</div>
                </div>
                <input type="file" id="file-input" accept=".stl,.stlproject" multiple>
            </div>

            <!-- Project Buttons -->
            <div class="action-buttons">
                <button class="action-btn project" onclick="saveProject()">üíæ Save Project</button>
                <button class="action-btn project" onclick="loadProject()">üìÇ Load Project</button>
            </div>
            
            <!-- Load from URL Section -->
            <div style="margin: 12px 0; padding: 12px; background: rgba(0, 245, 255, 0.05); border: 1px solid var(--border); border-radius: 8px;">
                <div style="font-size: 10px; color: var(--text-secondary); font-family: 'Azeret Mono', monospace; text-transform: uppercase; margin-bottom: 6px;">Load from URL:</div>
                <div style="display: flex; gap: 8px;">
                    <input type="text" id="project-url-input" placeholder="https://raw.githubusercontent.com/.../project.stlproject" 
                           style="flex: 1; padding: 8px; background: var(--bg-primary); border: 1px solid var(--border); border-radius: 4px; color: var(--text-primary); font-size: 11px; font-family: 'Azeret Mono', monospace;">
                    <button class="action-btn project" onclick="loadProjectFromURL()" style="white-space: nowrap; padding: 8px 12px;">
                        üåê Load
                    </button>
                </div>
                <div style="font-size: 9px; color: var(--text-secondary); margin-top: 4px; opacity: 0.7;">Paste GitHub raw URL or direct .stlproject link</div>
            </div>
            
            <!-- Browse GitHub Projects -->
            <div style="margin: 12px 0; padding: 12px; background: rgba(138, 85, 247, 0.05); border: 1px solid var(--border); border-radius: 8px;">
                <div style="font-size: 10px; color: var(--text-secondary); font-family: 'Azeret Mono', monospace; text-transform: uppercase; margin-bottom: 6px;">Browse GitHub Projects:</div>
                <select id="github-project-dropdown" onchange="loadSelectedGitHubProject()" 
                        style="width: 100%; padding: 10px; background: var(--bg-primary); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); font-family: 'Rajdhani', sans-serif; cursor: pointer; font-size: 12px; margin-bottom: 8px;">
                    <option value="">Select a project...</option>
                </select>
                <button class="action-btn project" onclick="refreshGitHubProjects()" style="width: 100%; padding: 8px; font-size: 11px;">
                    üîÑ Refresh List
                </button>
                <div style="font-size: 9px; color: var(--text-secondary); margin-top: 6px; opacity: 0.7;">
                    <span id="github-repo-info">Configure repo below ‚Üì</span>
                </div>
                <details style="margin-top: 8px;">
                    <summary style="cursor: pointer; font-size: 10px; color: var(--accent-cyan); font-family: 'Azeret Mono', monospace;">‚öôÔ∏è Repository Settings</summary>
                    <div style="margin-top: 8px; display: flex; flex-direction: column; gap: 6px;">
                        <div style="font-size: 9px; color: var(--accent-yellow); background: rgba(255, 215, 0, 0.1); padding: 6px; border-radius: 4px; margin-bottom: 4px;">
                            üí° <strong>How to find your path:</strong><br>
                            1. Open your GitHub repo<br>
                            2. Navigate to the folder with .stlproject files<br>
                            3. Copy path from URL after /tree/main/
                        </div>
                        <input type="text" id="github-owner" placeholder="Repository Owner (e.g. MrBaristaNZ)" value="MrBaristaNZ"
                               style="padding: 6px; background: var(--bg-primary); border: 1px solid var(--border); border-radius: 4px; color: var(--text-primary); font-size: 10px;">
                        <input type="text" id="github-repo" placeholder="Repository Name (e.g. printpalette)" value="printpalette"
                               style="padding: 6px; background: var(--bg-primary); border: 1px solid var(--border); border-radius: 4px; color: var(--text-primary); font-size: 10px;">
                        <input type="text" id="github-path" placeholder="Path (e.g. Projects/Blasters)" value="Projects/Blasters/Leedle Dynamics"
                               style="padding: 6px; background: var(--bg-primary); border: 1px solid var(--border); border-radius: 4px; color: var(--text-primary); font-size: 10px;">
                        <button onclick="testGitHubPath()" style="padding: 6px; background: var(--accent-cyan); color: var(--bg-primary); border: none; border-radius: 4px; cursor: pointer; font-size: 10px; font-weight: 600;">
                            üß™ Test Path
                        </button>
                        <button onclick="saveGitHubSettings()" style="padding: 6px; background: var(--accent-green); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 10px; font-weight: 600;">
                            üíæ Save & Refresh
                        </button>
                    </div>
                </details>
            </div>

            <!-- Action Buttons -->
            <div class="action-buttons">
                <button class="action-btn secondary" onclick="exportImage()">üì∏ Image</button>
                <button class="action-btn secondary" onclick="randomizeColors()">üé≤ Random Colour</button>
                <button class="action-btn secondary" onclick="clearAll()">üìÑ New Project</button>
            </div>

            <!-- Group Management -->
            <div class="group-management">
                <div class="section-header">
                    <div class="section-header-left">
                        <span>üìÅ Part Groups</span>
                    </div>
                </div>
                <div style="background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 8px; padding: 16px;">
                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 8px; font-family: 'Azeret Mono', monospace;">
                        1. Check parts below (‚úì) ‚Üí 2. Name group ‚Üí 3. Create
                    </div>
                    <input type="text" id="new-group-name" placeholder="Group name (e.g. 'Metal Parts')" 
                           style="width: 100%; padding: 10px; margin-bottom: 8px; background: var(--bg-primary); border: 1px solid var(--border); color: var(--text-primary); border-radius: 6px; font-family: 'Rajdhani', sans-serif;">
                    <button class="action-btn secondary" onclick="createGroup()" style="width: 100%; margin-bottom: 16px;">
                        ‚ûï Create Group from Selected Parts
                    </button>
                    
                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 8px; font-family: 'Azeret Mono', monospace; border-top: 1px solid var(--border); padding-top: 16px;">
                        Apply colour to saved group:
                    </div>
                    <select id="group-selector" onchange="selectGroup(this.value)" 
                            style="width: 100%; padding: 10px; margin-bottom: 8px; background: var(--bg-primary); border: 1px solid var(--border); color: var(--text-primary); border-radius: 6px; font-family: 'Rajdhani', sans-serif; cursor: pointer;">
                        <option value="">Select a group...</option>
                    </select>
                    
                    <div style="margin-bottom: 8px;">
                        <div style="font-size: 9px; color: var(--text-secondary); font-family: 'Azeret Mono', monospace; text-transform: uppercase; margin-bottom: 4px;">Group Colour:</div>
                        <select id="group-color-dropdown" onchange="updateGroupColorFromDropdown()" disabled style="width: 100%; padding: 10px; border-radius: 6px; background: var(--bg-primary); border: 1px solid var(--border); color: var(--text-primary); font-family: 'Rajdhani', sans-serif; cursor: pointer; font-size: 12px;">
                            <option value="">Pick a colour</option>
                        </select>
                    </div>
                    
                    <button class="action-btn secondary" onclick="deleteGroup()" id="delete-group-btn" disabled style="width: 100%; background: rgba(255, 0, 107, 0.1); border-color: var(--accent-magenta); color: var(--accent-magenta);">
                        üóë Delete Selected Group
                    </button>
                    
                    <button class="apply-multi-btn" onclick="colorAllGroupsRandomly()" style="width: 100%; margin-top: 8px; background: linear-gradient(135deg, rgba(138, 85, 247, 0.2), rgba(255, 107, 53, 0.2)); border-color: var(--accent-purple); color: var(--accent-purple);">
                        üé≤ Randomize All Group Colours
                    </button>
                </div>
            </div>

            <!-- Parts Section -->
            <div class="part-section">
                <div class="section-header">
                    <div class="section-header-left">
                        <span>Assembly Parts</span>
                    </div>
                    <div class="section-actions">
                        <button class="section-btn" onclick="expandAllParts()">Expand</button>
                        <button class="section-btn" onclick="collapseAllParts()">Collapse</button>
                        <button class="section-btn" onclick="lockAllParts()" title="Lock all parts">üîí Lock</button>
                        <button class="section-btn" onclick="unlockAllParts()" title="Unlock all parts">üîì Unlock</button>
                    </div>
                </div>
                <div id="parts-container">
                    <div class="empty-state">
                        No parts loaded yet.<br>
                        Upload STL files or load a project.
                    </div>
                </div>
            </div>
        </div>

        <div class="viewer">
            <div id="canvas-container"></div>
            
            <div style="position: absolute; top: 10px; left: 10px; background: rgba(10, 14, 23, 0.9); padding: 8px 12px; border-radius: 6px; border: 1px solid var(--border); font-size: 11px; color: var(--text-secondary); font-family: 'Azeret Mono', monospace; pointer-events: none; opacity: 0.8;">
                üí° Double-click a part to find it in the list
            </div>
            
            <div class="viewer-controls">
                <button class="control-btn" onclick="resetCamera()">Reset View</button>
                <button class="control-btn" onclick="frameModel()">Frame All</button>
                <button class="control-btn" id="measure-btn" onclick="toggleMeasure()">üìè Measure</button>
            </div>

            <div class="measurement-overlay" id="measurement-overlay">
                <div class="measurement-title">Measurement Tool</div>
                <div class="measurement-hint">Click two points to measure distance</div>
                <div class="measurement-value" id="measurement-value">--</div>
                <div id="bounding-box-info"></div>
            </div>

            <div class="info-overlay">
                <div><span class="info-label">ROTATE:</span>Left drag</div>
                <div><span class="info-label">PAN:</span>Right drag</div>
                <div><span class="info-label">ZOOM:</span>Scroll wheel</div>
                <div><span class="info-label">PARTS:</span><span id="part-count">0</span> loaded</div>
                <div id="project-name-display"></div>
            </div>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <script>
        // Scene setup
        let scene, camera, renderer, raycaster, mouse;
        let parts = [];
        let partFiles = {}; // Store original STL files
        let loader, exporter;
        let modelGroup;
        let measureMode = false;
        let measurePoints = [];
        let selectedParts = new Set();
        let groups = []; // Array of { name: string, parts: Set<number>, color: string }
        let selectedGroup = null;
        let animationFrameId = null; // Track animation frame for cleanup
        
        let presetColors = [
            // Row 1: Basic colors (most common)
            '#FFFFFF', // White (Pure White PLA)
            '#1C1C1C', // Black (True Black PLA)
            '#E63946', // Red (Fire Engine Red)
            '#2563EB', // Blue (Royal Blue)
            '#22C55E', // Green (Grass Green)
            
            // Row 2: Bright colors
            '#FCD34D', // Yellow (Bright Yellow)
            '#F97316', // Orange (Safety Orange)
            '#EC4899', // Pink (Hot Pink)
            '#7C3AED', // Purple (Deep Purple)
            '#38BDF8', // Sky Blue (Light Blue)
            
            // Row 3: Specialty colors
            '#9CA3AF', // Gray (Silver Gray)
            '#047857', // Dark Green (Forest Green)
            '#92400E', // Brown (Chocolate Brown)
            '#D4AF37', // Gold (Metallic Gold)
            '#F5F5DC'  // Natural/Beige (Transparent/Natural PLA)
        ];

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0e17);
            
            modelGroup = new THREE.Group();
            scene.add(modelGroup);
            
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 50, 150);
            camera.lookAt(0, 0, 0);
            
            const container = document.getElementById('canvas-container');
            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);
            
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(100, 100, 100);
            scene.add(mainLight);
            
            const fillLight = new THREE.DirectionalLight(0x00f5ff, 0.3);
            fillLight.position.set(-100, 0, -100);
            scene.add(fillLight);
            
            const rimLight = new THREE.DirectionalLight(0xff006b, 0.2);
            rimLight.position.set(0, -100, -100);
            scene.add(rimLight);
            
            loader = new THREE.STLLoader();
            exporter = new THREE.STLExporter();
            
            setupFileUpload();
            setupControls();
            animate();
            updateProjectDisplay();
            
            window.addEventListener('resize', onWindowResize);
            
            // Check if project URL is in URL parameters
            checkURLParameters();
            
            // Initialize GitHub project browser
            setTimeout(() => {
                initGitHubBrowser();
            }, 500);
        }

        function updateProjectDisplay() {
            const projectName = document.getElementById('project-name').value;
            document.getElementById('project-name-display').innerHTML = 
                `<span class="info-label">PROJECT:</span>${projectName}`;
        }

        // Update project name when changed
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('project-name').addEventListener('input', updateProjectDisplay);
        });

        // PROJECT SAVE/LOAD FUNCTIONS
        async function saveProject() {
            if (parts.length === 0) {
                showToast('‚ö†Ô∏è No parts to save');
                return;
            }

            try {
                const projectName = document.getElementById('project-name').value || 'Untitled Project';
                showToast('üíæ Saving project...');

                const zip = new JSZip();
                const stlFolder = zip.folder("stl_files");

                // Save all original STL files
                for (let i = 0; i < parts.length; i++) {
                    const part = parts[i];
                    const fileName = `${part.userData.name}.stl`;
                    
                    console.log(`Exporting part ${i}: ${fileName}`);
                    
                    // Create a temporary mesh with ONLY the geometry (no transforms)
                    const tempGeometry = part.geometry.clone();
                    const tempMesh = new THREE.Mesh(tempGeometry, new THREE.MeshBasicMaterial());
                    
                    // Export as binary STL
                    const stlData = exporter.parse(tempMesh, { binary: true });
                    
                    console.log(`STL data type: ${stlData.constructor.name}, length: ${stlData.byteLength || stlData.length}`);
                    
                    // Add to zip as binary
                    if (stlData instanceof DataView) {
                        // If it's a DataView, get the buffer
                        stlFolder.file(fileName, stlData.buffer, { binary: true });
                    } else if (stlData instanceof ArrayBuffer) {
                        stlFolder.file(fileName, stlData, { binary: true });
                    } else if (stlData instanceof Uint8Array) {
                        stlFolder.file(fileName, stlData, { binary: true });
                    } else {
                        // Fallback - treat as array and convert
                        const buffer = new Uint8Array(stlData);
                        stlFolder.file(fileName, buffer, { binary: true });
                    }
                    
                    // Cleanup
                    tempGeometry.dispose();
                    tempMesh.geometry.dispose();
                    tempMesh.material.dispose();
                }

                // Save project configuration
                const projectData = {
                    projectName: projectName,
                    version: "1.0",
                    created: new Date().toISOString(),
                    parts: parts.map(part => ({
                        name: part.userData.name,
                        fileName: `${part.userData.name}.stl`,
                        color: part.userData.color,
                        visible: part.userData.visible,
                        position: part.userData.position,
                        rotation: part.userData.rotation,
                        locked: part.userData.locked
                    })),
                    groups: groups.map(g => ({
                        name: g.name,
                        parts: Array.from(g.parts),
                        color: g.color || '#ffffff'
                    }))
                };

                zip.file("project.json", JSON.stringify(projectData, null, 2));

                console.log('Generating ZIP file...');
                
                // Generate and download zip
                const content = await zip.generateAsync({ 
                    type: "blob",
                    compression: "DEFLATE",
                    compressionOptions: { level: 6 }
                });
                
                console.log('ZIP generated, size:', content.size);
                
                const url = URL.createObjectURL(content);
                const link = document.createElement('a');
                link.href = url;
                link.download = `${projectName.replace(/[^a-z0-9]/gi, '_')}.stlproject`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                setTimeout(() => {
                    URL.revokeObjectURL(url);
                }, 100);

                showToast(`üíæ Project "${projectName}" saved successfully!`);
                console.log('Project saved successfully');
                
            } catch (err) {
                console.error('Save project error:', err);
                console.error('Error stack:', err.stack);
                showToast('‚ö†Ô∏è Error saving project: ' + err.message);
            }
        }

        async function loadProject() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.stlproject';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                showToast('üìÇ Loading project...');

                try {
                    console.log('=== Loading Project ===');
                    console.log('File:', file.name, 'Size:', file.size);
                    
                    const zip = await JSZip.loadAsync(file);
                    console.log('ZIP loaded successfully');
                    
                    // Read project configuration
                    const projectJsonFile = zip.file("project.json");
                    if (!projectJsonFile) {
                        throw new Error('Invalid project file - missing project.json');
                    }

                    const projectJsonText = await projectJsonFile.async("text");
                    const projectData = JSON.parse(projectJsonText);
                    console.log('Project data:', projectData);

                    // Validate project data
                    if (!projectData.parts || projectData.parts.length === 0) {
                        throw new Error('Project has no parts');
                    }

                    // Clear existing parts
                    clearAllSilent();

                    // Set project name
                    document.getElementById('project-name').value = projectData.projectName;
                    updateProjectDisplay();

                    // Load STL files
                    const stlFolder = zip.folder("stl_files");
                    if (!stlFolder) {
                        throw new Error('Invalid project file - missing stl_files folder');
                    }
                    
                    console.log(`Loading ${projectData.parts.length} parts...`);
                    
                    const loadedParts = [];
                    const failedParts = [];

                    // Load parts sequentially for better error handling
                    for (const partData of projectData.parts) {
                        try {
                            console.log(`Loading part: ${partData.name} (${partData.fileName})`);
                            
                            const stlFile = stlFolder.file(partData.fileName);
                            if (!stlFile) {
                                console.warn(`STL file not found: ${partData.fileName}`);
                                failedParts.push(partData.name);
                                continue;
                            }
                            
                            // Get the file as arraybuffer with validation
                            const arrayBuffer = await stlFile.async("arraybuffer");
                            
                            if (!arrayBuffer || arrayBuffer.byteLength === 0) {
                                console.error(`Empty STL file: ${partData.fileName}`);
                                failedParts.push(partData.name);
                                continue;
                            }
                            
                            console.log(`STL data loaded: ${arrayBuffer.byteLength} bytes`);
                            
                            await loadSTLFromBuffer(arrayBuffer, partData);
                            loadedParts.push(partData.name);
                            
                        } catch (partErr) {
                            console.error(`Failed to load part ${partData.name}:`, partErr);
                            failedParts.push(partData.name);
                        }
                    }

                    console.log(`Parts loaded: ${loadedParts.length}/${projectData.parts.length}`);
                    
                    if (loadedParts.length === 0) {
                        throw new Error('No parts could be loaded from project');
                    }

                    frameModel();
                    
                    // Restore groups if present
                    if (projectData.groups && Array.isArray(projectData.groups)) {
                        groups = projectData.groups.map(g => ({
                            name: g.name,
                            parts: new Set(g.parts),
                            color: g.color || '#ffffff'
                        }));
                        renderGroupSelector();
                        console.log('Groups restored:', groups.length);
                    }
                    
                    // Show success/warning message
                    if (failedParts.length === 0) {
                        showToast(`üìÇ Project "${projectData.projectName}" loaded successfully!`);
                    } else {
                        showToast(`‚ö†Ô∏è Loaded ${loadedParts.length}/${projectData.parts.length} parts (${failedParts.length} failed)`);
                        console.warn('Failed parts:', failedParts);
                    }
                    
                    console.log('=== Project Load Complete ===');

                } catch (err) {
                    console.error('=== Load Project Error ===');
                    console.error('Error:', err);
                    console.error('Stack:', err.stack);
                    
                    showToast('‚ö†Ô∏è Error loading project: ' + err.message);
                    
                    // Show detailed error in UI
                    const errorDetail = document.createElement('div');
                    errorDetail.style.cssText = 'position: fixed; top: 100px; left: 50%; transform: translateX(-50%); background: rgba(255, 0, 107, 0.95); color: white; padding: 20px; border-radius: 8px; z-index: 10000; max-width: 500px; box-shadow: 0 8px 32px rgba(0,0,0,0.5);';
                    errorDetail.innerHTML = `
                        <strong style="font-size: 18px;">Project Load Error:</strong><br><br>
                        <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 4px; margin: 10px 0;">
                            ${err.message}
                        </div>
                        <small style="opacity: 0.8;">Check console (F12) for detailed error information</small><br><br>
                        <button onclick="this.parentElement.remove()" style="width: 100%; margin-top: 10px; padding: 10px; background: white; color: #ff006b; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 14px;">Close</button>
                    `;
                    document.body.appendChild(errorDetail);
                    setTimeout(() => errorDetail.remove(), 15000);
                }
            };
            input.click();
        }
        
        // Load project from URL (GitHub, direct link, etc.)
        async function loadProjectFromURL(urlParam = null) {
            let url = urlParam;
            
            // If no URL provided, get from input field
            if (!url) {
                const urlInput = document.getElementById('project-url-input');
                url = urlInput ? urlInput.value.trim() : '';
            }
            
            if (!url) {
                showToast('‚ö†Ô∏è Please enter a project URL');
                return;
            }
            
            // Validate URL
            try {
                new URL(url);
            } catch (e) {
                showToast('‚ö†Ô∏è Invalid URL format');
                return;
            }
            
            showToast('üåê Loading project from URL...');
            console.log('=== Loading Project from URL ===');
            console.log('URL:', url);
            
            try {
                // Fetch the project file
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch: ${response.status} ${response.statusText}`);
                }
                
                const blob = await response.blob();
                console.log('Downloaded blob, size:', blob.size);
                
                // Convert blob to file for consistent handling
                const file = new File([blob], 'project.stlproject', { type: 'application/zip' });
                
                // Load using existing logic
                const zip = await JSZip.loadAsync(file);
                console.log('ZIP loaded successfully');
                
                // Read project configuration
                const projectJsonFile = zip.file("project.json");
                if (!projectJsonFile) {
                    throw new Error('Invalid project file - missing project.json');
                }

                const projectJsonText = await projectJsonFile.async("text");
                const projectData = JSON.parse(projectJsonText);
                console.log('Project data:', projectData);

                // Validate project data
                if (!projectData.parts || projectData.parts.length === 0) {
                    throw new Error('Project has no parts');
                }

                // Clear existing parts
                clearAllSilent();

                // Set project name
                document.getElementById('project-name').value = projectData.projectName;
                updateProjectDisplay();

                // Load STL files
                const stlFolder = zip.folder("stl_files");
                if (!stlFolder) {
                    throw new Error('Invalid project file - missing stl_files folder');
                }
                
                console.log(`Loading ${projectData.parts.length} parts...`);
                
                const loadedParts = [];
                const failedParts = [];

                // Load parts sequentially
                for (const partData of projectData.parts) {
                    try {
                        console.log(`Loading part: ${partData.name} (${partData.fileName})`);
                        
                        const stlFile = stlFolder.file(partData.fileName);
                        if (!stlFile) {
                            console.warn(`STL file not found: ${partData.fileName}`);
                            failedParts.push(partData.name);
                            continue;
                        }
                        
                        const arrayBuffer = await stlFile.async("arraybuffer");
                        await loadSTLFromBuffer(arrayBuffer, partData);
                        loadedParts.push(partData.name);
                        
                    } catch (partErr) {
                        console.error(`Error loading part ${partData.name}:`, partErr);
                        failedParts.push(partData.name);
                    }
                }

                // Restore groups if present
                if (projectData.groups && Array.isArray(projectData.groups)) {
                    groups = projectData.groups.map(g => ({
                        name: g.name,
                        parts: new Set(g.parts),
                        color: g.color || '#ffffff'
                    }));
                    renderGroupSelector();
                    console.log('Groups restored:', groups.length);
                }
                
                frameModel();
                
                if (failedParts.length === 0) {
                    showToast(`‚úì Project "${projectData.projectName}" loaded from URL!`);
                } else {
                    showToast(`‚ö†Ô∏è Loaded ${loadedParts.length}/${projectData.parts.length} parts (${failedParts.length} failed)`);
                    console.warn('Failed parts:', failedParts);
                }
                
                // Clear URL input on success
                const urlInput = document.getElementById('project-url-input');
                if (urlInput && !urlParam) urlInput.value = '';
                
                console.log('=== Project Load from URL Complete ===');

            } catch (err) {
                console.error('=== Load Project from URL Error ===');
                console.error('Error:', err);
                console.error('Stack:', err.stack);
                
                let errorMsg = err.message;
                
                // Provide helpful error messages
                if (err.message.includes('Failed to fetch')) {
                    errorMsg = 'Cannot load file. Check: 1) URL is correct, 2) File is publicly accessible, 3) CORS is enabled';
                }
                
                showToast('‚ö†Ô∏è Error loading from URL: ' + errorMsg);
                
                // Show detailed error
                const errorDetail = document.createElement('div');
                errorDetail.style.cssText = 'position: fixed; top: 100px; left: 50%; transform: translateX(-50%); background: rgba(255, 0, 107, 0.95); color: white; padding: 20px; border-radius: 8px; z-index: 10000; max-width: 500px; box-shadow: 0 8px 32px rgba(0,0,0,0.5);';
                errorDetail.innerHTML = `
                    <strong style="font-size: 18px;">Load from URL Error:</strong><br><br>
                    <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 4px; margin: 10px 0; word-break: break-all;">
                        ${errorMsg}
                    </div>
                    <div style="font-size: 11px; opacity: 0.9; margin: 10px 0;">
                        <strong>For GitHub files:</strong><br>
                        Use "raw" URL format:<br>
                        <code style="background: rgba(0,0,0,0.3); padding: 4px; border-radius: 3px; display: block; margin: 4px 0;">
                        https://raw.githubusercontent.com/<br>username/repo/branch/file.stlproject
                        </code>
                    </div>
                    <small style="opacity: 0.8;">Check console (F12) for detailed error information</small><br><br>
                    <button onclick="this.parentElement.remove()" style="width: 100%; margin-top: 10px; padding: 10px; background: white; color: #ff006b; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 14px;">Close</button>
                `;
                document.body.appendChild(errorDetail);
                setTimeout(() => errorDetail.remove(), 20000);
            }
        }
        
        // Check URL parameters on page load for auto-loading
        function checkURLParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const projectURL = urlParams.get('project');
            
            if (projectURL) {
                console.log('Auto-loading project from URL parameter:', projectURL);
                // Wait a bit for page to fully load
                setTimeout(() => {
                    loadProjectFromURL(projectURL);
                }, 1000);
            }
        }
        
        // GitHub Repository Browser Functions
        function getGitHubSettings() {
            return {
                owner: localStorage.getItem('github-owner') || document.getElementById('github-owner')?.value || 'MrBaristaNZ',
                repo: localStorage.getItem('github-repo') || document.getElementById('github-repo')?.value || 'printpalette',
                path: localStorage.getItem('github-path') || document.getElementById('github-path')?.value || 'Projects/Blasters/Leedle Dynamics'
            };
        }
        
        function saveGitHubSettings() {
            const owner = document.getElementById('github-owner').value.trim();
            const repo = document.getElementById('github-repo').value.trim();
            const path = document.getElementById('github-path').value.trim();
            
            if (!owner || !repo) {
                showToast('‚ö†Ô∏è Owner and Repository are required');
                return;
            }
            
            localStorage.setItem('github-owner', owner);
            localStorage.setItem('github-repo', repo);
            localStorage.setItem('github-path', path);
            
            showToast('‚úì Settings saved');
            refreshGitHubProjects();
        }
        
        async function testGitHubPath() {
            const owner = document.getElementById('github-owner').value.trim();
            const repo = document.getElementById('github-repo').value.trim();
            const path = document.getElementById('github-path').value.trim();
            
            if (!owner || !repo) {
                showToast('‚ö†Ô∏è Owner and Repository are required');
                return;
            }
            
            console.log('=== Testing GitHub Path ===');
            console.log('Owner:', owner);
            console.log('Repo:', repo);
            console.log('Path:', path);
            
            // Encode path properly
            const pathSegments = path ? path.split('/').map(seg => encodeURIComponent(seg.trim())) : [];
            const encodedPath = pathSegments.join('/');
            
            const apiUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${encodedPath}`;
            console.log('Full API URL:', apiUrl);
            
            showToast('üß™ Testing path...');
            
            try {
                const response = await fetch(apiUrl, {
                    headers: {
                        'Accept': 'application/vnd.github.v3+json'
                    }
                });
                
                console.log('Response status:', response.status);
                console.log('Response headers:', response.headers);
                
                if (response.status === 200) {
                    const data = await response.json();
                    const fileCount = Array.isArray(data) ? data.length : 1;
                    const stlProjects = Array.isArray(data) ? data.filter(f => f.name.endsWith('.stlproject')).length : 0;
                    
                    console.log('Success! Found', fileCount, 'items');
                    console.log('STL projects:', stlProjects);
                    
                    showToast(`‚úì Path works! Found ${fileCount} files (${stlProjects} .stlproject)`);
                    
                    // Show detailed info
                    const infoDiv = document.createElement('div');
                    infoDiv.style.cssText = 'position: fixed; top: 100px; left: 50%; transform: translateX(-50%); background: rgba(0, 255, 136, 0.95); color: white; padding: 20px; border-radius: 8px; z-index: 10000; max-width: 500px; box-shadow: 0 8px 32px rgba(0,0,0,0.5);';
                    infoDiv.innerHTML = `
                        <strong style="font-size: 16px;">‚úì Path Test Successful!</strong><br><br>
                        <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 4px; font-size: 11px; font-family: monospace;">
                            ${owner}/${repo}/${path}
                        </div><br>
                        <strong>Found:</strong> ${fileCount} total files<br>
                        <strong>.stlproject files:</strong> ${stlProjects}<br><br>
                        ${stlProjects > 0 ? '‚úÖ Ready to use! Click "Save & Refresh"' : '‚ö†Ô∏è No .stlproject files in this folder'}
                        <br><br>
                        <button onclick="this.parentElement.remove()" style="width: 100%; padding: 10px; background: white; color: #00ff88; border: none; border-radius: 6px; cursor: pointer; font-weight: bold;">Close</button>
                    `;
                    document.body.appendChild(infoDiv);
                    setTimeout(() => infoDiv.remove(), 10000);
                    
                } else if (response.status === 404) {
                    const errorData = await response.json().catch(() => ({}));
                    console.error('404 error:', errorData);
                    
                    showToast('‚ùå Path not found');
                    
                    // Show help
                    const helpDiv = document.createElement('div');
                    helpDiv.style.cssText = 'position: fixed; top: 100px; left: 50%; transform: translateX(-50%); background: rgba(255, 0, 107, 0.95); color: white; padding: 20px; border-radius: 8px; z-index: 10000; max-width: 500px; box-shadow: 0 8px 32px rgba(0,0,0,0.5);';
                    helpDiv.innerHTML = `
                        <strong style="font-size: 16px;">‚ùå Path Not Found</strong><br><br>
                        <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 4px; font-size: 11px; font-family: monospace; word-break: break-all;">
                            ${apiUrl}
                        </div><br>
                        <strong>Possible issues:</strong><br>
                        ‚Ä¢ Owner/repo name wrong<br>
                        ‚Ä¢ Folder path wrong (case-sensitive!)<br>
                        ‚Ä¢ Folder doesn't exist<br>
                        ‚Ä¢ Repository is private<br><br>
                        <strong>How to find correct path:</strong><br>
                        1. Open your repo on GitHub<br>
                        2. Navigate to the folder<br>
                        3. Look at URL: <code style="background: rgba(0,0,0,0.3); padding: 2px 4px; border-radius: 3px;">.../tree/main/YOUR/PATH</code><br>
                        4. Copy "YOUR/PATH" part<br><br>
                        <button onclick="this.parentElement.remove()" style="width: 100%; padding: 10px; background: white; color: #ff006b; border: none; border-radius: 6px; cursor: pointer; font-weight: bold;">Close</button>
                    `;
                    document.body.appendChild(helpDiv);
                    setTimeout(() => helpDiv.remove(), 20000);
                    
                } else {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
            } catch (error) {
                console.error('Test failed:', error);
                showToast('‚ùå Test failed: ' + error.message);
            }
            
            console.log('=== Test Complete ===');
        }
        
        function loadGitHubSettings() {
            const settings = getGitHubSettings();
            
            const ownerInput = document.getElementById('github-owner');
            const repoInput = document.getElementById('github-repo');
            const pathInput = document.getElementById('github-path');
            
            if (ownerInput) ownerInput.value = settings.owner;
            if (repoInput) repoInput.value = settings.repo;
            if (pathInput) pathInput.value = settings.path;
            
            // Update info display
            const infoSpan = document.getElementById('github-repo-info');
            if (infoSpan) {
                infoSpan.textContent = `${settings.owner}/${settings.repo}/${settings.path}`;
            }
        }
        
        async function refreshGitHubProjects() {
            const dropdown = document.getElementById('github-project-dropdown');
            const settings = getGitHubSettings();
            
            if (!dropdown) return;
            
            // Clear dropdown
            dropdown.innerHTML = '<option value="">Loading...</option>';
            dropdown.disabled = true;
            
            console.log('=== Fetching GitHub Projects ===');
            console.log('Settings:', settings);
            
            try {
                // Encode path properly - each segment separately
                const pathSegments = settings.path.split('/').map(seg => encodeURIComponent(seg.trim()));
                const encodedPath = pathSegments.join('/');
                
                // Construct GitHub API URL
                const apiUrl = `https://api.github.com/repos/${settings.owner}/${settings.repo}/contents/${encodedPath}`;
                console.log('API URL:', apiUrl);
                console.log('Encoded path:', encodedPath);
                
                const response = await fetch(apiUrl, {
                    headers: {
                        'Accept': 'application/vnd.github.v3+json'
                    }
                });
                
                console.log('Response status:', response.status);
                console.log('Response OK:', response.ok);
                
                if (!response.ok) {
                    if (response.status === 404) {
                        // Try to get more specific error
                        const errorData = await response.json().catch(() => ({}));
                        console.error('404 Error details:', errorData);
                        
                        throw new Error(`Path not found: "${settings.path}"\n\nCheck:\n1. Path spelling (case-sensitive)\n2. Folder exists in repo\n3. No extra spaces`);
                    }
                    if (response.status === 403) {
                        throw new Error('Rate limit exceeded. Wait a minute and try again.');
                    }
                    throw new Error(`GitHub API error: ${response.status} ${response.statusText}`);
                }
                
                const files = await response.json();
                console.log('Files received:', files);
                console.log('Total files:', Array.isArray(files) ? files.length : 'Not an array');
                
                // Handle non-array response (might be a single file)
                if (!Array.isArray(files)) {
                    throw new Error('Invalid response from GitHub. Check if path points to a folder (not a file).');
                }
                
                // Filter for .stlproject files
                const projects = files.filter(file => 
                    file.type === 'file' && 
                    file.name.toLowerCase().endsWith('.stlproject')
                );
                
                console.log('Project files found:', projects.length);
                console.log('Project names:', projects.map(p => p.name));
                
                // Populate dropdown
                dropdown.innerHTML = '<option value="">Select a project...</option>';
                
                if (projects.length === 0) {
                    // Show what files were found
                    const fileList = files.map(f => f.name).join(', ');
                    console.log('All files in folder:', fileList);
                    dropdown.innerHTML += `<option value="" disabled>No .stlproject files found (Found: ${files.length} other files)</option>`;
                } else {
                    projects.forEach(project => {
                        const option = document.createElement('option');
                        option.value = project.download_url;
                        option.textContent = project.name.replace('.stlproject', '');
                        dropdown.appendChild(option);
                    });
                }
                
                dropdown.disabled = false;
                
                if (projects.length === 0) {
                    showToast(`‚ö†Ô∏è No .stlproject files in this folder`);
                } else {
                    showToast(`‚úì Found ${projects.length} project(s)`);
                }
                
                // Update info display
                const infoSpan = document.getElementById('github-repo-info');
                if (infoSpan) {
                    if (projects.length === 0) {
                        infoSpan.innerHTML = `<span style="color: var(--accent-yellow);">‚ö†</span> ${files.length} files found, but no .stlproject files`;
                    } else {
                        infoSpan.innerHTML = `<span style="color: var(--accent-green);">‚úì</span> ${projects.length} project(s) in ${settings.owner}/${settings.repo}`;
                    }
                }
                
                console.log('=== GitHub Fetch Complete ===');
                
            } catch (error) {
                console.error('=== Error fetching GitHub projects ===');
                console.error('Error:', error);
                console.error('Message:', error.message);
                console.error('Stack:', error.stack);
                
                dropdown.innerHTML = '<option value="">Error - Check settings</option>';
                dropdown.disabled = false;
                
                showToast('‚ö†Ô∏è ' + error.message.split('\n')[0]);
                
                // Update info display
                const infoSpan = document.getElementById('github-repo-info');
                if (infoSpan) {
                    infoSpan.innerHTML = `<span style="color: var(--accent-magenta);">‚úó</span> Error - Check console (F12)`;
                }
            }
        }
        
        function loadSelectedGitHubProject() {
            const dropdown = document.getElementById('github-project-dropdown');
            const url = dropdown ? dropdown.value : '';
            
            if (!url) return;
            
            console.log('Loading selected GitHub project:', url);
            loadProjectFromURL(url);
            
            // Reset dropdown selection
            setTimeout(() => {
                if (dropdown) dropdown.value = '';
            }, 500);
        }
        
        // Initialize GitHub browser on page load
        function initGitHubBrowser() {
            loadGitHubSettings();
            refreshGitHubProjects();
        }

        function loadSTLFromBuffer(arrayBuffer, partData) {
            return new Promise((resolve, reject) => {
                try {
                    console.log(`Loading STL buffer for ${partData.name}, size: ${arrayBuffer.byteLength} bytes`);
                    
                    // Validate the arrayBuffer
                    if (!arrayBuffer || arrayBuffer.byteLength === 0) {
                        throw new Error(`Invalid or empty STL data for ${partData.name}`);
                    }
                    
                    // Parse the STL geometry
                    const geometry = loader.parse(arrayBuffer);
                    
                    if (!geometry || !geometry.attributes || !geometry.attributes.position) {
                        throw new Error(`Failed to parse STL geometry for ${partData.name}`);
                    }
                    
                    console.log(`Geometry loaded: ${geometry.attributes.position.count} vertices`);
                    
                    const material = new THREE.MeshStandardMaterial({
                        color: partData.color,
                        metalness: 0.3,
                        roughness: 0.4,
                        flatShading: false
                    });
                    
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.userData = {
                        name: partData.name,
                        visible: partData.visible !== undefined ? partData.visible : true,
                        color: partData.color,
                        position: partData.position || { x: 0, y: 0, z: 0 },
                        rotation: partData.rotation || { x: 0, y: 0, z: 0 },
                        locked: partData.locked || false
                    };

                    // Apply transformations
                    mesh.position.set(
                        mesh.userData.position.x,
                        mesh.userData.position.y,
                        mesh.userData.position.z
                    );

                    mesh.rotation.set(
                        mesh.userData.rotation.x * (Math.PI / 180),
                        mesh.userData.rotation.y * (Math.PI / 180),
                        mesh.userData.rotation.z * (Math.PI / 180)
                    );

                    mesh.visible = mesh.userData.visible;
                    
                    modelGroup.add(mesh);
                    parts.push(mesh);
                    
                    addPartControl(parts.length - 1);
                    updatePartCount();
                    updateBoundingBox();
                    updateCoordinates(parts.length - 1);

                    // Apply locked state if needed
                    if (mesh.userData.locked) {
                        setTimeout(() => {
                            const lockBtn = document.getElementById(`lock-btn-${parts.length - 1}`);
                            const card = document.getElementById(`part-card-${parts.length - 1}`);
                            if (lockBtn && card) {
                                lockBtn.classList.add('locked');
                                lockBtn.textContent = 'üîí';
                                card.classList.add('locked');
                            }
                        }, 100);
                    }
                    
                    // Apply hidden state if needed
                    if (!mesh.userData.visible) {
                        setTimeout(() => {
                            const visBtn = document.getElementById(`vis-btn-${parts.length - 1}`);
                            const card = document.getElementById(`part-card-${parts.length - 1}`);
                            if (visBtn && card) {
                                visBtn.classList.add('hidden-btn');
                                visBtn.classList.remove('visibility');
                                visBtn.textContent = '‚®Ø';
                                card.classList.add('hidden-part');
                            }
                        }, 100);
                    }

                    console.log(`Part ${partData.name} loaded successfully`);
                    resolve();
                    
                } catch (err) {
                    console.error(`Error loading part ${partData.name}:`, err);
                    reject(err);
                }
            });
        }

        function clearAllSilent() {
            console.log('Clearing all parts with proper disposal...');
            
            // Dispose of all parts properly
            parts.forEach(part => {
                // Remove from scene first
                modelGroup.remove(part);
                
                // Dispose geometry
                if (part.geometry) {
                    part.geometry.dispose();
                }
                
                // Dispose material and textures
                if (part.material) {
                    if (part.material.map) part.material.map.dispose();
                    if (part.material.lightMap) part.material.lightMap.dispose();
                    if (part.material.bumpMap) part.material.bumpMap.dispose();
                    if (part.material.normalMap) part.material.normalMap.dispose();
                    if (part.material.specularMap) part.material.specularMap.dispose();
                    if (part.material.envMap) part.material.envMap.dispose();
                    part.material.dispose();
                }
            });
            
            // Clear arrays completely
            parts.length = 0;
            partFiles = {};
            selectedParts.clear();
            groups.length = 0;
            selectedGroup = null;
            
            // Reset project name
            const projectNameInput = document.getElementById('project-name');
            if (projectNameInput) {
                projectNameInput.value = 'Untitled Project';
            }
            
            // Rebuild UI
            rebuildUI();
            updatePartCount();
            updateBoundingBox();
            renderGroupSelector();
            
            console.log('All parts cleared and memory freed');
        }

        // Part Selection for Group Creation
        function togglePartSelection(index) {
            console.log('Toggle part selection:', index);
            
            const checkbox = document.getElementById(`checkbox-${index}`);
            const card = document.getElementById(`part-card-${index}`);
            
            if (!checkbox || !card) {
                console.error('Could not find checkbox or card!');
                return;
            }
            
            // If a group is selected, manage group membership
            if (selectedGroup) {
                if (selectedGroup.parts.has(index)) {
                    // Remove from group
                    selectedGroup.parts.delete(index);
                    checkbox.classList.remove('checked');
                    checkbox.textContent = '';
                    card.classList.remove('selected');
                    showToast(`‚úì Removed from "${selectedGroup.name}"`);
                } else {
                    // Add to group
                    selectedGroup.parts.add(index);
                    checkbox.classList.add('checked');
                    checkbox.textContent = '‚úì';
                    card.classList.add('selected');
                    
                    // Apply group color if it has one
                    if (selectedGroup.color && parts[index]) {
                        animatePartColorChange(parts[index], selectedGroup.color);
                        parts[index].userData.color = selectedGroup.color;
                        
                        // Update dropdown
                        const colorDropdown = document.getElementById(`part-color-dropdown-${index}`);
                        if (colorDropdown) {
                            colorDropdown.value = selectedGroup.color;
                            colorDropdown.style.backgroundColor = selectedGroup.color;
                            colorDropdown.style.color = '#fff';
                            colorDropdown.style.borderColor = selectedGroup.color;
                            colorDropdown.style.borderWidth = '2px';
                        }
                    }
                    
                    showToast(`‚úì Added to "${selectedGroup.name}"`);
                }
                
                // Update group selector to show new part count
                renderGroupSelector();
                
                console.log('Group updated:', selectedGroup.name, 'Parts:', Array.from(selectedGroup.parts));
            } else {
                // No group selected - normal selection for creating new group
                if (selectedParts.has(index)) {
                    selectedParts.delete(index);
                    checkbox.classList.remove('checked');
                    checkbox.textContent = '';
                    card.classList.remove('selected');
                } else {
                    selectedParts.add(index);
                    checkbox.classList.add('checked');
                    checkbox.textContent = '‚úì';
                    card.classList.add('selected');
                }
                
                console.log('Selected parts:', Array.from(selectedParts));
            }
        }

        // Group Management Functions
        function createGroup() {
            const nameInput = document.getElementById('new-group-name');
            const name = nameInput.value.trim();
            
            if (!name) {
                showToast('‚ö†Ô∏è Enter a group name first');
                return;
            }
            
            if (selectedParts.size === 0) {
                showToast('‚ö†Ô∏è Select parts first (use checkboxes ‚úì)');
                return;
            }
            
            // Avoid duplicates
            if (groups.some(g => g.name === name)) {
                showToast('‚ö†Ô∏è Group "' + name + '" already exists');
                return;
            }
            
            // Get color from dropdown
            const colorDropdown = document.getElementById('group-color-dropdown');
            const selectedColor = colorDropdown ? colorDropdown.value : '#ffffff';
            
            if (!selectedColor || selectedColor === '') {
                showToast('‚ö†Ô∏è Select a colour from the dropdown first');
                return;
            }
            
            // Create new group with current selection and color
            const groupPartsCount = selectedParts.size;
            groups.push({ 
                name, 
                parts: new Set(selectedParts),
                color: selectedColor
            });
            
            nameInput.value = '';
            
            // Reset dropdown appearance
            if (colorDropdown) {
                colorDropdown.value = '';
                colorDropdown.style.backgroundColor = 'var(--bg-primary)';
                colorDropdown.style.color = 'var(--text-primary)';
                colorDropdown.style.borderColor = 'var(--border)';
            }
            
            // Clear selection visually
            selectedParts.forEach(index => {
                const checkbox = document.getElementById(`checkbox-${index}`);
                const card = document.getElementById(`part-card-${index}`);
                if (checkbox) {
                    checkbox.classList.remove('checked');
                    checkbox.textContent = '';
                }
                if (card) {
                    card.classList.remove('selected');
                }
            });
            
            // Store selected parts before clearing
            const partsInNewGroup = Array.from(selectedParts);
            selectedParts.clear();
            
            renderGroupSelector();
            
            showToast(`‚úì Group "${name}" created with ${groupPartsCount} part(s)`);
            
            console.log('Group created:', name, 'Color:', selectedColor);
        }

        function renderGroupSelector() {
            const selector = document.getElementById('group-selector');
            if (!selector) return;
            
            // Remember current selection
            const currentIndex = selector.value;
            
            selector.innerHTML = '<option value="">Select a group...</option>';
            
            groups.forEach((group, i) => {
                const color = group.color || '#ffffff';
                const option = document.createElement('option');
                option.value = i;
                option.textContent = `üî∑ ${group.name} (${group.parts.size} parts)`;
                option.style.color = color;
                option.style.fontWeight = 'bold';
                selector.appendChild(option);
            });
            
            // Restore selection if it was set
            if (selectedGroup && currentIndex !== '') {
                // Find the index of the currently selected group
                const index = groups.findIndex(g => g.name === selectedGroup.name);
                if (index !== -1) {
                    selector.value = index;
                }
            }
            
            console.log('Group selector rendered with', groups.length, 'groups');
        }

        function selectGroup(index) {
            const deleteBtn = document.getElementById('delete-group-btn');
            const colorDropdown = document.getElementById('group-color-dropdown');
            
            if (index === '' || index === null) {
                selectedGroup = null;
                
                // Clear all checkboxes when no group selected
                parts.forEach((part, idx) => {
                    const checkbox = document.getElementById(`checkbox-${idx}`);
                    const card = document.getElementById(`part-card-${idx}`);
                    if (checkbox) {
                        checkbox.classList.remove('checked');
                        checkbox.textContent = '';
                    }
                    if (card) {
                        card.classList.remove('selected');
                    }
                });
                
                // Reset dropdown
                if (colorDropdown) {
                    colorDropdown.value = '';
                    colorDropdown.style.backgroundColor = 'var(--bg-primary)';
                    colorDropdown.style.color = 'var(--text-primary)';
                    colorDropdown.style.borderColor = 'var(--border)';
                    colorDropdown.style.borderWidth = '1px';
                    colorDropdown.disabled = true;
                }
                
                if (deleteBtn) deleteBtn.disabled = true;
                return;
            }
            
            selectedGroup = groups[parseInt(index)];
            console.log('Group selected:', selectedGroup.name, 'Parts:', Array.from(selectedGroup.parts), 'Color:', selectedGroup.color);
            
            // Check/uncheck parts based on group membership
            parts.forEach((part, idx) => {
                const checkbox = document.getElementById(`checkbox-${idx}`);
                const card = document.getElementById(`part-card-${idx}`);
                
                if (selectedGroup.parts.has(idx)) {
                    // Part is in group - check it
                    if (checkbox) {
                        checkbox.classList.add('checked');
                        checkbox.textContent = '‚úì';
                    }
                    if (card) {
                        card.classList.add('selected');
                    }
                } else {
                    // Part is not in group - uncheck it
                    if (checkbox) {
                        checkbox.classList.remove('checked');
                        checkbox.textContent = '';
                    }
                    if (card) {
                        card.classList.remove('selected');
                    }
                }
            });
            
            // Enable colour dropdown for this group
            if (colorDropdown) {
                colorDropdown.disabled = false;
                
                // Load the group's current colour if it has one
                if (selectedGroup.color) {
                    colorDropdown.value = selectedGroup.color;
                    colorDropdown.style.backgroundColor = selectedGroup.color;
                    colorDropdown.style.color = '#fff';
                    colorDropdown.style.fontWeight = '600';
                    colorDropdown.style.borderColor = selectedGroup.color;
                    colorDropdown.style.borderWidth = '2px';
                } else {
                    // No colour yet - reset to default
                    colorDropdown.value = '';
                    colorDropdown.style.backgroundColor = 'var(--bg-primary)';
                    colorDropdown.style.color = 'var(--text-primary)';
                    colorDropdown.style.borderColor = 'var(--border)';
                    colorDropdown.style.borderWidth = '1px';
                }
            }
            
            // Enable delete button
            if (deleteBtn) {
                deleteBtn.disabled = false;
            }
        }

        function animatePartColorChange(mesh, targetColor, duration = 500) {
            const start = mesh.material.color.clone();
            const end = new THREE.Color(targetColor);
            const startTime = performance.now();

            function animate() {
                const elapsed = performance.now() - startTime;
                const t = Math.min(1, elapsed / duration);
                mesh.material.color.r = start.r + (end.r - start.r) * t;
                mesh.material.color.g = start.g + (end.g - start.g) * t;
                mesh.material.color.b = start.b + (end.b - start.b) * t;

                if (t < 1) requestAnimationFrame(animate);
            }
            animate();
        }

        function applyColorToGroup() {
            if (!selectedGroup) {
                showToast('‚ö†Ô∏è Select a group first');
                return;
            }
            
            const colorDropdown = document.getElementById('group-color-dropdown');
            const selectedColor = colorDropdown ? colorDropdown.value : '#ff006b';
            
            if (!selectedColor || selectedColor === '') {
                showToast('‚ö†Ô∏è Select a colour from the dropdown first');
                return;
            }
            
            console.log('=== Manual Re-apply Color to Group ===');
            console.log('Group:', selectedGroup.name);
            console.log('Color value:', selectedColor);
            
            let successCount = 0;
            
            selectedGroup.parts.forEach(idx => {
                if (parts[idx]) {
                    animatePartColorChange(parts[idx], selectedColor);
                    parts[idx].userData.color = selectedColor;
                    
                    // Update dropdown
                    const dropdown = document.getElementById(`part-color-dropdown-${idx}`);
                    if (dropdown) {
                        dropdown.value = selectedColor;
                        dropdown.style.backgroundColor = selectedColor;
                        dropdown.style.color = '#fff';
                        dropdown.style.borderColor = selectedColor;
                        dropdown.style.borderWidth = '2px';
                    }
                    successCount++;
                }
            });
            
            // Save color to group
            selectedGroup.color = selectedColor;
            renderGroupSelector();
            
            showToast(`‚úì Re-applied ${selectedColor.toUpperCase()} to "${selectedGroup.name}" (${successCount} parts)`);
            console.log('Color re-applied successfully');
        }

        function updateGroupColorFromDropdown() {
            const dropdown = document.getElementById('group-color-dropdown');
            
            if (!dropdown) {
                console.warn('Colour dropdown not found');
                return;
            }
            
            const color = dropdown.value;
            
            if (!color) {
                // Reset to default when no color selected
                dropdown.style.backgroundColor = 'var(--bg-primary)';
                dropdown.style.color = 'var(--text-primary)';
                dropdown.style.borderColor = 'var(--border)';
                return;
            }

            // Set dropdown background to selected color
            dropdown.style.backgroundColor = color;
            dropdown.style.color = 'white';
            dropdown.style.borderColor = color;
            dropdown.style.borderWidth = '2px';

            // AUTO-APPLY: If a group is selected, apply colour immediately!
            if (selectedGroup) {
                console.log('Auto-applying colour to group:', selectedGroup.name);
                
                let successCount = 0;
                
                // Apply to all parts in the group
                selectedGroup.parts.forEach(idx => {
                    if (parts[idx]) {
                        animatePartColorChange(parts[idx], color);
                        parts[idx].userData.color = color;
                        
                        // Update dropdown
                        const dropdown = document.getElementById(`part-color-dropdown-${idx}`);
                        if (dropdown) {
                            dropdown.value = color;
                            dropdown.style.backgroundColor = color;
                            dropdown.style.color = '#fff';
                            dropdown.style.borderColor = color;
                            dropdown.style.borderWidth = '2px';
                        }
                        successCount++;
                    }
                });
                
                // Save color to group
                selectedGroup.color = color;
                renderGroupSelector();
                
                showToast(`‚úì ${color.toUpperCase()} applied to "${selectedGroup.name}" (${successCount} parts)`);
            }
            
            console.log('Colour selected from dropdown:', color);
        }

        function colorAllGroupsRandomly() {
            if (groups.length === 0) {
                showToast('‚ö†Ô∏è No groups created yet');
                return;
            }
            
            groups.forEach(group => {
                const randomColor = presetColors[Math.floor(Math.random() * presetColors.length)];
                group.color = randomColor;
                
                group.parts.forEach(idx => {
                    if (parts[idx]) {
                        animatePartColorChange(parts[idx], randomColor);
                        parts[idx].userData.color = randomColor;

                        // Update dropdown
                        const dropdown = document.getElementById(`part-color-dropdown-${idx}`);
                        if (dropdown) {
                            dropdown.value = randomColor;
                            dropdown.style.backgroundColor = randomColor;
                            dropdown.style.color = '#fff';
                            dropdown.style.borderColor = randomColor;
                            dropdown.style.borderWidth = '2px';
                        }
                    }
                });
            });
            
            renderGroupSelector();
            showToast('üé≤ All groups coloured randomly!');
            console.log('All groups randomized');
        }

        function deleteGroup() {
            if (!selectedGroup) {
                showToast('‚ö†Ô∏è Select a group first');
                return;
            }
            
            const groupName = selectedGroup.name;
            const index = groups.findIndex(g => g.name === groupName);
            
            if (index !== -1) {
                // Clear checkboxes for parts in this group
                selectedGroup.parts.forEach(partIndex => {
                    const checkbox = document.getElementById(`checkbox-${partIndex}`);
                    const card = document.getElementById(`part-card-${partIndex}`);
                    if (checkbox) {
                        checkbox.classList.remove('checked');
                        checkbox.textContent = '';
                    }
                    if (card) {
                        card.classList.remove('selected');
                    }
                });
                
                groups.splice(index, 1);
                selectedGroup = null;
                renderGroupSelector();
                
                const deleteBtn = document.getElementById('delete-group-btn');
                const colorDropdown = document.getElementById('group-color-dropdown');
                
                if (deleteBtn) deleteBtn.disabled = true;
                if (colorDropdown) {
                    colorDropdown.disabled = true;
                    colorDropdown.value = '';
                    colorDropdown.style.backgroundColor = 'var(--bg-primary)';
                    colorDropdown.style.color = 'var(--text-primary)';
                    colorDropdown.style.borderColor = 'var(--border)';
                    colorDropdown.style.borderWidth = '1px';
                }
                
                // Reset group selector
                const selector = document.getElementById('group-selector');
                if (selector) selector.value = '';
                
                showToast(`üóë Group "${groupName}" deleted`);
                console.log('Group deleted:', groupName);
            }
        }

        // Populate dropdown and setup event listeners on load
        window.addEventListener('load', () => {
            const dropdown = document.getElementById('group-color-dropdown');
            if (dropdown) {
                // Populate with preset colors
                presetColors.forEach(color => {
                    const option = document.createElement('option');
                    option.value = color;
                    option.textContent = color.toUpperCase();
                    option.style.backgroundColor = color;
                    option.style.color = '#fff';
                    option.style.fontWeight = '600';
                    option.style.padding = '4px 8px';
                    dropdown.appendChild(option);
                });
                
                console.log('Color dropdown populated with', presetColors.length, 'colors');
            }
        });

        // Expand/Collapse All Parts
        function expandAllParts() {
            parts.forEach((part, index) => {
                const card = document.getElementById(`part-card-${index}`);
                const collapseBtn = document.getElementById(`part-collapse-${index}`);
                if (card && card.classList.contains('minimized')) {
                    card.classList.remove('minimized');
                    if (collapseBtn) collapseBtn.textContent = '‚àí';
                }
            });
            showToast('All parts expanded');
        }

        function collapseAllParts() {
            parts.forEach((part, index) => {
                const card = document.getElementById(`part-card-${index}`);
                const collapseBtn = document.getElementById(`part-collapse-${index}`);
                if (card && !card.classList.contains('minimized')) {
                    card.classList.remove('expanded');
                    const transformBtn = document.getElementById(`transform-btn-${index}`);
                    const transformDiv = document.getElementById(`transform-${index}`);
                    if (transformBtn) transformBtn.classList.remove('active');
                    if (transformDiv) transformDiv.classList.remove('show');
                    
                    card.classList.add('minimized');
                    if (collapseBtn) collapseBtn.textContent = '+';
                }
            });
            showToast('All parts collapsed');
        }
        
        function lockAllParts() {
            let lockedCount = 0;
            parts.forEach((part, index) => {
                if (!part.userData.locked) {
                    part.userData.locked = true;
                    const btn = document.getElementById(`lock-btn-${index}`);
                    const card = document.getElementById(`part-card-${index}`);
                    const transformDiv = document.getElementById(`transform-${index}`);
                    
                    if (btn) {
                        btn.classList.add('locked');
                        btn.textContent = 'üîí';
                    }
                    if (card) {
                        card.classList.add('locked');
                    }
                    if (transformDiv && transformDiv.classList.contains('show')) {
                        transformDiv.classList.add('disabled');
                    }
                    lockedCount++;
                }
            });
            
            if (lockedCount > 0) {
                showToast(`üîí Locked ${lockedCount} part(s)`);
            } else {
                showToast('All parts already locked');
            }
        }
        
        function unlockAllParts() {
            let unlockedCount = 0;
            parts.forEach((part, index) => {
                if (part.userData.locked) {
                    part.userData.locked = false;
                    const btn = document.getElementById(`lock-btn-${index}`);
                    const card = document.getElementById(`part-card-${index}`);
                    const transformDiv = document.getElementById(`transform-${index}`);
                    
                    if (btn) {
                        btn.classList.remove('locked');
                        btn.textContent = 'üîì';
                    }
                    if (card) {
                        card.classList.remove('locked');
                    }
                    if (transformDiv) {
                        transformDiv.classList.remove('disabled');
                    }
                    unlockedCount++;
                }
            });
            
            if (unlockedCount > 0) {
                showToast(`üîì Unlocked ${unlockedCount} part(s)`);
            } else {
                showToast('All parts already unlocked');
            }
        }

        function togglePartCollapse(index) {
            const card = document.getElementById(`part-card-${index}`);
            const btn = document.getElementById(`part-collapse-${index}`);
            
            if (!card || !btn) {
                console.warn('Card or button not found for index:', index);
                return;
            }
            
            if (card.classList.contains('minimized')) {
                card.classList.remove('minimized');
                btn.textContent = '‚àí';
            } else {
                card.classList.remove('expanded');
                const transformBtn = document.getElementById(`transform-btn-${index}`);
                const transformDiv = document.getElementById(`transform-${index}`);
                if (transformBtn) transformBtn.classList.remove('active');
                if (transformDiv) transformDiv.classList.remove('show');
                
                card.classList.add('minimized');
                btn.textContent = '+';
            }
        }

        // Color Management
        function renderColorGrid() {
            const grid = document.getElementById('color-grid');
            grid.innerHTML = '';
            
            presetColors.forEach((color, index) => {
                const item = document.createElement('div');
                item.className = 'color-item';
                item.style.background = color;
                item.dataset.color = color; // Store color in data attribute
                
                // Restore selection if this was the selected color
                if (selectedColor && selectedColor.toLowerCase() === color.toLowerCase()) {
                    item.classList.add('selected');
                }
                
                // Fix: Use arrow function to capture 'item' reference correctly
                item.onclick = () => {
                    selectColor(color, item);
                    console.log('Color grid item clicked:', color);
                };
                
                const removeBtn = document.createElement('div');
                removeBtn.className = 'color-remove';
                removeBtn.textContent = '√ó';
                removeBtn.onclick = (e) => {
                    e.stopPropagation();
                    removeColor(index);
                };
                
                item.appendChild(removeBtn);
                grid.appendChild(item);
            });
            
            console.log('Color grid rendered with', presetColors.length, 'colors');
        }

        function selectColor(color, element) {
            console.log('=== Select Palette Color ===');
            console.log('Color:', color);
            console.log('Element:', element);
            console.log('Previously selected color:', selectedColor);
            
            selectedColor = color;
            
            // Remove selected class from all color items
            document.querySelectorAll('.color-item').forEach(el => {
                el.classList.remove('selected');
            });
            
            // Add selected class to clicked item
            if (element) {
                element.classList.add('selected');
                console.log('Added selected class to element');
            } else {
                // If no element provided, find it by color
                document.querySelectorAll('.color-item').forEach(el => {
                    if (el.dataset.color && el.dataset.color.toLowerCase() === color.toLowerCase()) {
                        el.classList.add('selected');
                        console.log('Found and selected element by color match');
                    }
                });
            }
            
            // Update the header indicator
            const indicator = document.getElementById('selected-color-indicator');
            if (indicator) {
                indicator.style.display = 'inline-block';
                indicator.style.background = color;
                indicator.textContent = color;
                indicator.style.color = 'white';
                indicator.style.textShadow = '0 1px 2px rgba(0,0,0,0.5)';
            }
            
            updateApplyButton();
            
            // Show feedback that color was selected
            showToast(`‚úì Palette colour selected - now select parts (‚úì)`);
            
            console.log('Selected palette color set to:', selectedColor);
            console.log('Selected parts count:', selectedParts.size);
            console.log('============================');
        }

        function addNewColor() {
            const newColorInput = document.getElementById('new-color-input');
            const newColor = newColorInput.value;
            
            console.log('Adding new color to palette:', newColor);
            
            // Check if color already exists (case insensitive)
            const colorExists = presetColors.some(c => c.toLowerCase() === newColor.toLowerCase());
            
            if (colorExists) {
                showToast('‚ö†Ô∏è Colour already in palette');
                // Flash the existing color
                const existingItem = document.querySelector(`.color-item[data-color="${newColor}"]`);
                if (existingItem) {
                    existingItem.style.transform = 'scale(1.2)';
                    existingItem.style.boxShadow = '0 0 20px ' + newColor;
                    setTimeout(() => {
                        existingItem.style.transform = '';
                        existingItem.style.boxShadow = '';
                    }, 500);
                }
                return;
            }
            
            // Add the new color
            presetColors.push(newColor);
            renderColorGrid();
            
            // Update all part preset color pickers
            parts.forEach((part, index) => {
                const presetsContainer = document.getElementById(`presets-${index}`);
                if (presetsContainer) {
                    presetsContainer.innerHTML = '';
                    presetColors.forEach(color => {
                        const preset = document.createElement('div');
                        preset.className = 'preset-color';
                        preset.style.background = color;
                        preset.onclick = () => updateColor(index, color);
                        presetsContainer.appendChild(preset);
                    });
                }
            });
            
            // Flash the new color in the palette
            setTimeout(() => {
                const newItem = document.querySelector(`.color-item[data-color="${newColor}"]`);
                if (newItem) {
                    newItem.style.transform = 'scale(1.2)';
                    newItem.style.boxShadow = '0 0 20px ' + newColor;
                    setTimeout(() => {
                        newItem.style.transform = '';
                        newItem.style.boxShadow = '';
                    }, 500);
                }
            }, 50);
            
            showToast(`‚úì Colour ${newColor} added to palette!`);
            console.log('New color added. Total colors:', presetColors.length);
        }

        function removeColor(index) {
            if (presetColors.length > 1) {
                presetColors.splice(index, 1);
                renderColorGrid();
                showToast('Colour removed from palette');
            } else {
                showToast('‚ö†Ô∏è Must keep at least one colour');
            }
        }

        function toggleColorPanel() {
            const content = document.getElementById('color-content');
            const btn = document.getElementById('color-collapse-btn');
            content.classList.toggle('collapsed');
            btn.textContent = content.classList.contains('collapsed') ? '+' : '‚àí';
        }

        function applyColorToSelected() {
            console.log('=== Apply Palette Color Debug ===');
            console.log('Selected palette color:', selectedColor);
            console.log('Selected parts:', Array.from(selectedParts));
            
            // Make absolutely sure we're using the palette selected color
            if (!selectedColor || selectedColor === '') {
                showToast('‚ö†Ô∏è Click a colour in the PALETTE first (the coloured squares)');
                console.log('ERROR: No palette color selected!');
                
                // Visual hint - flash the palette
                const palette = document.querySelector('.color-grid');
                if (palette) {
                    palette.style.border = '2px solid var(--accent-magenta)';
                    setTimeout(() => {
                        palette.style.border = '';
                    }, 1000);
                }
                return;
            }
            
            if (selectedParts.size === 0) {
                showToast('‚ö†Ô∏è Select parts first using the checkboxes (‚úì)');
                console.log('ERROR: No parts selected!');
                return;
            }
            
            // Apply the PALETTE color to all selected parts
            let successCount = 0;
            selectedParts.forEach(index => {
                console.log(`Applying palette color ${selectedColor} to part ${index}`);
                if (parts[index]) {
                    // Update the part's color with animation
                    animatePartColorChange(parts[index], selectedColor);
                    parts[index].userData.color = selectedColor;
                    
                    // Update the dropdown
                    const dropdown = document.getElementById(`part-color-dropdown-${index}`);
                    if (dropdown) {
                        dropdown.value = selectedColor;
                        dropdown.style.backgroundColor = selectedColor;
                        dropdown.style.color = '#fff';
                        dropdown.style.borderColor = selectedColor;
                        dropdown.style.borderWidth = '2px';
                    }
                    
                    successCount++;
                } else {
                    console.error(`Part ${index} not found!`);
                }
            });
            
            console.log(`Successfully applied palette color to ${successCount} parts`);
            showToast(`‚úì Applied ${selectedColor} to ${successCount} part(s)!`);
        }

        function updateApplyButton() {
            const btn = document.getElementById('apply-color-btn');
            if (!btn) {
                console.warn('Apply color button not found!');
                return;
            }
            
            const shouldEnable = selectedColor && selectedParts.size > 0;
            
            btn.disabled = !shouldEnable;
            
            // Show the actual palette color that will be applied
            if (selectedParts.size > 0 && selectedColor) {
                btn.textContent = `Apply Palette Colour to ${selectedParts.size} Part(s)`;
                btn.style.cursor = 'pointer';
                btn.style.background = `linear-gradient(135deg, ${selectedColor} 0%, ${selectedColor}88 100%)`;
                btn.style.borderColor = selectedColor;
                btn.style.color = '#ffffff';
            } else if (selectedParts.size > 0) {
                btn.textContent = 'Click a PALETTE Colour First';
                btn.style.cursor = 'not-allowed';
                btn.style.background = 'rgba(0, 255, 136, 0.1)';
                btn.style.borderColor = 'var(--accent-green)';
                btn.style.color = 'var(--accent-green)';
            } else if (selectedColor) {
                btn.textContent = 'Select Parts First (‚úì checkboxes)';
                btn.style.cursor = 'not-allowed';
                btn.style.background = 'rgba(0, 255, 136, 0.1)';
                btn.style.borderColor = 'var(--accent-green)';
                btn.style.color = 'var(--accent-green)';
            } else {
                btn.textContent = 'Select Color & Parts First';
                btn.style.cursor = 'not-allowed';
                btn.style.background = 'rgba(0, 255, 136, 0.1)';
                btn.style.borderColor = 'var(--accent-green)';
                btn.style.color = 'var(--accent-green)';
            }
            
            console.log('Apply button updated - Color:', selectedColor, 'Parts:', selectedParts.size, 'Enabled:', shouldEnable);
        }

        // Part Selection

        function updateSelectionInfo() {
            const info = document.getElementById('selection-info');
            if (selectedParts.size > 0) {
                info.textContent = `(${selectedParts.size} selected)`;
            } else {
                info.textContent = '';
            }
        }

        // Part Locking
        function toggleLock(index) {
            if (!parts[index]) return;
            
            parts[index].userData.locked = !parts[index].userData.locked;
            const btn = document.getElementById(`lock-btn-${index}`);
            const card = document.getElementById(`part-card-${index}`);
            const transformDiv = document.getElementById(`transform-${index}`);
            
            if (parts[index].userData.locked) {
                btn.classList.add('locked');
                btn.textContent = 'üîí';
                card.classList.add('locked');
                if (transformDiv && transformDiv.classList.contains('show')) {
                    transformDiv.classList.add('disabled');
                }
            } else {
                btn.classList.remove('locked');
                btn.textContent = 'üîì';
                card.classList.remove('locked');
                if (transformDiv) {
                    transformDiv.classList.remove('disabled');
                }
            }
        }

        function setupFileUpload() {
            const fileInput = document.getElementById('file-input');
            const uploadZone = document.getElementById('upload-zone');
            
            fileInput.addEventListener('change', (e) => {
                handleFiles(e.target.files);
            });
            
            uploadZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadZone.classList.add('drag-over');
            });
            
            uploadZone.addEventListener('dragleave', () => {
                uploadZone.classList.remove('drag-over');
            });
            
            uploadZone.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadZone.classList.remove('drag-over');
                handleFiles(e.dataTransfer.files);
            });
        }

        async function handleFiles(files) {
            for (const file of files) {
                if (file.name.toLowerCase().endsWith('.stlproject')) {
                    // It's a project file - load it
                    const zip = await JSZip.loadAsync(file);
                    const projectJsonFile = zip.file("project.json");
                    if (projectJsonFile) {
                        const projectData = JSON.parse(await projectJsonFile.async("text"));
                        
                        clearAllSilent();
                        document.getElementById('project-name').value = projectData.projectName;
                        updateProjectDisplay();
                        
                        if (projectData.colors) {
                            presetColors = projectData.colors;
                            renderColorGrid();
                        }
                        
                        const stlFolder = zip.folder("stl_files");
                        for (const partData of projectData.parts) {
                            const stlFile = stlFolder.file(partData.fileName);
                            if (stlFile) {
                                const arrayBuffer = await stlFile.async("arraybuffer");
                                await loadSTLFromBuffer(arrayBuffer, partData);
                            }
                        }
                        
                        frameModel();
                        showToast(`üìÇ Project "${projectData.projectName}" loaded!`);
                    }
                } else if (file.name.toLowerCase().endsWith('.stl')) {
                    loadSTL(file);
                } else {
                    showToast('‚ö†Ô∏è Please upload .stl or .stlproject files');
                }
            }
        }

        function loadSTL(file) {
            console.log('Loading STL file:', file.name);
            
            try {
                const reader = new FileReader();
                
                reader.onerror = (error) => {
                    console.error('File read error:', error);
                    showToast('‚ùå Error reading file: ' + file.name);
                };
                
                reader.onload = (e) => {
                    try {
                        console.log('File loaded, parsing geometry...');
                        const geometry = loader.parse(e.target.result);
                        console.log('Geometry parsed successfully');
                        
                        const randomColor = presetColors[Math.floor(Math.random() * presetColors.length)];
                        
                        const material = new THREE.MeshStandardMaterial({
                            color: randomColor,
                            metalness: 0.3,
                            roughness: 0.4,
                            flatShading: false
                        });
                        
                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.userData = {
                            name: file.name.replace('.stl', ''),
                            visible: true,
                            color: randomColor,
                            position: { x: 0, y: 0, z: 0 },
                            rotation: { x: 0, y: 0, z: 0 },
                            locked: false
                        };
                        
                        console.log('Adding mesh to scene...');
                        modelGroup.add(mesh);
                        parts.push(mesh);
                        
                        console.log('Creating UI controls...');
                        addPartControl(parts.length - 1);
                        updatePartCount();
                        updateBoundingBox();
                        updateCoordinates(parts.length - 1);
                        
                        if (parts.length === 1) {
                            frameModel();
                        }
                        
                        showToast(`‚úì Loaded: ${file.name}`);
                        console.log('STL loaded successfully:', file.name);
                    } catch (error) {
                        console.error('Error processing STL:', error);
                        showToast('‚ùå Error loading: ' + file.name);
                    }
                };
                
                console.log('Starting file read...');
                reader.readAsArrayBuffer(file);
            } catch (error) {
                console.error('Error in loadSTL:', error);
                showToast('‚ùå Failed to load: ' + file.name);
            }
        }

        function addPartControl(index) {
            try {
                console.log('Adding part control for index:', index);
                const container = document.getElementById('parts-container');
                
                if (!container) {
                    console.error('Parts container not found!');
                    return;
                }
                
                // Remove existing card if it exists (prevent duplicates)
                const existingCard = document.getElementById(`part-card-${index}`);
                if (existingCard) {
                    console.log('Removing existing card for index:', index);
                    existingCard.remove();
                }
                
                if (parts.length === 1) {
                    container.innerHTML = '';
                }
                
                if (!parts[index]) {
                    console.error('Part not found at index:', index);
                    return;
                }
                
                const part = parts[index];
                const card = document.createElement('div');
                card.className = 'part-card';
                card.style.animationDelay = `${index * 0.1}s`;
                card.id = `part-card-${index}`;
                
                card.innerHTML = `
                <div class="part-header">
                    <div class="part-name-section">
                        <div class="select-checkbox" id="checkbox-${index}" onclick="togglePartSelection(${index})" title="Select for multi-color"></div>
                        <div class="part-name">${part.userData.name}</div>
                    </div>
                    <div class="part-actions">
                        <button class="collapse-btn" onclick="togglePartCollapse(${index})" id="part-collapse-${index}">‚àí</button>
                        <button class="icon-btn lock-btn" onclick="toggleLock(${index})" title="Lock/Unlock" id="lock-btn-${index}">
                            üîì
                        </button>
                        <button class="icon-btn visibility" onclick="toggleVisibility(${index})" title="Toggle visibility" id="vis-btn-${index}">
                            üëÅ
                        </button>
                        <button class="icon-btn" onclick="toggleTransform(${index})" title="Transform controls" id="transform-btn-${index}">‚öô</button>
                        <button class="icon-btn danger" onclick="removePart(${index})" title="Remove part">√ó</button>
                    </div>
                </div>
                
                <div class="part-content">
                    <div class="coordinate-display" ondblclick="focusOnPart(${index})" title="Double-click to focus in 3D view">
                        <div class="coord-title">Current Position</div>
                        <div class="coord-values">
                            <div class="coord-item">
                                <div class="coord-label">X</div>
                                <div class="coord-value" id="coord-x-${index}">0.0</div>
                            </div>
                            <div class="coord-item">
                                <div class="coord-label">Y</div>
                                <div class="coord-value" id="coord-y-${index}">0.0</div>
                            </div>
                            <div class="coord-item">
                                <div class="coord-label">Z</div>
                                <div class="coord-value" id="coord-z-${index}">0.0</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="color-picker-container">
                        <div style="font-size: 9px; color: var(--text-secondary); font-family: 'Azeret Mono', monospace; text-transform: uppercase; margin-bottom: 4px;">Part Colour:</div>
                        <select id="part-color-dropdown-${index}" onchange="updateColorFromDropdown(${index})" style="width: 100%; padding: 10px; border-radius: 6px; background: var(--bg-primary); border: 1px solid var(--border); color: var(--text-primary); font-family: 'Rajdhani', sans-serif; cursor: pointer; font-size: 12px; transition: all 0.3s ease;">
                            <option value="">Pick a colour</option>
                        </select>
                    </div>
                    
                    <div class="transform-controls" id="transform-${index}">
                        <div class="transform-section">
                            <div class="transform-label">Position (mm)</div>
                            <div class="transform-sliders">
                                ${['x', 'y', 'z'].map(axis => `
                                <div class="slider-row">
                                    <span class="slider-label">${axis.toUpperCase()}</span>
                                    <div class="slider-container">
                                        <input type="range" min="-500" max="500" value="0" step="0.1" 
                                               oninput="updateTransform(${index}, 'position', '${axis}', this.value)" id="pos-${axis}-${index}">
                                        <div class="input-controls">
                                            <button class="arrow-btn" onclick="adjustValue(${index}, 'position', '${axis}', -1)">‚àí</button>
                                            <input type="number" class="number-input" value="0" step="0.1"
                                                   onchange="setTransformDirect(${index}, 'position', '${axis}', this.value)" id="input-pos-${axis}-${index}">
                                            <button class="arrow-btn" onclick="adjustValue(${index}, 'position', '${axis}', 1)">+</button>
                                        </div>
                                    </div>
                                </div>
                                `).join('')}
                            </div>
                        </div>
                        
                        <div class="transform-section">
                            <div class="transform-label">Rotation (degrees)</div>
                            <div class="transform-sliders">
                                ${['x', 'y', 'z'].map(axis => `
                                <div class="slider-row">
                                    <span class="slider-label rotation">${axis.toUpperCase()}</span>
                                    <div class="slider-container">
                                        <input type="range" class="rotation" min="-180" max="180" value="0" step="1" 
                                               oninput="updateTransform(${index}, 'rotation', '${axis}', this.value)" id="rot-${axis}-${index}">
                                        <div class="input-controls">
                                            <button class="arrow-btn" onclick="adjustValue(${index}, 'rotation', '${axis}', -5)">‚àí</button>
                                            <input type="number" class="number-input" value="0" step="1"
                                                   onchange="setTransformDirect(${index}, 'rotation', '${axis}', this.value)" id="input-rot-${axis}-${index}">
                                            <button class="arrow-btn" onclick="adjustValue(${index}, 'rotation', '${axis}', 5)">+</button>
                                        </div>
                                    </div>
                                </div>
                                `).join('')}
                            </div>
                        </div>
                        
                        <button class="transform-reset" onclick="resetTransform(${index})">Reset Transform</button>
                    </div>
                </div>
            `;
            
            container.appendChild(card);
            
            // Populate the color dropdown for this part
            const partColorDropdown = document.getElementById(`part-color-dropdown-${index}`);
            if (partColorDropdown) {
                presetColors.forEach(color => {
                    const option = document.createElement('option');
                    option.value = color;
                    option.textContent = color.toUpperCase();
                    option.style.backgroundColor = color;
                    option.style.color = '#fff';
                    option.style.fontWeight = '600';
                    option.style.padding = '4px 8px';
                    partColorDropdown.appendChild(option);
                });
                
                // Set current color
                partColorDropdown.value = part.userData.color;
                partColorDropdown.style.backgroundColor = part.userData.color;
                partColorDropdown.style.color = '#fff';
                partColorDropdown.style.fontWeight = '600';
                partColorDropdown.style.borderColor = part.userData.color;
                partColorDropdown.style.borderWidth = '2px';
            }
            
            console.log('Part control added successfully for index:', index);
            } catch (error) {
                console.error('Error in addPartControl:', error);
                showToast('‚ùå Error creating part controls');
            }
        }

        function toggleTransform(index) {
            if (parts[index] && parts[index].userData.locked) {
                showToast('‚ö†Ô∏è Part is locked. Unlock to edit.');
                return;
            }
            
            const transformDiv = document.getElementById(`transform-${index}`);
            const btn = document.getElementById(`transform-btn-${index}`);
            const card = document.getElementById(`part-card-${index}`);
            
            transformDiv.classList.toggle('show');
            btn.classList.toggle('active');
            card.classList.toggle('expanded');
        }

        function updateColor(index, color) {
            if (parts[index]) {
                animatePartColorChange(parts[index], color);
                parts[index].userData.color = color;
                
                // Update dropdown if it exists
                const dropdown = document.getElementById(`part-color-dropdown-${index}`);
                if (dropdown) {
                    dropdown.value = color;
                    dropdown.style.backgroundColor = color;
                    dropdown.style.color = '#fff';
                    dropdown.style.borderColor = color;
                    dropdown.style.borderWidth = '2px';
                }
            }
        }
        
        function updateColorFromDropdown(index) {
            const dropdown = document.getElementById(`part-color-dropdown-${index}`);
            
            if (!dropdown) {
                console.warn('Color dropdown not found for part:', index);
                return;
            }
            
            const color = dropdown.value;
            
            if (!color) {
                // Reset to default when no color selected
                dropdown.style.backgroundColor = 'var(--bg-primary)';
                dropdown.style.color = 'var(--text-primary)';
                dropdown.style.borderColor = 'var(--border)';
                dropdown.style.borderWidth = '1px';
                return;
            }

            // Set dropdown visual feedback
            dropdown.style.backgroundColor = color;
            dropdown.style.color = '#fff';
            dropdown.style.borderColor = color;
            dropdown.style.borderWidth = '2px';

            // Apply color to part immediately
            if (parts[index]) {
                animatePartColorChange(parts[index], color);
                parts[index].userData.color = color;
                showToast(`‚úì ${color.toUpperCase()} applied to "${parts[index].userData.name}"`);
            }
        }

        function updateTransform(index, type, axis, value) {
            if (!parts[index] || parts[index].userData.locked) return;
            
            const val = parseFloat(value);
            
            if (type === 'position') {
                parts[index].position[axis] = val;
                parts[index].userData.position[axis] = val;
                document.getElementById(`input-pos-${axis}-${index}`).value = val.toFixed(1);
                updateCoordinates(index);
            } else if (type === 'rotation') {
                const radians = val * (Math.PI / 180);
                parts[index].rotation[axis] = radians;
                parts[index].userData.rotation[axis] = val;
                document.getElementById(`input-rot-${axis}-${index}`).value = val.toFixed(0);
            }
            
            updateBoundingBox();
        }

        function setTransformDirect(index, type, axis, value) {
            if (!parts[index] || parts[index].userData.locked) return;
            
            const val = parseFloat(value);
            
            if (type === 'position') {
                const clamped = Math.max(-500, Math.min(500, val));
                parts[index].position[axis] = clamped;
                parts[index].userData.position[axis] = clamped;
                document.getElementById(`pos-${axis}-${index}`).value = clamped;
                document.getElementById(`input-pos-${axis}-${index}`).value = clamped.toFixed(1);
                updateCoordinates(index);
            } else if (type === 'rotation') {
                const clamped = Math.max(-180, Math.min(180, val));
                const radians = clamped * (Math.PI / 180);
                parts[index].rotation[axis] = radians;
                parts[index].userData.rotation[axis] = clamped;
                document.getElementById(`rot-${axis}-${index}`).value = clamped;
                document.getElementById(`input-rot-${axis}-${index}`).value = clamped.toFixed(0);
            }
            
            updateBoundingBox();
        }

        function adjustValue(index, type, axis, delta) {
            if (!parts[index] || parts[index].userData.locked) return;
            
            if (type === 'position') {
                const current = parts[index].position[axis];
                const newVal = Math.max(-500, Math.min(500, current + delta));
                setTransformDirect(index, type, axis, newVal);
            } else if (type === 'rotation') {
                const current = parts[index].userData.rotation[axis];
                const newVal = Math.max(-180, Math.min(180, current + delta));
                setTransformDirect(index, type, axis, newVal);
            }
        }

        function updateCoordinates(index) {
            if (!parts[index]) return;
            
            const pos = parts[index].position;
            document.getElementById(`coord-x-${index}`).textContent = pos.x.toFixed(1);
            document.getElementById(`coord-y-${index}`).textContent = pos.y.toFixed(1);
            document.getElementById(`coord-z-${index}`).textContent = pos.z.toFixed(1);
        }

        function resetTransform(index) {
            if (parts[index] && !parts[index].userData.locked) {
                parts[index].position.set(0, 0, 0);
                parts[index].rotation.set(0, 0, 0);
                parts[index].userData.position = { x: 0, y: 0, z: 0 };
                parts[index].userData.rotation = { x: 0, y: 0, z: 0 };
                
                ['x', 'y', 'z'].forEach(axis => {
                    document.getElementById(`pos-${axis}-${index}`).value = 0;
                    document.getElementById(`input-pos-${axis}-${index}`).value = 0;
                    document.getElementById(`rot-${axis}-${index}`).value = 0;
                    document.getElementById(`input-rot-${axis}-${index}`).value = 0;
                });
                
                updateCoordinates(index);
                updateBoundingBox();
                showToast('Transform reset');
            }
        }

        function toggleVisibility(index) {
            if (parts[index]) {
                parts[index].visible = !parts[index].visible;
                parts[index].userData.visible = parts[index].visible;
                
                const btn = document.getElementById(`vis-btn-${index}`);
                const card = document.getElementById(`part-card-${index}`);
                
                if (parts[index].visible) {
                    btn.classList.remove('hidden-btn');
                    btn.classList.add('visibility');
                    btn.textContent = 'üëÅ';
                    card.classList.remove('hidden-part');
                } else {
                    btn.classList.add('hidden-btn');
                    btn.classList.remove('visibility');
                    btn.textContent = '‚®Ø';
                    card.classList.add('hidden-part');
                }
                
                updateBoundingBox();
            }
        }

        function removePart(index) {
            if (parts[index]) {
                const part = parts[index];
                
                // Remove from scene
                modelGroup.remove(part);
                
                // Dispose geometry
                if (part.geometry) {
                    part.geometry.dispose();
                }
                
                // Dispose material and textures
                if (part.material) {
                    if (part.material.map) part.material.map.dispose();
                    if (part.material.lightMap) part.material.lightMap.dispose();
                    if (part.material.bumpMap) part.material.bumpMap.dispose();
                    if (part.material.normalMap) part.material.normalMap.dispose();
                    if (part.material.specularMap) part.material.specularMap.dispose();
                    if (part.material.envMap) part.material.envMap.dispose();
                    part.material.dispose();
                }
                
                // Remove from array
                parts.splice(index, 1);
                
                // Update selected parts indices
                selectedParts.delete(index);
                const newSelected = new Set();
                selectedParts.forEach(i => {
                    if (i > index) newSelected.add(i - 1);
                    else if (i < index) newSelected.add(i);
                });
                selectedParts = newSelected;
                
                rebuildUI();
                updatePartCount();
                updateBoundingBox();
                showToast('Part removed');
                
                console.log('Part removed with proper disposal, remaining parts:', parts.length);
            }
        }

        function rebuildUI() {
            const container = document.getElementById('parts-container');
            container.innerHTML = '';
            
            if (parts.length === 0) {
                container.innerHTML = '<div class="empty-state">No parts loaded yet.<br>Upload STL files or load a project.</div>';
            } else {
                parts.forEach((part, index) => {
                    addPartControl(index);
                    
                    const colorInput = document.querySelector(`#preview-${index} input`);
                    if (colorInput) colorInput.value = part.userData.color;
                    
                    ['x', 'y', 'z'].forEach(axis => {
                        const posSlider = document.getElementById(`pos-${axis}-${index}`);
                        const posInput = document.getElementById(`input-pos-${axis}-${index}`);
                        const rotSlider = document.getElementById(`rot-${axis}-${index}`);
                        const rotInput = document.getElementById(`input-rot-${axis}-${index}`);
                        
                        if (posSlider && posInput) {
                            posSlider.value = part.userData.position[axis];
                            posInput.value = part.userData.position[axis].toFixed(1);
                        }
                        if (rotSlider && rotInput) {
                            rotSlider.value = part.userData.rotation[axis];
                            rotInput.value = part.userData.rotation[axis].toFixed(0);
                        }
                    });
                    
                    updateCoordinates(index);
                    
                    if (!part.visible) {
                        const btn = document.getElementById(`vis-btn-${index}`);
                        const card = document.getElementById(`part-card-${index}`);
                        btn.classList.add('hidden-btn');
                        btn.classList.remove('visibility');
                        btn.textContent = '‚®Ø';
                        card.classList.add('hidden-part');
                    }
                    
                    if (part.userData.locked) {
                        const btn = document.getElementById(`lock-btn-${index}`);
                        const card = document.getElementById(`part-card-${index}`);
                        btn.classList.add('locked');
                        btn.textContent = 'üîí';
                        card.classList.add('locked');
                    }
                    
                    // Restore selection state
                    if (selectedParts.has(index)) {
                        const checkbox = document.getElementById(`checkbox-${index}`);
                        const card = document.getElementById(`part-card-${index}`);
                        if (checkbox) {
                            checkbox.classList.add('checked');
                            checkbox.textContent = '‚úì';
                        }
                        if (card) {
                            card.classList.add('selected');
                        }
                    }
                });
            }
        }

        function randomizeColors() {
            parts.forEach((part, index) => {
                const randomColor = presetColors[Math.floor(Math.random() * presetColors.length)];
                updateColor(index, randomColor);
            });
            showToast('üé® Colours randomized!');
        }

        function clearAll() {
            console.log('=== clearAll() called ===');
            console.log('Parts count:', parts.length);
            console.log('Groups count:', groups.length);
            
            const message = parts.length > 0 
                ? `Start a new project? This will clear all ${parts.length} part(s) and ${groups.length} group(s).\n\nMake sure you've saved your current project!`
                : 'Start a new project?';
            
            console.log('Showing confirm dialog...');
            const userConfirmed = confirm(message);
            console.log('User confirmed:', userConfirmed);
            
            if (userConfirmed) {
                console.log('Clearing all...');
                clearAllSilent();
                showToast('‚úì New project started');
                console.log('Clear complete');
            } else {
                console.log('User cancelled');
            }
        }

        function highlightPartInSidebar(partIndex) {
            const card = document.getElementById(`part-card-${partIndex}`);
            
            if (!card) {
                console.warn('Part card not found:', partIndex);
                return;
            }
            
            // Expand part if it's collapsed
            if (card.classList.contains('minimized')) {
                const collapseBtn = document.getElementById(`part-collapse-${partIndex}`);
                if (collapseBtn) {
                    card.classList.remove('minimized');
                    collapseBtn.textContent = '‚àí';
                }
            }
            
            // Scroll to the part card smoothly
            card.scrollIntoView({ 
                behavior: 'smooth', 
                block: 'center'
            });
            
            // Add highlight effect
            card.style.transition = 'all 0.3s ease';
            card.style.transform = 'scale(1.02)';
            card.style.boxShadow = '0 0 20px rgba(0, 245, 255, 0.6), 0 0 40px rgba(0, 245, 255, 0.3)';
            card.style.borderColor = 'var(--accent-cyan)';
            card.style.borderWidth = '2px';
            
            // Show toast
            const partName = parts[partIndex]?.userData?.name || `Part ${partIndex + 1}`;
            showToast(`üìç Found: ${partName}`);
            
            // Remove highlight after 2 seconds
            setTimeout(() => {
                card.style.transform = '';
                card.style.boxShadow = '';
                card.style.borderColor = '';
                card.style.borderWidth = '';
            }, 2000);
            
            console.log('Highlighted part in sidebar:', partIndex, partName);
        }

        function focusOnPart(partIndex) {
            if (!parts[partIndex]) {
                console.warn('Part not found:', partIndex);
                return;
            }
            
            const part = parts[partIndex];
            const partName = part.userData.name || `Part ${partIndex + 1}`;
            
            // Get part's bounding box
            const box = new THREE.Box3().setFromObject(part);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            
            // Calculate distance based on part size
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            const distance = Math.abs(maxDim / Math.sin(fov / 2)) * 1.5;
            
            // Position camera to look at part
            const direction = new THREE.Vector3(1, 1, 1).normalize();
            camera.position.copy(center).add(direction.multiplyScalar(distance));
            camera.lookAt(center);
            
            // Highlight the part temporarily
            const originalEmissive = part.material.emissive.clone();
            part.material.emissive.setHex(0x00f5ff);
            part.material.emissiveIntensity = 0.3;
            
            setTimeout(() => {
                part.material.emissive.copy(originalEmissive);
                part.material.emissiveIntensity = 0;
            }, 1500);
            
            showToast(`üîç Focused on: ${partName}`);
            console.log('Focused on part:', partIndex, partName);
        }

        function frameModel() {
            if (parts.length === 0) return;
            
            const box = new THREE.Box3();
            parts.forEach(part => {
                if (part.visible) {
                    box.expandByObject(part);
                }
            });
            
            const center = new THREE.Vector3();
            box.getCenter(center);
            
            const size = new THREE.Vector3();
            box.getSize(size);
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
            cameraZ *= 2;
            
            camera.position.set(center.x + cameraZ * 0.5, center.y + cameraZ * 0.5, center.z + cameraZ);
            camera.lookAt(center);
        }

        function resetCamera() {
            camera.position.set(0, 50, 150);
            camera.lookAt(0, 0, 0);
            modelGroup.rotation.set(0, 0, 0);
        }

        function updatePartCount() {
            document.getElementById('part-count').textContent = parts.length;
        }

        function updateBoundingBox() {
            if (parts.length === 0) {
                document.getElementById('bounding-box-info').innerHTML = '';
                return;
            }
            
            const box = new THREE.Box3();
            parts.forEach(part => {
                if (part.visible) {
                    box.expandByObject(part);
                }
            });
            
            const size = new THREE.Vector3();
            box.getSize(size);
            
            const info = `
                <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(0, 245, 255, 0.15);">
                    <div style="color: var(--accent-yellow); margin-bottom: 4px;">Bounding Box:</div>
                    <div>X: ${size.x.toFixed(2)} mm</div>
                    <div>Y: ${size.y.toFixed(2)} mm</div>
                    <div>Z: ${size.z.toFixed(2)} mm</div>
                </div>
            `;
            
            document.getElementById('bounding-box-info').innerHTML = info;
        }

        function toggleMeasure() {
            measureMode = !measureMode;
            const btn = document.getElementById('measure-btn');
            const overlay = document.getElementById('measurement-overlay');
            
            if (measureMode) {
                btn.classList.add('active');
                overlay.classList.add('active');
                measurePoints = [];
                showToast('üìè Measurement mode active');
            } else {
                btn.classList.remove('active');
                overlay.classList.remove('active');
                clearMeasurementVisuals();
            }
        }

        function clearMeasurementVisuals() {
            document.querySelectorAll('.measurement-line, .measurement-point').forEach(el => el.remove());
        }

        function exportImage() {
            renderer.render(scene, camera);
            const imgData = renderer.domElement.toDataURL('image/png');
            const link = document.createElement('a');
            link.href = imgData;
            const projectName = document.getElementById('project-name').value.replace(/[^a-z0-9]/gi, '_');
            link.download = `${projectName}_preview.png`;
            link.click();
            showToast('üì∏ Image exported!');
        }

        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let isPanning = false;

        function setupControls() {
            const canvas = renderer.domElement;
            
            // Double-click to find part in sidebar
            canvas.addEventListener('dblclick', (e) => {
                const rect = canvas.getBoundingClientRect();
                mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(parts);
                
                if (intersects.length > 0) {
                    const clickedPart = intersects[0].object;
                    const partIndex = parts.indexOf(clickedPart);
                    
                    if (partIndex !== -1) {
                        highlightPartInSidebar(partIndex);
                    }
                }
            });
            
            canvas.addEventListener('mousedown', (e) => {
                if (measureMode) {
                    handleMeasureClick(e);
                    return;
                }
                
                if (e.button === 0) {
                    isDragging = true;
                } else if (e.button === 2) {
                    isPanning = true;
                }
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            canvas.addEventListener('mousemove', (e) => {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                
                if (isDragging) {
                    modelGroup.rotation.y += deltaX * 0.01;
                    modelGroup.rotation.x += deltaY * 0.01;
                } else if (isPanning) {
                    camera.position.x -= deltaX * 0.1;
                    camera.position.y += deltaY * 0.1;
                }
                
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
                isPanning = false;
            });
            
            canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });
            
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                camera.position.z += e.deltaY * 0.1;
                camera.position.z = Math.max(10, Math.min(500, camera.position.z));
            });
        }

        function handleMeasureClick(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(parts);
            
            if (intersects.length > 0) {
                const point = intersects[0].point;
                measurePoints.push(point);
                
                const marker = document.createElement('div');
                marker.className = 'measurement-point';
                marker.style.left = event.clientX + 'px';
                marker.style.top = event.clientY + 'px';
                document.body.appendChild(marker);
                
                if (measurePoints.length === 2) {
                    const distance = measurePoints[0].distanceTo(measurePoints[1]);
                    document.getElementById('measurement-value').textContent = distance.toFixed(2) + ' mm';
                    
                    const line = document.createElement('div');
                    line.className = 'measurement-line';
                    const dx = event.clientX - (parseFloat(document.querySelectorAll('.measurement-point')[0].style.left));
                    const dy = event.clientY - (parseFloat(document.querySelectorAll('.measurement-point')[0].style.top));
                    const length = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                    
                    line.style.width = length + 'px';
                    line.style.left = document.querySelectorAll('.measurement-point')[0].style.left;
                    line.style.top = document.querySelectorAll('.measurement-point')[0].style.top;
                    line.style.transform = `rotate(${angle}deg)`;
                    document.body.appendChild(line);
                    
                    showToast(`Distance: ${distance.toFixed(2)} mm`);
                    
                    setTimeout(() => {
                        clearMeasurementVisuals();
                        measurePoints = [];
                        document.getElementById('measurement-value').textContent = '--';
                    }, 5000);
                }
            }
        }

        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        function stopAnimation() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
                console.log('Animation stopped');
            }
        }

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        // Cleanup function to prevent memory leaks
        function cleanupResources() {
            console.log('Cleaning up resources...');
            
            // Stop animation loop
            stopAnimation();
            
            // Remove event listeners
            window.removeEventListener('resize', onWindowResize);
            
            // Clear all parts with proper disposal
            clearAllSilent();
            
            // Dispose renderer
            if (renderer) {
                renderer.dispose();
                renderer.forceContextLoss();
            }
            
            console.log('Cleanup complete');
        }

        window.addEventListener('load', init);
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', cleanupResources);
    </script>
</body>
</html>
