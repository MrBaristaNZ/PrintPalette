
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Print Palette - 3D Print Colour Preview Studio</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@300;500;700&family=Azeret+Mono:wght@400;600&display=swap');

        :root {
            --bg-primary: #0a0e17;
            --bg-secondary: #141922;
            --bg-tertiary: #1e2530;
            --accent-cyan: #00f5ff;
            --accent-magenta: #ff006b;
            --accent-yellow: #ffd700;
            --accent-green: #00ff88;
            --accent-orange: #ff6b35;
            --accent-purple: #a855f7;
            --text-primary: #e8edf4;
            --text-secondary: #8b95a8;
            --border: rgba(0, 245, 255, 0.15);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
        }

        .container {
            display: grid;
            grid-template-columns: 400px 1fr;
            height: 100vh;
            gap: 0;
        }

        /* Sidebar */
        .sidebar {
            background: var(--bg-secondary);
            border-right: 2px solid var(--border);
            padding: 24px;
            overflow-y: auto;
            position: relative;
        }

        .sidebar::before {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 1px;
            height: 100%;
            background: linear-gradient(180deg, 
                transparent 0%, 
                var(--accent-cyan) 30%, 
                var(--accent-cyan) 70%, 
                transparent 100%);
            opacity: 0.3;
        }

        .logo {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 8px;
            letter-spacing: -0.5px;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-magenta));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-family: 'Azeret Mono', monospace;
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 24px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .project-name-section {
            margin-bottom: 24px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px;
        }

        .project-label {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 8px;
            font-family: 'Azeret Mono', monospace;
            text-transform: uppercase;
        }

        .project-name-input {
            width: 100%;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 10px 12px;
            border-radius: 6px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 16px;
            font-weight: 600;
        }

        .project-name-input:focus {
            outline: none;
            border-color: var(--accent-cyan);
        }

        /* Upload Section */
        .upload-section {
            margin-bottom: 24px;
        }

        .upload-zone {
            border: 2px dashed var(--border);
            border-radius: 8px;
            padding: 32px 16px;
            text-align: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .upload-zone::before {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at center, rgba(0, 245, 255, 0.1) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .upload-zone:hover::before {
            opacity: 1;
        }

        .upload-zone:hover {
            border-color: var(--accent-cyan);
            background: rgba(0, 245, 255, 0.05);
        }

        .upload-zone.drag-over {
            border-color: var(--accent-magenta);
            background: rgba(255, 0, 107, 0.1);
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: 12px;
            opacity: 0.6;
        }

        .upload-text {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .upload-hint {
            font-family: 'Azeret Mono', monospace;
            font-size: 10px;
            color: var(--text-secondary);
            opacity: 0.6;
        }

        #file-input {
            display: none;
        }

        .action-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 12px;
        }

        .action-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 0.5px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
        }

        .action-btn:hover {
            background: rgba(0, 245, 255, 0.1);
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        .action-btn.secondary {
            background: transparent;
        }

        .action-btn.project {
            background: rgba(168, 85, 247, 0.1);
            border-color: var(--accent-purple);
            color: var(--accent-purple);
            grid-column: 1 / -1;
        }

        .action-btn.project:hover {
            background: rgba(168, 85, 247, 0.2);
        }

        .action-btn.export-stl {
            background: rgba(255, 215, 0, 0.1);
            border-color: var(--accent-yellow);
            color: var(--accent-yellow);
        }

        .action-btn.export-stl:hover {
            background: rgba(255, 215, 0, 0.2);
        }

        .action-btn.arrangement {
            background: rgba(0, 255, 136, 0.1);
            border-color: var(--accent-green);
            color: var(--accent-green);
            font-size: 11px;
        }

        .action-btn.arrangement:hover {
            background: rgba(0, 255, 136, 0.2);
        }

        /* Group Management */
        .group-management {
            margin-bottom: 24px;
        }

        #group-color-dropdown {
            transition: all 0.2s;
            color: white;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }

        #group-color-dropdown:hover {
            border-color: var(--accent-cyan);
            transform: scale(1.02);
        }

        #group-color-dropdown option {
            padding: 8px;
            font-weight: 600;
        }

        .apply-multi-btn {
            flex: 1;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid var(--accent-green);
            color: var(--accent-green);
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        .apply-multi-btn:hover:not(:disabled) {
            background: rgba(0, 255, 136, 0.2);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 255, 136, 0.3);
        }

        .apply-multi-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* Color Management */
        .color-management {
            margin-bottom: 24px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px;
        }

        .color-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            user-select: none;
        }

        .color-title {
            font-size: 13px;
            font-weight: 600;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .collapse-btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-size: 12px;
        }

        .collapse-btn:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        .color-content {
            max-height: 500px;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .color-content.collapsed {
            max-height: 0;
        }

        .color-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            margin-bottom: 12px;
        }

        .color-item {
            position: relative;
            aspect-ratio: 1;
            border-radius: 6px;
            border: 2px solid var(--border);
            cursor: pointer;
            transition: all 0.2s;
        }

        .color-item:hover {
            border-color: var(--accent-cyan);
            transform: scale(1.05);
        }

        .color-item.selected {
            border-color: var(--accent-green);
            border-width: 3px;
            box-shadow: 0 0 0 3px rgba(0, 255, 136, 0.3), 0 0 20px rgba(0, 255, 136, 0.5);
            transform: scale(1.1);
        }
        
        .color-item.selected::after {
            content: '‚úì';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.8), 0 0 8px rgba(0, 0, 0, 0.5);
            pointer-events: none;
        }

        .color-remove {
            position: absolute;
            top: -6px;
            right: -6px;
            background: var(--accent-magenta);
            border: 2px solid var(--bg-tertiary);
            color: white;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            z-index: 10;
        }

        .color-item:hover .color-remove {
            display: flex;
        }

        .color-add-section {
            display: flex;
            gap: 12px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border);
            align-items: flex-start;
        }

        .color-input-new {
            flex: 1;
            height: 36px;
            border-radius: 6px;
            border: 2px solid var(--border);
            cursor: pointer;
        }

        .add-color-btn {
            background: rgba(255, 0, 107, 0.1);
            border: 1px solid var(--accent-magenta);
            color: var(--accent-magenta);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-size: 11px;
            font-weight: 600;
            transition: all 0.2s;
            white-space: nowrap;
            align-self: flex-end;
            margin-top: 18px;
        }

        .add-color-btn:hover {
            background: rgba(255, 0, 107, 0.2);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(255, 0, 107, 0.3);
            border-color: var(--accent-magenta);
        }

        .group-color-section {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border);
        }

        .group-label {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 8px;
            font-family: 'Azeret Mono', monospace;
        }

        .apply-to-selected-btn {
            width: 100%;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid var(--accent-green);
            color: var(--accent-green);
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        .apply-to-selected-btn:hover {
            background: rgba(0, 255, 136, 0.2);
        }

        .apply-to-selected-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Parts Section - keeping styles minimal for brevity */
        .section-header {
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .section-header-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .section-header-left::before {
            content: '';
            width: 3px;
            height: 12px;
            background: var(--accent-cyan);
            border-radius: 2px;
        }

        .section-actions {
            display: flex;
            gap: 8px;
        }

        .section-btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-size: 10px;
            font-weight: 600;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        .section-btn:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        .selection-info {
            font-size: 11px;
            color: var(--accent-green);
            font-weight: 600;
        }

        .part-section {
            margin-bottom: 24px;
        }

        .empty-state {
            text-align: center;
            padding: 32px 16px;
            color: var(--text-secondary);
            font-size: 13px;
            opacity: 0.6;
        }

        .part-card {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .part-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 3px;
            height: 100%;
            background: var(--accent-cyan);
            transform: scaleY(0);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .part-card:hover {
            border-color: var(--accent-cyan);
            box-shadow: 0 4px 20px rgba(0, 245, 255, 0.1);
        }

        .part-card:hover::before {
            transform: scaleY(1);
        }

        .part-card.expanded {
            border-color: var(--accent-cyan);
        }

        .part-card.hidden-part {
            opacity: 0.5;
        }

        .part-card.selected {
            border-color: var(--accent-green);
            background: rgba(0, 255, 136, 0.05);
        }

        .part-card.locked {
            border-color: var(--accent-orange);
            background: rgba(255, 107, 53, 0.05);
        }

        .part-card.minimized .part-content {
            max-height: 0;
            opacity: 0;
            margin-top: 0;
        }

        .part-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .part-name-section {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
        }

        .select-checkbox {
            width: 24px;
            height: 24px;
            border: 2px solid var(--border);
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-size: 14px;
            font-weight: bold;
            background: var(--bg-primary);
            flex-shrink: 0;
        }

        .select-checkbox:hover {
            border-color: var(--accent-green);
            background: rgba(0, 255, 136, 0.1);
        }

        .select-checkbox.checked {
            background: var(--accent-green);
            border-color: var(--accent-green);
            color: var(--bg-primary);
        }

        .part-name {
            font-size: 15px;
            font-weight: 600;
            letter-spacing: 0.3px;
        }

        .part-actions {
            display: flex;
            gap: 8px;
        }

        .icon-btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            width: 32px;
            height: 32px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-size: 14px;
            font-weight: 600;
        }

        .icon-btn:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        .icon-btn.danger:hover {
            border-color: var(--accent-magenta);
            color: var(--accent-magenta);
        }

        .icon-btn.active {
            background: rgba(0, 245, 255, 0.1);
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        .icon-btn.visibility {
            background: rgba(0, 255, 136, 0.1);
            border-color: var(--accent-green);
            color: var(--accent-green);
        }

        .icon-btn.visibility.hidden-btn {
            background: rgba(255, 0, 107, 0.1);
            border-color: var(--accent-magenta);
            color: var(--accent-magenta);
        }

        .icon-btn.lock-btn {
            background: rgba(255, 107, 53, 0.1);
            border-color: var(--accent-orange);
            color: var(--accent-orange);
        }

        .icon-btn.lock-btn.locked {
            background: rgba(255, 107, 53, 0.2);
        }

        .part-content {
            max-height: 2000px;
            opacity: 1;
            overflow: hidden;
            transition: all 0.3s ease;
            margin-top: 12px;
        }

        /* Coordinate Display */
        .coordinate-display {
            background: rgba(0, 245, 255, 0.05);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 12px;
            font-family: 'Azeret Mono', monospace;
            font-size: 11px;
        }

        .coord-title {
            color: var(--accent-cyan);
            font-weight: 600;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .coord-values {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .coord-item {
            text-align: center;
        }

        .coord-label {
            color: var(--text-secondary);
            font-size: 9px;
            margin-bottom: 2px;
        }

        .coord-value {
            color: var(--text-primary);
            font-weight: 600;
        }

        .color-picker-container {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .color-input-wrapper {
            position: relative;
            flex: 1;
        }

        .color-preview {
            width: 100%;
            height: 40px;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid var(--border);
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }

        .color-preview::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, transparent 0%, rgba(255, 255, 255, 0.1) 100%);
            pointer-events: none;
        }

        .color-preview:hover {
            border-color: var(--accent-cyan);
            transform: scale(1.02);
        }

        input[type="color"] {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .color-hex {
            font-family: 'Azeret Mono', monospace;
            font-size: 11px;
            color: var(--text-secondary);
            text-align: center;
            margin-top: 6px;
            letter-spacing: 0.5px;
        }

        .preset-colors {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 6px;
            margin-top: 12px;
        }

        .preset-color {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .preset-color:hover {
            border-color: var(--accent-cyan);
            transform: scale(1.1);
        }

        /* Transform Controls - minimal for space */
        .transform-controls {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border);
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .transform-controls.show {
            max-height: 800px;
        }

        .transform-controls.disabled {
            pointer-events: none;
            opacity: 0.3;
        }

        .transform-section {
            margin-bottom: 16px;
        }

        .transform-label {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 8px;
            font-family: 'Azeret Mono', monospace;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .transform-label::before {
            content: '';
            width: 2px;
            height: 10px;
            background: var(--accent-cyan);
        }

        .transform-sliders {
            display: grid;
            gap: 10px;
        }

        .slider-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .slider-label {
            font-family: 'Azeret Mono', monospace;
            font-size: 11px;
            color: var(--accent-cyan);
            width: 12px;
            font-weight: 600;
        }

        .slider-label.rotation {
            color: var(--accent-magenta);
        }

        .slider-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: var(--bg-primary);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--accent-cyan);
            cursor: pointer;
        }

        input[type="range"].rotation::-webkit-slider-thumb {
            background: var(--accent-magenta);
        }

        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--accent-cyan);
            cursor: pointer;
            border: none;
        }

        input[type="range"].rotation::-moz-range-thumb {
            background: var(--accent-magenta);
        }

        .input-controls {
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .number-input {
            flex: 1;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 4px 8px;
            border-radius: 4px;
            font-family: 'Azeret Mono', monospace;
            font-size: 11px;
            text-align: center;
        }

        .number-input:focus {
            outline: none;
            border-color: var(--accent-cyan);
        }

        .arrow-btn {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-size: 12px;
            font-weight: 600;
        }

        .arrow-btn:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
            background: rgba(0, 245, 255, 0.1);
        }

        .arrow-btn:active {
            transform: scale(0.95);
        }

        .transform-reset {
            margin-top: 12px;
            width: 100%;
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        .transform-reset:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        /* Viewer */
        .viewer {
            position: relative;
            background: radial-gradient(ellipse at center, #1a2030 0%, var(--bg-primary) 100%);
        }

        #canvas-container {
            width: 100%;
            height: 100%;
        }

        .viewer-controls {
            position: absolute;
            top: 24px;
            right: 24px;
            display: flex;
            gap: 12px;
        }

        .control-btn {
            background: rgba(20, 25, 34, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 10px 18px;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-size: 13px;
            font-weight: 600;
            letter-spacing: 0.5px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
        }

        .control-btn:hover {
            background: rgba(0, 245, 255, 0.1);
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
            box-shadow: 0 4px 20px rgba(0, 245, 255, 0.2);
        }

        .control-btn.active {
            background: rgba(255, 215, 0, 0.2);
            border-color: var(--accent-yellow);
            color: var(--accent-yellow);
        }

        .info-overlay {
            position: absolute;
            bottom: 24px;
            left: 24px;
            background: rgba(20, 25, 34, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px 20px;
            font-family: 'Azeret Mono', monospace;
            font-size: 11px;
            color: var(--text-secondary);
        }

        .info-overlay div {
            margin-bottom: 4px;
        }

        .info-overlay div:last-child {
            margin-bottom: 0;
        }

        .info-label {
            color: var(--accent-cyan);
            margin-right: 8px;
        }

        /* Measurement Overlay */
        .measurement-overlay {
            position: absolute;
            top: 24px;
            left: 24px;
            background: rgba(20, 25, 34, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid var(--accent-yellow);
            border-radius: 8px;
            padding: 16px 20px;
            font-family: 'Azeret Mono', monospace;
            font-size: 11px;
            color: var(--text-primary);
            display: none;
        }

        .measurement-overlay.active {
            display: block;
        }

        .measurement-title {
            color: var(--accent-yellow);
            font-weight: 600;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .measurement-value {
            font-size: 18px;
            color: var(--accent-yellow);
            margin: 8px 0;
            font-weight: 600;
        }

        .measurement-hint {
            color: var(--text-secondary);
            font-size: 10px;
            margin-top: 8px;
        }

        /* Animations */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .part-card {
            animation: fadeInUp 0.5s cubic-bezier(0.4, 0, 0.2, 1) backwards;
        }

        /* Custom Scrollbar */
        .sidebar::-webkit-scrollbar {
            width: 6px;
        }

        .sidebar::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }

        .sidebar::-webkit-scrollbar-thumb {
            background: var(--accent-cyan);
            border-radius: 3px;
        }

        .sidebar::-webkit-scrollbar-thumb:hover {
            background: var(--accent-magenta);
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: 24px;
            right: 24px;
            background: rgba(20, 25, 34, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid var(--accent-cyan);
            border-radius: 8px;
            padding: 16px 20px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            transform: translateY(150%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1000;
            box-shadow: 0 8px 32px rgba(0, 245, 255, 0.2);
        }

        .toast.show {
            transform: translateY(0);
        }

        /* Measurement Line */
        .measurement-line {
            position: absolute;
            height: 2px;
            background: var(--accent-yellow);
            transform-origin: 0 0;
            pointer-events: none;
            z-index: 100;
        }

        .measurement-point {
            position: absolute;
            width: 8px;
            height: 8px;
            background: var(--accent-yellow);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 101;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <div class="logo">PRINT PALETTE</div>
            <div class="subtitle">3D Print Colour Preview</div>
            
            <!-- Project Name Section -->
            <div class="project-name-section">
                <div class="project-label">Project Name</div>
                <input type="text" class="project-name-input" id="project-name" placeholder="My Blaster Assembly" value="Untitled Project">
            </div>

            <!-- Upload Section -->
            <div class="upload-section">
                <div class="upload-zone" id="upload-zone" onclick="document.getElementById('file-input').click()">
                    <div class="upload-icon">üì¶</div>
                    <div class="upload-text">Load STL Parts</div>
                    <div class="upload-hint">Or load a project file (.stlproject)</div>
                </div>
                <input type="file" id="file-input" accept=".stl,.stlproject" multiple>
            </div>

            <!-- Project Buttons -->
            <div class="action-buttons">
                <button class="action-btn project" onclick="saveProject()">üíæ Save Project</button>
                <button class="action-btn project" onclick="loadProject()">üìÇ Load Project</button>
            </div>

            <!-- Action Buttons -->
            <div class="action-buttons">
                <button class="action-btn export-stl" onclick="exportAssembly()">üì• Export STL</button>
                <button class="action-btn secondary" onclick="exportImage()">üì∏ Image</button>
                <button class="action-btn secondary" onclick="randomizeColors()">üé≤ Random Colour</button>
                <button class="action-btn secondary" onclick="clearAll()">üìÑ New Project</button>
            </div>

            <!-- Group Management -->
            <div class="group-management">
                <div class="section-header">
                    <div class="section-header-left">
                        <span>üìÅ Part Groups</span>
                    </div>
                </div>
                <div style="background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 8px; padding: 16px;">
                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 8px; font-family: 'Azeret Mono', monospace;">
                        1. Check parts below (‚úì) ‚Üí 2. Name group ‚Üí 3. Create
                    </div>
                    <input type="text" id="new-group-name" placeholder="Group name (e.g. 'Metal Parts')" 
                           style="width: 100%; padding: 10px; margin-bottom: 8px; background: var(--bg-primary); border: 1px solid var(--border); color: var(--text-primary); border-radius: 6px; font-family: 'Rajdhani', sans-serif;">
                    <button class="action-btn secondary" onclick="createGroup()" style="width: 100%; margin-bottom: 16px;">
                        ‚ûï Create Group from Selected Parts
                    </button>
                    
                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 8px; font-family: 'Azeret Mono', monospace; border-top: 1px solid var(--border); padding-top: 16px;">
                        Apply colour to saved group:
                    </div>
                    <select id="group-selector" onchange="selectGroup(this.value)" 
                            style="width: 100%; padding: 10px; margin-bottom: 8px; background: var(--bg-primary); border: 1px solid var(--border); color: var(--text-primary); border-radius: 6px; font-family: 'Rajdhani', sans-serif; cursor: pointer;">
                        <option value="">Select a group...</option>
                    </select>
                    
                    <div style="display: flex; gap: 12px; align-items: center; margin-bottom: 4px;">
                        <div style="display: flex; flex-direction: column; gap: 4px; flex: 1;">
                            <div style="font-size: 9px; color: var(--text-secondary); font-family: 'Azeret Mono', monospace; text-transform: uppercase;">Group Colour:</div>
                            <select id="group-color-dropdown" onchange="updateGroupColorFromDropdown()" style="padding: 8px; border-radius: 6px; background: var(--bg-primary); border: 1px solid var(--border); color: var(--text-primary); font-family: 'Rajdhani', sans-serif; cursor: pointer; font-size: 12px;">
                                <option value="">Pick a colour</option>
                            </select>
                        </div>
                        <button class="apply-multi-btn" id="apply-group-color-btn" onclick="applyColorToGroup()" disabled>
                            Select Group First
                        </button>
                    </div>
                    
                    <button class="action-btn secondary" onclick="deleteGroup()" id="delete-group-btn" disabled style="width: 100%; background: rgba(255, 0, 107, 0.1); border-color: var(--accent-magenta); color: var(--accent-magenta);">
                        üóë Delete Selected Group
                    </button>
                    
                    <button class="apply-multi-btn" onclick="colorAllGroupsRandomly()" style="width: 100%; margin-top: 8px; background: linear-gradient(135deg, rgba(138, 85, 247, 0.2), rgba(255, 107, 53, 0.2)); border-color: var(--accent-purple); color: var(--accent-purple);">
                        üé≤ Randomize All Group Colours
                    </button>
                </div>
            </div>

            <!-- Parts Section -->
            <div class="part-section">
                <div class="section-header">
                    <div class="section-header-left">
                        <span>Assembly Parts</span>
                    </div>
                    <div class="section-actions">
                        <button class="section-btn" onclick="expandAllParts()">Expand</button>
                        <button class="section-btn" onclick="collapseAllParts()">Collapse</button>
                    </div>
                </div>
                <div id="parts-container">
                    <div class="empty-state">
                        No parts loaded yet.<br>
                        Upload STL files or load a project.
                    </div>
                </div>
            </div>
        </div>

        <div class="viewer">
            <div id="canvas-container"></div>
            
            <div class="viewer-controls">
                <button class="control-btn" onclick="resetCamera()">Reset View</button>
                <button class="control-btn" onclick="frameModel()">Frame All</button>
                <button class="control-btn" id="measure-btn" onclick="toggleMeasure()">üìè Measure</button>
            </div>

            <div class="measurement-overlay" id="measurement-overlay">
                <div class="measurement-title">Measurement Tool</div>
                <div class="measurement-hint">Click two points to measure distance</div>
                <div class="measurement-value" id="measurement-value">--</div>
                <div id="bounding-box-info"></div>
            </div>

            <div class="info-overlay">
                <div><span class="info-label">ROTATE:</span>Left drag</div>
                <div><span class="info-label">PAN:</span>Right drag</div>
                <div><span class="info-label">ZOOM:</span>Scroll wheel</div>
                <div><span class="info-label">PARTS:</span><span id="part-count">0</span> loaded</div>
                <div id="project-name-display"></div>
            </div>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <script>
        // Scene setup
        let scene, camera, renderer, raycaster, mouse;
        let parts = [];
        let partFiles = {}; // Store original STL files
        let loader, exporter;
        let modelGroup;
        let measureMode = false;
        let measurePoints = [];
        let selectedParts = new Set();
        let groups = []; // Array of { name: string, parts: Set<number> }
        let selectedGroup = null;
        
        let presetColors = [
            '#ff006b', '#00f5ff', '#5b6fd8', '#ffd700', '#00ff88',
            '#ff6b35', '#a855f7', '#2a3550', '#f8f8f8', '#1a1a1a',
            '#ff3366', '#33ff99', '#3366ff', '#ffcc00', '#cc33ff'
        ];

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0e17);
            
            modelGroup = new THREE.Group();
            scene.add(modelGroup);
            
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 50, 150);
            camera.lookAt(0, 0, 0);
            
            const container = document.getElementById('canvas-container');
            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);
            
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(100, 100, 100);
            scene.add(mainLight);
            
            const fillLight = new THREE.DirectionalLight(0x00f5ff, 0.3);
            fillLight.position.set(-100, 0, -100);
            scene.add(fillLight);
            
            const rimLight = new THREE.DirectionalLight(0xff006b, 0.2);
            rimLight.position.set(0, -100, -100);
            scene.add(rimLight);
            
            loader = new THREE.STLLoader();
            exporter = new THREE.STLExporter();
            
            setupFileUpload();
            setupControls();
            animate();
            updateProjectDisplay();
            
            window.addEventListener('resize', onWindowResize);
        }

        function updateProjectDisplay() {
            const projectName = document.getElementById('project-name').value;
            document.getElementById('project-name-display').innerHTML = 
                `<span class="info-label">PROJECT:</span>${projectName}`;
        }

        // Update project name when changed
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('project-name').addEventListener('input', updateProjectDisplay);
        });

        // PROJECT SAVE/LOAD FUNCTIONS
        async function saveProject() {
            if (parts.length === 0) {
                showToast('‚ö†Ô∏è No parts to save');
                return;
            }

            try {
                const projectName = document.getElementById('project-name').value || 'Untitled Project';
                showToast('üíæ Saving project...');

                const zip = new JSZip();
                const stlFolder = zip.folder("stl_files");

                // Save all original STL files
                for (let i = 0; i < parts.length; i++) {
                    const part = parts[i];
                    const fileName = `${part.userData.name}.stl`;
                    
                    console.log(`Exporting part ${i}: ${fileName}`);
                    
                    // Create a temporary mesh with ONLY the geometry (no transforms)
                    const tempGeometry = part.geometry.clone();
                    const tempMesh = new THREE.Mesh(tempGeometry, new THREE.MeshBasicMaterial());
                    
                    // Export as binary STL
                    const stlData = exporter.parse(tempMesh, { binary: true });
                    
                    console.log(`STL data type: ${stlData.constructor.name}, length: ${stlData.byteLength || stlData.length}`);
                    
                    // Add to zip as binary
                    if (stlData instanceof DataView) {
                        // If it's a DataView, get the buffer
                        stlFolder.file(fileName, stlData.buffer, { binary: true });
                    } else if (stlData instanceof ArrayBuffer) {
                        stlFolder.file(fileName, stlData, { binary: true });
                    } else if (stlData instanceof Uint8Array) {
                        stlFolder.file(fileName, stlData, { binary: true });
                    } else {
                        // Fallback - treat as array and convert
                        const buffer = new Uint8Array(stlData);
                        stlFolder.file(fileName, buffer, { binary: true });
                    }
                    
                    // Cleanup
                    tempGeometry.dispose();
                    tempMesh.geometry.dispose();
                    tempMesh.material.dispose();
                }

                // Save project configuration
                const projectData = {
                    projectName: projectName,
                    version: "1.0",
                    created: new Date().toISOString(),
                    parts: parts.map(part => ({
                        name: part.userData.name,
                        fileName: `${part.userData.name}.stl`,
                        color: part.userData.color,
                        visible: part.userData.visible,
                        position: part.userData.position,
                        rotation: part.userData.rotation,
                        locked: part.userData.locked
                    })),
                    groups: groups.map(g => ({
                        name: g.name,
                        parts: Array.from(g.parts),
                        color: g.color || '#ffffff'
                    }))
                };

                zip.file("project.json", JSON.stringify(projectData, null, 2));

                console.log('Generating ZIP file...');
                
                // Generate and download zip
                const content = await zip.generateAsync({ 
                    type: "blob",
                    compression: "DEFLATE",
                    compressionOptions: { level: 6 }
                });
                
                console.log('ZIP generated, size:', content.size);
                
                const url = URL.createObjectURL(content);
                const link = document.createElement('a');
                link.href = url;
                link.download = `${projectName.replace(/[^a-z0-9]/gi, '_')}.stlproject`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                setTimeout(() => {
                    URL.revokeObjectURL(url);
                }, 100);

                showToast(`üíæ Project "${projectName}" saved successfully!`);
                console.log('Project saved successfully');
                
            } catch (err) {
                console.error('Save project error:', err);
                console.error('Error stack:', err.stack);
                showToast('‚ö†Ô∏è Error saving project: ' + err.message);
            }
        }

        async function loadProject() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.stlproject';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                showToast('üìÇ Loading project...');

                try {
                    console.log('=== Loading Project ===');
                    console.log('File:', file.name, 'Size:', file.size);
                    
                    const zip = await JSZip.loadAsync(file);
                    console.log('ZIP loaded successfully');
                    
                    // Read project configuration
                    const projectJsonFile = zip.file("project.json");
                    if (!projectJsonFile) {
                        throw new Error('Invalid project file - missing project.json');
                    }

                    const projectJsonText = await projectJsonFile.async("text");
                    const projectData = JSON.parse(projectJsonText);
                    console.log('Project data:', projectData);

                    // Validate project data
                    if (!projectData.parts || projectData.parts.length === 0) {
                        throw new Error('Project has no parts');
                    }

                    // Clear existing parts
                    clearAllSilent();

                    // Set project name
                    document.getElementById('project-name').value = projectData.projectName;
                    updateProjectDisplay();

                    // Load STL files
                    const stlFolder = zip.folder("stl_files");
                    if (!stlFolder) {
                        throw new Error('Invalid project file - missing stl_files folder');
                    }
                    
                    console.log(`Loading ${projectData.parts.length} parts...`);
                    
                    const loadedParts = [];
                    const failedParts = [];

                    // Load parts sequentially for better error handling
                    for (const partData of projectData.parts) {
                        try {
                            console.log(`Loading part: ${partData.name} (${partData.fileName})`);
                            
                            const stlFile = stlFolder.file(partData.fileName);
                            if (!stlFile) {
                                console.warn(`STL file not found: ${partData.fileName}`);
                                failedParts.push(partData.name);
                                continue;
                            }
                            
                            // Get the file as arraybuffer with validation
                            const arrayBuffer = await stlFile.async("arraybuffer");
                            
                            if (!arrayBuffer || arrayBuffer.byteLength === 0) {
                                console.error(`Empty STL file: ${partData.fileName}`);
                                failedParts.push(partData.name);
                                continue;
                            }
                            
                            console.log(`STL data loaded: ${arrayBuffer.byteLength} bytes`);
                            
                            await loadSTLFromBuffer(arrayBuffer, partData);
                            loadedParts.push(partData.name);
                            
                        } catch (partErr) {
                            console.error(`Failed to load part ${partData.name}:`, partErr);
                            failedParts.push(partData.name);
                        }
                    }

                    console.log(`Parts loaded: ${loadedParts.length}/${projectData.parts.length}`);
                    
                    if (loadedParts.length === 0) {
                        throw new Error('No parts could be loaded from project');
                    }

                    frameModel();
                    
                    // Restore groups if present
                    if (projectData.groups && Array.isArray(projectData.groups)) {
                        groups = projectData.groups.map(g => ({
                            name: g.name,
                            parts: new Set(g.parts),
                            color: g.color || '#ffffff'
                        }));
                        renderGroupSelector();
                        console.log('Groups restored:', groups.length);
                    }
                    
                    // Show success/warning message
                    if (failedParts.length === 0) {
                        showToast(`üìÇ Project "${projectData.projectName}" loaded successfully!`);
                    } else {
                        showToast(`‚ö†Ô∏è Loaded ${loadedParts.length}/${projectData.parts.length} parts (${failedParts.length} failed)`);
                        console.warn('Failed parts:', failedParts);
                    }
                    
                    console.log('=== Project Load Complete ===');

                } catch (err) {
                    console.error('=== Load Project Error ===');
                    console.error('Error:', err);
                    console.error('Stack:', err.stack);
                    
                    showToast('‚ö†Ô∏è Error loading project: ' + err.message);
                    
                    // Show detailed error in UI
                    const errorDetail = document.createElement('div');
                    errorDetail.style.cssText = 'position: fixed; top: 100px; left: 50%; transform: translateX(-50%); background: rgba(255, 0, 107, 0.95); color: white; padding: 20px; border-radius: 8px; z-index: 10000; max-width: 500px; box-shadow: 0 8px 32px rgba(0,0,0,0.5);';
                    errorDetail.innerHTML = `
                        <strong style="font-size: 18px;">Project Load Error:</strong><br><br>
                        <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 4px; margin: 10px 0;">
                            ${err.message}
                        </div>
                        <small style="opacity: 0.8;">Check console (F12) for detailed error information</small><br><br>
                        <button onclick="this.parentElement.remove()" style="width: 100%; margin-top: 10px; padding: 10px; background: white; color: #ff006b; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 14px;">Close</button>
                    `;
                    document.body.appendChild(errorDetail);
                    setTimeout(() => errorDetail.remove(), 15000);
                }
            };
            input.click();
        }

        function loadSTLFromBuffer(arrayBuffer, partData) {
            return new Promise((resolve, reject) => {
                try {
                    console.log(`Loading STL buffer for ${partData.name}, size: ${arrayBuffer.byteLength} bytes`);
                    
                    // Validate the arrayBuffer
                    if (!arrayBuffer || arrayBuffer.byteLength === 0) {
                        throw new Error(`Invalid or empty STL data for ${partData.name}`);
                    }
                    
                    // Parse the STL geometry
                    const geometry = loader.parse(arrayBuffer);
                    
                    if (!geometry || !geometry.attributes || !geometry.attributes.position) {
                        throw new Error(`Failed to parse STL geometry for ${partData.name}`);
                    }
                    
                    console.log(`Geometry loaded: ${geometry.attributes.position.count} vertices`);
                    
                    const material = new THREE.MeshStandardMaterial({
                        color: partData.color,
                        metalness: 0.3,
                        roughness: 0.4,
                        flatShading: false
                    });
                    
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.userData = {
                        name: partData.name,
                        visible: partData.visible !== undefined ? partData.visible : true,
                        color: partData.color,
                        position: partData.position || { x: 0, y: 0, z: 0 },
                        rotation: partData.rotation || { x: 0, y: 0, z: 0 },
                        locked: partData.locked || false
                    };

                    // Apply transformations
                    mesh.position.set(
                        mesh.userData.position.x,
                        mesh.userData.position.y,
                        mesh.userData.position.z
                    );

                    mesh.rotation.set(
                        mesh.userData.rotation.x * (Math.PI / 180),
                        mesh.userData.rotation.y * (Math.PI / 180),
                        mesh.userData.rotation.z * (Math.PI / 180)
                    );

                    mesh.visible = mesh.userData.visible;
                    
                    modelGroup.add(mesh);
                    parts.push(mesh);
                    
                    addPartControl(parts.length - 1);
                    updatePartCount();
                    updateBoundingBox();
                    updateCoordinates(parts.length - 1);

                    // Apply locked state if needed
                    if (mesh.userData.locked) {
                        setTimeout(() => {
                            const lockBtn = document.getElementById(`lock-btn-${parts.length - 1}`);
                            const card = document.getElementById(`part-card-${parts.length - 1}`);
                            if (lockBtn && card) {
                                lockBtn.classList.add('locked');
                                lockBtn.textContent = 'üîí';
                                card.classList.add('locked');
                            }
                        }, 100);
                    }
                    
                    // Apply hidden state if needed
                    if (!mesh.userData.visible) {
                        setTimeout(() => {
                            const visBtn = document.getElementById(`vis-btn-${parts.length - 1}`);
                            const card = document.getElementById(`part-card-${parts.length - 1}`);
                            if (visBtn && card) {
                                visBtn.classList.add('hidden-btn');
                                visBtn.classList.remove('visibility');
                                visBtn.textContent = '‚®Ø';
                                card.classList.add('hidden-part');
                            }
                        }, 100);
                    }

                    console.log(`Part ${partData.name} loaded successfully`);
                    resolve();
                    
                } catch (err) {
                    console.error(`Error loading part ${partData.name}:`, err);
                    reject(err);
                }
            });
        }

        function clearAllSilent() {
            parts.forEach(part => {
                modelGroup.remove(part);
                part.geometry.dispose();
                part.material.dispose();
            });
            parts = [];
            partFiles = {};
            selectedParts.clear();
            groups = [];
            selectedGroup = null;
            
            // Reset project name
            const projectNameInput = document.getElementById('project-name');
            if (projectNameInput) {
                projectNameInput.value = 'Untitled Project';
            }
            
            rebuildUI();
            updatePartCount();
            updateBoundingBox();
            renderGroupSelector();
        }

        // Part Selection for Group Creation
        function togglePartSelection(index) {
            console.log('Toggle part selection:', index);
            
            const checkbox = document.getElementById(`checkbox-${index}`);
            const card = document.getElementById(`part-card-${index}`);
            
            if (!checkbox || !card) {
                console.error('Could not find checkbox or card!');
                return;
            }
            
            if (selectedParts.has(index)) {
                selectedParts.delete(index);
                checkbox.classList.remove('checked');
                checkbox.textContent = '';
                card.classList.remove('selected');
            } else {
                selectedParts.add(index);
                checkbox.classList.add('checked');
                checkbox.textContent = '‚úì';
                card.classList.add('selected');
            }
            
            console.log('Selected parts:', Array.from(selectedParts));
        }

        // Group Management Functions
        function createGroup() {
            const nameInput = document.getElementById('new-group-name');
            const name = nameInput.value.trim();
            
            if (!name) {
                showToast('‚ö†Ô∏è Enter a group name first');
                return;
            }
            
            if (selectedParts.size === 0) {
                showToast('‚ö†Ô∏è Select parts first (use checkboxes ‚úì)');
                return;
            }
            
            // Avoid duplicates
            if (groups.some(g => g.name === name)) {
                showToast('‚ö†Ô∏è Group "' + name + '" already exists');
                return;
            }
            
            // Get color from dropdown
            const colorDropdown = document.getElementById('group-color-dropdown');
            const selectedColor = colorDropdown ? colorDropdown.value : '#ffffff';
            
            if (!selectedColor || selectedColor === '') {
                showToast('‚ö†Ô∏è Select a colour from the dropdown first');
                return;
            }
            
            // Create new group with current selection and color
            const groupPartsCount = selectedParts.size;
            groups.push({ 
                name, 
                parts: new Set(selectedParts),
                color: selectedColor
            });
            
            nameInput.value = '';
            
            // Reset dropdown appearance
            if (colorDropdown) {
                colorDropdown.value = '';
                colorDropdown.style.backgroundColor = 'var(--bg-primary)';
                colorDropdown.style.color = 'var(--text-primary)';
                colorDropdown.style.borderColor = 'var(--border)';
            }
            
            // Clear selection visually
            selectedParts.forEach(index => {
                const checkbox = document.getElementById(`checkbox-${index}`);
                const card = document.getElementById(`part-card-${index}`);
                if (checkbox) {
                    checkbox.classList.remove('checked');
                    checkbox.textContent = '';
                }
                if (card) {
                    card.classList.remove('selected');
                }
            });
            selectedParts.clear();
            
            renderGroupSelector();
            showToast(`‚úì Group "${name}" created with ${groupPartsCount} part(s)`);
            
            console.log('Group created:', name, 'Color:', selectedColor);
        }

        function renderGroupSelector() {
            const selector = document.getElementById('group-selector');
            if (!selector) return;
            
            selector.innerHTML = '<option value="">Select Group</option>';
            
            groups.forEach((group, i) => {
                const color = group.color || '#ffffff';
                const option = document.createElement('option');
                option.value = i;
                option.textContent = `üî∑ ${group.name} (${group.parts.size} parts)`;
                option.style.color = color;
                option.style.fontWeight = 'bold';
                selector.appendChild(option);
            });
            
            console.log('Group selector rendered with', groups.length, 'groups');
        }

        function selectGroup(index) {
            const applyBtn = document.getElementById('apply-group-color-btn');
            const deleteBtn = document.getElementById('delete-group-btn');
            const colorDropdown = document.getElementById('group-color-dropdown');
            
            if (index === '' || index === null) {
                selectedGroup = null;
                
                // Reset dropdown
                if (colorDropdown) {
                    colorDropdown.value = '';
                    colorDropdown.style.backgroundColor = 'var(--bg-primary)';
                    colorDropdown.style.color = 'var(--text-primary)';
                }
                
                if (applyBtn) {
                    applyBtn.disabled = true;
                    applyBtn.textContent = 'Select Group First';
                    applyBtn.style.background = 'rgba(0, 255, 136, 0.1)';
                    applyBtn.style.borderColor = 'var(--accent-green)';
                }
                if (deleteBtn) deleteBtn.disabled = true;
                return;
            }
            
            selectedGroup = groups[parseInt(index)];
            
            // Load the group's current color into the dropdown
            if (colorDropdown && selectedGroup.color) {
                colorDropdown.value = selectedGroup.color;
                // Set dropdown background to group's color
                colorDropdown.style.backgroundColor = selectedGroup.color;
                colorDropdown.style.color = '#fff';
                colorDropdown.style.fontWeight = '600';
                updateGroupColorFromDropdown();
            }
            
            if (applyBtn && colorDropdown) {
                applyBtn.disabled = false;
                const color = colorDropdown.value || selectedGroup.color || '#ffffff';
                applyBtn.textContent = `Apply ${color.toUpperCase()} to "${selectedGroup.name}"`;
                applyBtn.style.background = `linear-gradient(135deg, ${color}22, ${color}44)`;
                applyBtn.style.borderColor = color;
            }
            
            if (deleteBtn) {
                deleteBtn.disabled = false;
            }
            
            console.log('Group selected:', selectedGroup.name, 'Parts:', Array.from(selectedGroup.parts), 'Color:', selectedGroup.color);
        }

        function animatePartColorChange(mesh, targetColor, duration = 500) {
            const start = mesh.material.color.clone();
            const end = new THREE.Color(targetColor);
            const startTime = performance.now();

            function animate() {
                const elapsed = performance.now() - startTime;
                const t = Math.min(1, elapsed / duration);
                mesh.material.color.r = start.r + (end.r - start.r) * t;
                mesh.material.color.g = start.g + (end.g - start.g) * t;
                mesh.material.color.b = start.b + (end.b - start.b) * t;

                if (t < 1) requestAnimationFrame(animate);
            }
            animate();
        }

        function applyColorToGroup() {
            if (!selectedGroup) {
                showToast('‚ö†Ô∏è Select a group first');
                return;
            }
            
            const colorDropdown = document.getElementById('group-color-dropdown');
            const selectedColor = colorDropdown ? colorDropdown.value : '#ff006b';
            
            if (!selectedColor || selectedColor === '') {
                showToast('‚ö†Ô∏è Select a colour from the dropdown first');
                return;
            }
            
            console.log('=== Apply Color to Group ===');
            console.log('Group:', selectedGroup.name);
            console.log('Color dropdown element:', colorDropdown);
            console.log('Color value:', selectedColor);
            
            let successCount = 0;
            
            selectedGroup.parts.forEach(idx => {
                if (parts[idx]) {
                    animatePartColorChange(parts[idx], selectedColor);
                    parts[idx].userData.color = selectedColor;
                    
                    const preview = document.getElementById(`preview-${idx}`);
                    const hex = document.getElementById(`hex-${idx}`);
                    const colorInput = preview?.querySelector('input');
                    if (preview) preview.style.background = selectedColor;
                    if (hex) hex.textContent = selectedColor;
                    if (colorInput) colorInput.value = selectedColor;
                    successCount++;
                }
            });
            
            // Save color to group
            selectedGroup.color = selectedColor;
            renderGroupSelector();
            
            showToast(`‚úì Applied ${selectedColor} to "${selectedGroup.name}" (${successCount} parts)`);
            console.log('Color applied successfully');
        }

        function updateGroupColorFromDropdown() {
            const dropdown = document.getElementById('group-color-dropdown');
            
            if (!dropdown) {
                console.warn('Colour dropdown not found');
                return;
            }
            
            const color = dropdown.value;
            
            if (!color) {
                // Reset to default when no color selected
                dropdown.style.backgroundColor = 'var(--bg-primary)';
                dropdown.style.color = 'var(--text-primary)';
                dropdown.style.borderColor = 'var(--border)';
                return;
            }

            // Set dropdown background to selected color
            dropdown.style.backgroundColor = color;
            dropdown.style.color = 'white';
            dropdown.style.borderColor = color;
            dropdown.style.borderWidth = '2px';

            if (selectedGroup) {
                const applyBtn = document.getElementById('apply-group-color-btn');
                if (applyBtn) {
                    applyBtn.textContent = `Apply ${color.toUpperCase()} to "${selectedGroup.name}"`;
                    applyBtn.style.background = `linear-gradient(135deg, ${color}22, ${color}44)`;
                    applyBtn.style.borderColor = color;
                }
            }
            
            console.log('Colour selected from dropdown:', color);
        }

        function colorAllGroupsRandomly() {
            if (groups.length === 0) {
                showToast('‚ö†Ô∏è No groups created yet');
                return;
            }
            
            groups.forEach(group => {
                const randomColor = presetColors[Math.floor(Math.random() * presetColors.length)];
                group.color = randomColor;
                
                group.parts.forEach(idx => {
                    if (parts[idx]) {
                        animatePartColorChange(parts[idx], randomColor);
                        parts[idx].userData.color = randomColor;

                        const preview = document.getElementById(`preview-${idx}`);
                        const hex = document.getElementById(`hex-${idx}`);
                        const input = preview?.querySelector('input');
                        if (preview) preview.style.background = randomColor;
                        if (hex) hex.textContent = randomColor;
                        if (input) input.value = randomColor;
                    }
                });
            });
            
            renderGroupSelector();
            showToast('üé≤ All groups coloured randomly!');
            console.log('All groups randomized');
        }

        function deleteGroup() {
            if (!selectedGroup) {
                showToast('‚ö†Ô∏è Select a group first');
                return;
            }
            
            const groupName = selectedGroup.name;
            const index = groups.findIndex(g => g.name === groupName);
            
            if (index !== -1) {
                groups.splice(index, 1);
                selectedGroup = null;
                renderGroupSelector();
                
                const applyBtn = document.getElementById('apply-group-color-btn');
                const deleteBtn = document.getElementById('delete-group-btn');
                if (applyBtn) {
                    applyBtn.disabled = true;
                    applyBtn.textContent = 'Select Group First';
                    applyBtn.style.background = 'rgba(0, 255, 136, 0.1)';
                    applyBtn.style.borderColor = 'var(--accent-green)';
                }
                if (deleteBtn) deleteBtn.disabled = true;
                
                // Reset group selector
                const selector = document.getElementById('group-selector');
                if (selector) selector.value = '';
                
                showToast(`üóë Group "${groupName}" deleted`);
                console.log('Group deleted:', groupName);
            }
        }

        // Populate dropdown and setup event listeners on load
        window.addEventListener('load', () => {
            const dropdown = document.getElementById('group-color-dropdown');
            if (dropdown) {
                // Populate with preset colors
                presetColors.forEach(color => {
                    const option = document.createElement('option');
                    option.value = color;
                    option.textContent = color.toUpperCase();
                    option.style.backgroundColor = color;
                    option.style.color = '#fff';
                    option.style.fontWeight = '600';
                    option.style.padding = '4px 8px';
                    dropdown.appendChild(option);
                });
                
                console.log('Color dropdown populated with', presetColors.length, 'colors');
            }
        });

        // Expand/Collapse All Parts
        function expandAllParts() {
            parts.forEach((part, index) => {
                const card = document.getElementById(`part-card-${index}`);
                const collapseBtn = document.getElementById(`part-collapse-${index}`);
                if (card && card.classList.contains('minimized')) {
                    card.classList.remove('minimized');
                    if (collapseBtn) collapseBtn.textContent = '‚àí';
                }
            });
            showToast('All parts expanded');
        }

        function collapseAllParts() {
            parts.forEach((part, index) => {
                const card = document.getElementById(`part-card-${index}`);
                const collapseBtn = document.getElementById(`part-collapse-${index}`);
                if (card && !card.classList.contains('minimized')) {
                    card.classList.remove('expanded');
                    const transformBtn = document.getElementById(`transform-btn-${index}`);
                    const transformDiv = document.getElementById(`transform-${index}`);
                    if (transformBtn) transformBtn.classList.remove('active');
                    if (transformDiv) transformDiv.classList.remove('show');
                    
                    card.classList.add('minimized');
                    if (collapseBtn) collapseBtn.textContent = '+';
                }
            });
            showToast('All parts collapsed');
        }

        function togglePartCollapse(index) {
            const card = document.getElementById(`part-card-${index}`);
            const btn = document.getElementById(`part-collapse-${index}`);
            
            if (card.classList.contains('minimized')) {
                card.classList.remove('minimized');
                btn.textContent = '‚àí';
            } else {
                card.classList.remove('expanded');
                const transformBtn = document.getElementById(`transform-btn-${index}`);
                const transformDiv = document.getElementById(`transform-${index}`);
                if (transformBtn) transformBtn.classList.remove('active');
                if (transformDiv) transformDiv.classList.remove('show');
                
                card.classList.add('minimized');
                btn.textContent = '+';
            }
        }

        // Color Management
        function renderColorGrid() {
            const grid = document.getElementById('color-grid');
            grid.innerHTML = '';
            
            presetColors.forEach((color, index) => {
                const item = document.createElement('div');
                item.className = 'color-item';
                item.style.background = color;
                item.dataset.color = color; // Store color in data attribute
                
                // Restore selection if this was the selected color
                if (selectedColor && selectedColor.toLowerCase() === color.toLowerCase()) {
                    item.classList.add('selected');
                }
                
                // Fix: Use arrow function to capture 'item' reference correctly
                item.onclick = () => {
                    selectColor(color, item);
                    console.log('Color grid item clicked:', color);
                };
                
                const removeBtn = document.createElement('div');
                removeBtn.className = 'color-remove';
                removeBtn.textContent = '√ó';
                removeBtn.onclick = (e) => {
                    e.stopPropagation();
                    removeColor(index);
                };
                
                item.appendChild(removeBtn);
                grid.appendChild(item);
            });
            
            console.log('Color grid rendered with', presetColors.length, 'colors');
        }

        function selectColor(color, element) {
            console.log('=== Select Palette Color ===');
            console.log('Color:', color);
            console.log('Element:', element);
            console.log('Previously selected color:', selectedColor);
            
            selectedColor = color;
            
            // Remove selected class from all color items
            document.querySelectorAll('.color-item').forEach(el => {
                el.classList.remove('selected');
            });
            
            // Add selected class to clicked item
            if (element) {
                element.classList.add('selected');
                console.log('Added selected class to element');
            } else {
                // If no element provided, find it by color
                document.querySelectorAll('.color-item').forEach(el => {
                    if (el.dataset.color && el.dataset.color.toLowerCase() === color.toLowerCase()) {
                        el.classList.add('selected');
                        console.log('Found and selected element by color match');
                    }
                });
            }
            
            // Update the header indicator
            const indicator = document.getElementById('selected-color-indicator');
            if (indicator) {
                indicator.style.display = 'inline-block';
                indicator.style.background = color;
                indicator.textContent = color;
                indicator.style.color = 'white';
                indicator.style.textShadow = '0 1px 2px rgba(0,0,0,0.5)';
            }
            
            updateApplyButton();
            
            // Show feedback that color was selected
            showToast(`‚úì Palette colour selected - now select parts (‚úì)`);
            
            console.log('Selected palette color set to:', selectedColor);
            console.log('Selected parts count:', selectedParts.size);
            console.log('============================');
        }

        function addNewColor() {
            const newColorInput = document.getElementById('new-color-input');
            const newColor = newColorInput.value;
            
            console.log('Adding new color to palette:', newColor);
            
            // Check if color already exists (case insensitive)
            const colorExists = presetColors.some(c => c.toLowerCase() === newColor.toLowerCase());
            
            if (colorExists) {
                showToast('‚ö†Ô∏è Colour already in palette');
                // Flash the existing color
                const existingItem = document.querySelector(`.color-item[data-color="${newColor}"]`);
                if (existingItem) {
                    existingItem.style.transform = 'scale(1.2)';
                    existingItem.style.boxShadow = '0 0 20px ' + newColor;
                    setTimeout(() => {
                        existingItem.style.transform = '';
                        existingItem.style.boxShadow = '';
                    }, 500);
                }
                return;
            }
            
            // Add the new color
            presetColors.push(newColor);
            renderColorGrid();
            
            // Update all part preset color pickers
            parts.forEach((part, index) => {
                const presetsContainer = document.getElementById(`presets-${index}`);
                if (presetsContainer) {
                    presetsContainer.innerHTML = '';
                    presetColors.forEach(color => {
                        const preset = document.createElement('div');
                        preset.className = 'preset-color';
                        preset.style.background = color;
                        preset.onclick = () => updateColor(index, color);
                        presetsContainer.appendChild(preset);
                    });
                }
            });
            
            // Flash the new color in the palette
            setTimeout(() => {
                const newItem = document.querySelector(`.color-item[data-color="${newColor}"]`);
                if (newItem) {
                    newItem.style.transform = 'scale(1.2)';
                    newItem.style.boxShadow = '0 0 20px ' + newColor;
                    setTimeout(() => {
                        newItem.style.transform = '';
                        newItem.style.boxShadow = '';
                    }, 500);
                }
            }, 50);
            
            showToast(`‚úì Colour ${newColor} added to palette!`);
            console.log('New color added. Total colors:', presetColors.length);
        }

        function removeColor(index) {
            if (presetColors.length > 1) {
                presetColors.splice(index, 1);
                renderColorGrid();
                showToast('Colour removed from palette');
            } else {
                showToast('‚ö†Ô∏è Must keep at least one colour');
            }
        }

        function toggleColorPanel() {
            const content = document.getElementById('color-content');
            const btn = document.getElementById('color-collapse-btn');
            content.classList.toggle('collapsed');
            btn.textContent = content.classList.contains('collapsed') ? '+' : '‚àí';
        }

        function applyColorToSelected() {
            console.log('=== Apply Palette Color Debug ===');
            console.log('Selected palette color:', selectedColor);
            console.log('Selected parts:', Array.from(selectedParts));
            
            // Make absolutely sure we're using the palette selected color
            if (!selectedColor || selectedColor === '') {
                showToast('‚ö†Ô∏è Click a colour in the PALETTE first (the coloured squares)');
                console.log('ERROR: No palette color selected!');
                
                // Visual hint - flash the palette
                const palette = document.querySelector('.color-grid');
                if (palette) {
                    palette.style.border = '2px solid var(--accent-magenta)';
                    setTimeout(() => {
                        palette.style.border = '';
                    }, 1000);
                }
                return;
            }
            
            if (selectedParts.size === 0) {
                showToast('‚ö†Ô∏è Select parts first using the checkboxes (‚úì)');
                console.log('ERROR: No parts selected!');
                return;
            }
            
            // Apply the PALETTE color to all selected parts
            let successCount = 0;
            selectedParts.forEach(index => {
                console.log(`Applying palette color ${selectedColor} to part ${index}`);
                if (parts[index]) {
                    // Update the part's color
                    parts[index].material.color.set(selectedColor);
                    parts[index].userData.color = selectedColor;
                    
                    // Update the UI elements
                    const preview = document.getElementById(`preview-${index}`);
                    const hex = document.getElementById(`hex-${index}`);
                    const colorInput = document.querySelector(`#preview-${index} input`);
                    
                    if (preview) preview.style.background = selectedColor;
                    if (hex) hex.textContent = selectedColor;
                    if (colorInput) colorInput.value = selectedColor;
                    
                    successCount++;
                } else {
                    console.error(`Part ${index} not found!`);
                }
            });
            
            console.log(`Successfully applied palette color to ${successCount} parts`);
            showToast(`‚úì Applied ${selectedColor} to ${successCount} part(s)!`);
        }

        function updateApplyButton() {
            const btn = document.getElementById('apply-color-btn');
            if (!btn) {
                console.warn('Apply color button not found!');
                return;
            }
            
            const shouldEnable = selectedColor && selectedParts.size > 0;
            
            btn.disabled = !shouldEnable;
            
            // Show the actual palette color that will be applied
            if (selectedParts.size > 0 && selectedColor) {
                btn.textContent = `Apply Palette Colour to ${selectedParts.size} Part(s)`;
                btn.style.cursor = 'pointer';
                btn.style.background = `linear-gradient(135deg, ${selectedColor} 0%, ${selectedColor}88 100%)`;
                btn.style.borderColor = selectedColor;
                btn.style.color = '#ffffff';
            } else if (selectedParts.size > 0) {
                btn.textContent = 'Click a PALETTE Colour First';
                btn.style.cursor = 'not-allowed';
                btn.style.background = 'rgba(0, 255, 136, 0.1)';
                btn.style.borderColor = 'var(--accent-green)';
                btn.style.color = 'var(--accent-green)';
            } else if (selectedColor) {
                btn.textContent = 'Select Parts First (‚úì checkboxes)';
                btn.style.cursor = 'not-allowed';
                btn.style.background = 'rgba(0, 255, 136, 0.1)';
                btn.style.borderColor = 'var(--accent-green)';
                btn.style.color = 'var(--accent-green)';
            } else {
                btn.textContent = 'Select Color & Parts First';
                btn.style.cursor = 'not-allowed';
                btn.style.background = 'rgba(0, 255, 136, 0.1)';
                btn.style.borderColor = 'var(--accent-green)';
                btn.style.color = 'var(--accent-green)';
            }
            
            console.log('Apply button updated - Color:', selectedColor, 'Parts:', selectedParts.size, 'Enabled:', shouldEnable);
        }

        // Part Selection
        function togglePartSelection(index) {
            console.log('=== Toggle Part Selection ===');
            console.log('Part index:', index);
            console.log('Was selected:', selectedParts.has(index));
            
            const checkbox = document.getElementById(`checkbox-${index}`);
            const card = document.getElementById(`part-card-${index}`);
            
            if (!checkbox || !card) {
                console.error('Could not find checkbox or card for part', index);
                return;
            }
            
            if (selectedParts.has(index)) {
                selectedParts.delete(index);
                checkbox.classList.remove('checked');
                checkbox.textContent = '';
                card.classList.remove('selected');
                console.log('Deselected part', index);
            } else {
                selectedParts.add(index);
                checkbox.classList.add('checked');
                checkbox.textContent = '‚úì';
                card.classList.add('selected');
                console.log('Selected part', index);
            }
            
            console.log('Total selected parts:', selectedParts.size);
            console.log('Selected parts array:', Array.from(selectedParts));
            
            updateSelectionInfo();
            updateApplyButton();
            console.log('============================');
        }

        function updateSelectionInfo() {
            const info = document.getElementById('selection-info');
            if (selectedParts.size > 0) {
                info.textContent = `(${selectedParts.size} selected)`;
            } else {
                info.textContent = '';
            }
        }

        // Part Locking
        function toggleLock(index) {
            if (!parts[index]) return;
            
            parts[index].userData.locked = !parts[index].userData.locked;
            const btn = document.getElementById(`lock-btn-${index}`);
            const card = document.getElementById(`part-card-${index}`);
            const transformDiv = document.getElementById(`transform-${index}`);
            
            if (parts[index].userData.locked) {
                btn.classList.add('locked');
                btn.textContent = 'üîí';
                card.classList.add('locked');
                if (transformDiv && transformDiv.classList.contains('show')) {
                    transformDiv.classList.add('disabled');
                }
            } else {
                btn.classList.remove('locked');
                btn.textContent = 'üîì';
                card.classList.remove('locked');
                if (transformDiv) {
                    transformDiv.classList.remove('disabled');
                }
            }
        }

        function setupFileUpload() {
            const fileInput = document.getElementById('file-input');
            const uploadZone = document.getElementById('upload-zone');
            
            fileInput.addEventListener('change', (e) => {
                handleFiles(e.target.files);
            });
            
            uploadZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadZone.classList.add('drag-over');
            });
            
            uploadZone.addEventListener('dragleave', () => {
                uploadZone.classList.remove('drag-over');
            });
            
            uploadZone.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadZone.classList.remove('drag-over');
                handleFiles(e.dataTransfer.files);
            });
        }

        async function handleFiles(files) {
            for (const file of files) {
                if (file.name.toLowerCase().endsWith('.stlproject')) {
                    // It's a project file - load it
                    const zip = await JSZip.loadAsync(file);
                    const projectJsonFile = zip.file("project.json");
                    if (projectJsonFile) {
                        const projectData = JSON.parse(await projectJsonFile.async("text"));
                        
                        clearAllSilent();
                        document.getElementById('project-name').value = projectData.projectName;
                        updateProjectDisplay();
                        
                        if (projectData.colors) {
                            presetColors = projectData.colors;
                            renderColorGrid();
                        }
                        
                        const stlFolder = zip.folder("stl_files");
                        for (const partData of projectData.parts) {
                            const stlFile = stlFolder.file(partData.fileName);
                            if (stlFile) {
                                const arrayBuffer = await stlFile.async("arraybuffer");
                                await loadSTLFromBuffer(arrayBuffer, partData);
                            }
                        }
                        
                        frameModel();
                        showToast(`üìÇ Project "${projectData.projectName}" loaded!`);
                    }
                } else if (file.name.toLowerCase().endsWith('.stl')) {
                    loadSTL(file);
                } else {
                    showToast('‚ö†Ô∏è Please upload .stl or .stlproject files');
                }
            }
        }

        function loadSTL(file) {
            console.log('Loading STL file:', file.name);
            
            try {
                const reader = new FileReader();
                
                reader.onerror = (error) => {
                    console.error('File read error:', error);
                    showToast('‚ùå Error reading file: ' + file.name);
                };
                
                reader.onload = (e) => {
                    try {
                        console.log('File loaded, parsing geometry...');
                        const geometry = loader.parse(e.target.result);
                        console.log('Geometry parsed successfully');
                        
                        const randomColor = presetColors[Math.floor(Math.random() * presetColors.length)];
                        
                        const material = new THREE.MeshStandardMaterial({
                            color: randomColor,
                            metalness: 0.3,
                            roughness: 0.4,
                            flatShading: false
                        });
                        
                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.userData = {
                            name: file.name.replace('.stl', ''),
                            visible: true,
                            color: randomColor,
                            position: { x: 0, y: 0, z: 0 },
                            rotation: { x: 0, y: 0, z: 0 },
                            locked: false
                        };
                        
                        console.log('Adding mesh to scene...');
                        modelGroup.add(mesh);
                        parts.push(mesh);
                        
                        console.log('Creating UI controls...');
                        addPartControl(parts.length - 1);
                        updatePartCount();
                        updateBoundingBox();
                        updateCoordinates(parts.length - 1);
                        
                        if (parts.length === 1) {
                            frameModel();
                        }
                        
                        showToast(`‚úì Loaded: ${file.name}`);
                        console.log('STL loaded successfully:', file.name);
                    } catch (error) {
                        console.error('Error processing STL:', error);
                        showToast('‚ùå Error loading: ' + file.name);
                    }
                };
                
                console.log('Starting file read...');
                reader.readAsArrayBuffer(file);
            } catch (error) {
                console.error('Error in loadSTL:', error);
                showToast('‚ùå Failed to load: ' + file.name);
            }
        }

        function addPartControl(index) {
            try {
                console.log('Adding part control for index:', index);
                const container = document.getElementById('parts-container');
                
                if (!container) {
                    console.error('Parts container not found!');
                    return;
                }
                
                if (parts.length === 1) {
                    container.innerHTML = '';
                }
                
                if (!parts[index]) {
                    console.error('Part not found at index:', index);
                    return;
                }
                
                const part = parts[index];
                const card = document.createElement('div');
                card.className = 'part-card';
                card.style.animationDelay = `${index * 0.1}s`;
                card.id = `part-card-${index}`;
                
                card.innerHTML = `
                <div class="part-header">
                    <div class="part-name-section">
                        <div class="select-checkbox" id="checkbox-${index}" onclick="togglePartSelection(${index})" title="Select for multi-color"></div>
                        <div class="part-name">${part.userData.name}</div>
                    </div>
                    <div class="part-actions">
                        <button class="collapse-btn" onclick="togglePartCollapse(${index})" id="part-collapse-${index}">‚àí</button>
                        <button class="icon-btn lock-btn" onclick="toggleLock(${index})" title="Lock/Unlock" id="lock-btn-${index}">
                            üîì
                        </button>
                        <button class="icon-btn visibility" onclick="toggleVisibility(${index})" title="Toggle visibility" id="vis-btn-${index}">
                            üëÅ
                        </button>
                        <button class="icon-btn" onclick="toggleTransform(${index})" title="Transform controls" id="transform-btn-${index}">‚öô</button>
                        <button class="icon-btn danger" onclick="removePart(${index})" title="Remove part">√ó</button>
                    </div>
                </div>
                
                <div class="part-content">
                    <div class="coordinate-display">
                        <div class="coord-title">Current Position</div>
                        <div class="coord-values">
                            <div class="coord-item">
                                <div class="coord-label">X</div>
                                <div class="coord-value" id="coord-x-${index}">0.0</div>
                            </div>
                            <div class="coord-item">
                                <div class="coord-label">Y</div>
                                <div class="coord-value" id="coord-y-${index}">0.0</div>
                            </div>
                            <div class="coord-item">
                                <div class="coord-label">Z</div>
                                <div class="coord-value" id="coord-z-${index}">0.0</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="color-picker-container">
                        <div class="color-input-wrapper">
                            <div class="color-preview" style="background: ${part.userData.color};" id="preview-${index}">
                                <input type="color" value="${part.userData.color}" onchange="updateColor(${index}, this.value)">
                            </div>
                            <div class="color-hex" id="hex-${index}">${part.userData.color}</div>
                        </div>
                    </div>
                    <div class="preset-colors" id="presets-${index}"></div>
                    
                    <div class="transform-controls" id="transform-${index}">
                        <div class="transform-section">
                            <div class="transform-label">Position (mm)</div>
                            <div class="transform-sliders">
                                ${['x', 'y', 'z'].map(axis => `
                                <div class="slider-row">
                                    <span class="slider-label">${axis.toUpperCase()}</span>
                                    <div class="slider-container">
                                        <input type="range" min="-500" max="500" value="0" step="0.1" 
                                               oninput="updateTransform(${index}, 'position', '${axis}', this.value)" id="pos-${axis}-${index}">
                                        <div class="input-controls">
                                            <button class="arrow-btn" onclick="adjustValue(${index}, 'position', '${axis}', -1)">‚àí</button>
                                            <input type="number" class="number-input" value="0" step="0.1"
                                                   onchange="setTransformDirect(${index}, 'position', '${axis}', this.value)" id="input-pos-${axis}-${index}">
                                            <button class="arrow-btn" onclick="adjustValue(${index}, 'position', '${axis}', 1)">+</button>
                                        </div>
                                    </div>
                                </div>
                                `).join('')}
                            </div>
                        </div>
                        
                        <div class="transform-section">
                            <div class="transform-label">Rotation (degrees)</div>
                            <div class="transform-sliders">
                                ${['x', 'y', 'z'].map(axis => `
                                <div class="slider-row">
                                    <span class="slider-label rotation">${axis.toUpperCase()}</span>
                                    <div class="slider-container">
                                        <input type="range" class="rotation" min="-180" max="180" value="0" step="1" 
                                               oninput="updateTransform(${index}, 'rotation', '${axis}', this.value)" id="rot-${axis}-${index}">
                                        <div class="input-controls">
                                            <button class="arrow-btn" onclick="adjustValue(${index}, 'rotation', '${axis}', -5)">‚àí</button>
                                            <input type="number" class="number-input" value="0" step="1"
                                                   onchange="setTransformDirect(${index}, 'rotation', '${axis}', this.value)" id="input-rot-${axis}-${index}">
                                            <button class="arrow-btn" onclick="adjustValue(${index}, 'rotation', '${axis}', 5)">+</button>
                                        </div>
                                    </div>
                                </div>
                                `).join('')}
                            </div>
                        </div>
                        
                        <button class="transform-reset" onclick="resetTransform(${index})">Reset Transform</button>
                    </div>
                </div>
            `;
            
            container.appendChild(card);
            
            const presetsContainer = document.getElementById(`presets-${index}`);
            presetColors.forEach(color => {
                const preset = document.createElement('div');
                preset.className = 'preset-color';
                preset.style.background = color;
                preset.onclick = () => updateColor(index, color);
                presetsContainer.appendChild(preset);
            });
            
            console.log('Part control added successfully for index:', index);
            } catch (error) {
                console.error('Error in addPartControl:', error);
                showToast('‚ùå Error creating part controls');
            }
        }

        function toggleTransform(index) {
            if (parts[index] && parts[index].userData.locked) {
                showToast('‚ö†Ô∏è Part is locked. Unlock to edit.');
                return;
            }
            
            const transformDiv = document.getElementById(`transform-${index}`);
            const btn = document.getElementById(`transform-btn-${index}`);
            const card = document.getElementById(`part-card-${index}`);
            
            transformDiv.classList.toggle('show');
            btn.classList.toggle('active');
            card.classList.toggle('expanded');
        }

        function updateColor(index, color) {
            if (parts[index]) {
                parts[index].material.color.set(color);
                parts[index].userData.color = color;
                document.getElementById(`preview-${index}`).style.background = color;
                document.getElementById(`hex-${index}`).textContent = color;
            }
        }

        function updateTransform(index, type, axis, value) {
            if (!parts[index] || parts[index].userData.locked) return;
            
            const val = parseFloat(value);
            
            if (type === 'position') {
                parts[index].position[axis] = val;
                parts[index].userData.position[axis] = val;
                document.getElementById(`input-pos-${axis}-${index}`).value = val.toFixed(1);
                updateCoordinates(index);
            } else if (type === 'rotation') {
                const radians = val * (Math.PI / 180);
                parts[index].rotation[axis] = radians;
                parts[index].userData.rotation[axis] = val;
                document.getElementById(`input-rot-${axis}-${index}`).value = val.toFixed(0);
            }
            
            updateBoundingBox();
        }

        function setTransformDirect(index, type, axis, value) {
            if (!parts[index] || parts[index].userData.locked) return;
            
            const val = parseFloat(value);
            
            if (type === 'position') {
                const clamped = Math.max(-500, Math.min(500, val));
                parts[index].position[axis] = clamped;
                parts[index].userData.position[axis] = clamped;
                document.getElementById(`pos-${axis}-${index}`).value = clamped;
                document.getElementById(`input-pos-${axis}-${index}`).value = clamped.toFixed(1);
                updateCoordinates(index);
            } else if (type === 'rotation') {
                const clamped = Math.max(-180, Math.min(180, val));
                const radians = clamped * (Math.PI / 180);
                parts[index].rotation[axis] = radians;
                parts[index].userData.rotation[axis] = clamped;
                document.getElementById(`rot-${axis}-${index}`).value = clamped;
                document.getElementById(`input-rot-${axis}-${index}`).value = clamped.toFixed(0);
            }
            
            updateBoundingBox();
        }

        function adjustValue(index, type, axis, delta) {
            if (!parts[index] || parts[index].userData.locked) return;
            
            if (type === 'position') {
                const current = parts[index].position[axis];
                const newVal = Math.max(-500, Math.min(500, current + delta));
                setTransformDirect(index, type, axis, newVal);
            } else if (type === 'rotation') {
                const current = parts[index].userData.rotation[axis];
                const newVal = Math.max(-180, Math.min(180, current + delta));
                setTransformDirect(index, type, axis, newVal);
            }
        }

        function updateCoordinates(index) {
            if (!parts[index]) return;
            
            const pos = parts[index].position;
            document.getElementById(`coord-x-${index}`).textContent = pos.x.toFixed(1);
            document.getElementById(`coord-y-${index}`).textContent = pos.y.toFixed(1);
            document.getElementById(`coord-z-${index}`).textContent = pos.z.toFixed(1);
        }

        function resetTransform(index) {
            if (parts[index] && !parts[index].userData.locked) {
                parts[index].position.set(0, 0, 0);
                parts[index].rotation.set(0, 0, 0);
                parts[index].userData.position = { x: 0, y: 0, z: 0 };
                parts[index].userData.rotation = { x: 0, y: 0, z: 0 };
                
                ['x', 'y', 'z'].forEach(axis => {
                    document.getElementById(`pos-${axis}-${index}`).value = 0;
                    document.getElementById(`input-pos-${axis}-${index}`).value = 0;
                    document.getElementById(`rot-${axis}-${index}`).value = 0;
                    document.getElementById(`input-rot-${axis}-${index}`).value = 0;
                });
                
                updateCoordinates(index);
                updateBoundingBox();
                showToast('Transform reset');
            }
        }

        function toggleVisibility(index) {
            if (parts[index]) {
                parts[index].visible = !parts[index].visible;
                parts[index].userData.visible = parts[index].visible;
                
                const btn = document.getElementById(`vis-btn-${index}`);
                const card = document.getElementById(`part-card-${index}`);
                
                if (parts[index].visible) {
                    btn.classList.remove('hidden-btn');
                    btn.classList.add('visibility');
                    btn.textContent = 'üëÅ';
                    card.classList.remove('hidden-part');
                } else {
                    btn.classList.add('hidden-btn');
                    btn.classList.remove('visibility');
                    btn.textContent = '‚®Ø';
                    card.classList.add('hidden-part');
                }
                
                updateBoundingBox();
            }
        }

        function removePart(index) {
            if (parts[index]) {
                modelGroup.remove(parts[index]);
                parts[index].geometry.dispose();
                parts[index].material.dispose();
                parts.splice(index, 1);
                
                // Update selected parts indices
                selectedParts.delete(index);
                const newSelected = new Set();
                selectedParts.forEach(i => {
                    if (i > index) newSelected.add(i - 1);
                    else if (i < index) newSelected.add(i);
                });
                selectedParts = newSelected;
                
                rebuildUI();
                updatePartCount();
                updateBoundingBox();
                showToast('Part removed');
            }
        }

        function rebuildUI() {
            const container = document.getElementById('parts-container');
            container.innerHTML = '';
            
            if (parts.length === 0) {
                container.innerHTML = '<div class="empty-state">No parts loaded yet.<br>Upload STL files or load a project.</div>';
            } else {
                parts.forEach((part, index) => {
                    addPartControl(index);
                    
                    const colorInput = document.querySelector(`#preview-${index} input`);
                    if (colorInput) colorInput.value = part.userData.color;
                    
                    ['x', 'y', 'z'].forEach(axis => {
                        const posSlider = document.getElementById(`pos-${axis}-${index}`);
                        const posInput = document.getElementById(`input-pos-${axis}-${index}`);
                        const rotSlider = document.getElementById(`rot-${axis}-${index}`);
                        const rotInput = document.getElementById(`input-rot-${axis}-${index}`);
                        
                        if (posSlider && posInput) {
                            posSlider.value = part.userData.position[axis];
                            posInput.value = part.userData.position[axis].toFixed(1);
                        }
                        if (rotSlider && rotInput) {
                            rotSlider.value = part.userData.rotation[axis];
                            rotInput.value = part.userData.rotation[axis].toFixed(0);
                        }
                    });
                    
                    updateCoordinates(index);
                    
                    if (!part.visible) {
                        const btn = document.getElementById(`vis-btn-${index}`);
                        const card = document.getElementById(`part-card-${index}`);
                        btn.classList.add('hidden-btn');
                        btn.classList.remove('visibility');
                        btn.textContent = '‚®Ø';
                        card.classList.add('hidden-part');
                    }
                    
                    if (part.userData.locked) {
                        const btn = document.getElementById(`lock-btn-${index}`);
                        const card = document.getElementById(`part-card-${index}`);
                        btn.classList.add('locked');
                        btn.textContent = 'üîí';
                        card.classList.add('locked');
                    }
                    
                    // Restore selection state
                    if (selectedParts.has(index)) {
                        const checkbox = document.getElementById(`checkbox-${index}`);
                        const card = document.getElementById(`part-card-${index}`);
                        if (checkbox) {
                            checkbox.classList.add('checked');
                            checkbox.textContent = '‚úì';
                        }
                        if (card) {
                            card.classList.add('selected');
                        }
                    }
                });
            }
        }

        function randomizeColors() {
            parts.forEach((part, index) => {
                const randomColor = presetColors[Math.floor(Math.random() * presetColors.length)];
                updateColor(index, randomColor);
                const colorInput = document.querySelector(`#preview-${index} input`);
                if (colorInput) colorInput.value = randomColor;
            });
            showToast('üé® Colours randomized!');
        }

        function clearAll() {
            console.log('=== clearAll() called ===');
            console.log('Parts count:', parts.length);
            console.log('Groups count:', groups.length);
            
            const message = parts.length > 0 
                ? `Start a new project? This will clear all ${parts.length} part(s) and ${groups.length} group(s).\n\nMake sure you've saved your current project!`
                : 'Start a new project?';
            
            console.log('Showing confirm dialog...');
            const userConfirmed = confirm(message);
            console.log('User confirmed:', userConfirmed);
            
            if (userConfirmed) {
                console.log('Clearing all...');
                clearAllSilent();
                showToast('‚úì New project started');
                console.log('Clear complete');
            } else {
                console.log('User cancelled');
            }
        }

        function frameModel() {
            if (parts.length === 0) return;
            
            const box = new THREE.Box3();
            parts.forEach(part => {
                if (part.visible) {
                    box.expandByObject(part);
                }
            });
            
            const center = new THREE.Vector3();
            box.getCenter(center);
            
            const size = new THREE.Vector3();
            box.getSize(size);
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
            cameraZ *= 2;
            
            camera.position.set(center.x + cameraZ * 0.5, center.y + cameraZ * 0.5, center.z + cameraZ);
            camera.lookAt(center);
        }

        function resetCamera() {
            camera.position.set(0, 50, 150);
            camera.lookAt(0, 0, 0);
            modelGroup.rotation.set(0, 0, 0);
        }

        function updatePartCount() {
            document.getElementById('part-count').textContent = parts.length;
        }

        function updateBoundingBox() {
            if (parts.length === 0) {
                document.getElementById('bounding-box-info').innerHTML = '';
                return;
            }
            
            const box = new THREE.Box3();
            parts.forEach(part => {
                if (part.visible) {
                    box.expandByObject(part);
                }
            });
            
            const size = new THREE.Vector3();
            box.getSize(size);
            
            const info = `
                <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(0, 245, 255, 0.15);">
                    <div style="color: var(--accent-yellow); margin-bottom: 4px;">Bounding Box:</div>
                    <div>X: ${size.x.toFixed(2)} mm</div>
                    <div>Y: ${size.y.toFixed(2)} mm</div>
                    <div>Z: ${size.z.toFixed(2)} mm</div>
                </div>
            `;
            
            document.getElementById('bounding-box-info').innerHTML = info;
        }

        // Export Assembly as STL
        function exportAssembly() {
            if (parts.length === 0) {
                showToast('‚ö†Ô∏è No parts to export');
                return;
            }
            
            const visibleParts = parts.filter(p => p.visible);
            if (visibleParts.length === 0) {
                showToast('‚ö†Ô∏è No visible parts to export');
                return;
            }
            
            const exportGroup = new THREE.Group();
            visibleParts.forEach(part => {
                const clonedGeometry = part.geometry.clone();
                clonedGeometry.applyMatrix4(part.matrixWorld);
                const mesh = new THREE.Mesh(clonedGeometry);
                exportGroup.add(mesh);
            });
            
            const result = exporter.parse(exportGroup, { binary: true });
            const blob = new Blob([result], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            const projectName = document.getElementById('project-name').value.replace(/[^a-z0-9]/gi, '_');
            link.download = `${projectName}_assembly.stl`;
            link.click();
            URL.revokeObjectURL(url);
            
            exportGroup.children.forEach(child => {
                child.geometry.dispose();
            });
            
            showToast('üì• Assembly STL exported!');
        }

        function toggleMeasure() {
            measureMode = !measureMode;
            const btn = document.getElementById('measure-btn');
            const overlay = document.getElementById('measurement-overlay');
            
            if (measureMode) {
                btn.classList.add('active');
                overlay.classList.add('active');
                measurePoints = [];
                showToast('üìè Measurement mode active');
            } else {
                btn.classList.remove('active');
                overlay.classList.remove('active');
                clearMeasurementVisuals();
            }
        }

        function clearMeasurementVisuals() {
            document.querySelectorAll('.measurement-line, .measurement-point').forEach(el => el.remove());
        }

        function exportImage() {
            renderer.render(scene, camera);
            const imgData = renderer.domElement.toDataURL('image/png');
            const link = document.createElement('a');
            link.href = imgData;
            const projectName = document.getElementById('project-name').value.replace(/[^a-z0-9]/gi, '_');
            link.download = `${projectName}_preview.png`;
            link.click();
            showToast('üì∏ Image exported!');
        }

        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let isPanning = false;

        function setupControls() {
            const canvas = renderer.domElement;
            
            canvas.addEventListener('mousedown', (e) => {
                if (measureMode) {
                    handleMeasureClick(e);
                    return;
                }
                
                if (e.button === 0) {
                    isDragging = true;
                } else if (e.button === 2) {
                    isPanning = true;
                }
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            canvas.addEventListener('mousemove', (e) => {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                
                if (isDragging) {
                    modelGroup.rotation.y += deltaX * 0.01;
                    modelGroup.rotation.x += deltaY * 0.01;
                } else if (isPanning) {
                    camera.position.x -= deltaX * 0.1;
                    camera.position.y += deltaY * 0.1;
                }
                
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
                isPanning = false;
            });
            
            canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });
            
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                camera.position.z += e.deltaY * 0.1;
                camera.position.z = Math.max(10, Math.min(500, camera.position.z));
            });
        }

        function handleMeasureClick(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(parts);
            
            if (intersects.length > 0) {
                const point = intersects[0].point;
                measurePoints.push(point);
                
                const marker = document.createElement('div');
                marker.className = 'measurement-point';
                marker.style.left = event.clientX + 'px';
                marker.style.top = event.clientY + 'px';
                document.body.appendChild(marker);
                
                if (measurePoints.length === 2) {
                    const distance = measurePoints[0].distanceTo(measurePoints[1]);
                    document.getElementById('measurement-value').textContent = distance.toFixed(2) + ' mm';
                    
                    const line = document.createElement('div');
                    line.className = 'measurement-line';
                    const dx = event.clientX - (parseFloat(document.querySelectorAll('.measurement-point')[0].style.left));
                    const dy = event.clientY - (parseFloat(document.querySelectorAll('.measurement-point')[0].style.top));
                    const length = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                    
                    line.style.width = length + 'px';
                    line.style.left = document.querySelectorAll('.measurement-point')[0].style.left;
                    line.style.top = document.querySelectorAll('.measurement-point')[0].style.top;
                    line.style.transform = `rotate(${angle}deg)`;
                    document.body.appendChild(line);
                    
                    showToast(`Distance: ${distance.toFixed(2)} mm`);
                    
                    setTimeout(() => {
                        clearMeasurementVisuals();
                        measurePoints = [];
                        document.getElementById('measurement-value').textContent = '--';
                    }, 5000);
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        window.addEventListener('load', init);
    </script>
</body>
</html>
