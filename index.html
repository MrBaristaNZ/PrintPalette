<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Print Palette - 3D Print Colour Preview Studio</title>
    <script async src="https://unpkg.com/es-module-shims@1.10.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
        }
    }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@300;500;700&family=Azeret+Mono:wght@400;600&display=swap');

        :root {
            --bg-primary: #0a0e17;
            --bg-secondary: #141922;
            --bg-tertiary: #1e2530;
            --accent-cyan: #00f5ff;
            --accent-magenta: #ff006b;
            --accent-yellow: #ffd700;
            --accent-green: #00ff88;
            --accent-orange: #ff6b35;
            --accent-purple: #a855f7;
            --text-primary: #e8edf4;
            --text-secondary: #8b95a8;
            --border: rgba(0, 245, 255, 0.15);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
        }

        .container {
            display: grid;
            grid-template-columns: 400px 1fr;
            height: 100vh;
            gap: 0;
        }

        /* Sidebar */
        .sidebar {
            background: var(--bg-secondary);
            border-right: 2px solid var(--border);
            padding: 24px;
            overflow-y: auto;
            position: relative;
        }

        .sidebar::before {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 1px;
            height: 100%;
            background: linear-gradient(180deg, 
                transparent 0%, 
                var(--accent-cyan) 30%, 
                var(--accent-cyan) 70%, 
                transparent 100%);
            opacity: 0.3;
        }

        .logo {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 8px;
            letter-spacing: -0.5px;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-magenta));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-family: 'Azeret Mono', monospace;
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 24px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .project-name-section {
            margin-bottom: 24px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px;
        }

        .project-label {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 8px;
            font-family: 'Azeret Mono', monospace;
            text-transform: uppercase;
        }

        .project-name-input {
            width: 100%;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 10px 12px;
            border-radius: 6px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 16px;
            font-weight: 600;
        }

        .project-name-input:focus {
            outline: none;
            border-color: var(--accent-cyan);
        }

        /* Upload Section */
        .upload-section {
            margin-bottom: 24px;
        }

        .upload-zone {
            border: 2px dashed var(--border);
            border-radius: 8px;
            padding: 32px 16px;
            text-align: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .upload-zone::before {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at center, rgba(0, 245, 255, 0.1) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .upload-zone:hover::before {
            opacity: 1;
        }

        .upload-zone:hover {
            border-color: var(--accent-cyan);
            background: rgba(0, 245, 255, 0.05);
        }

        .upload-zone.drag-over {
            border-color: var(--accent-magenta);
            background: rgba(255, 0, 107, 0.1);
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: 12px;
            opacity: 0.6;
        }

        .upload-text {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .upload-hint {
            font-family: 'Azeret Mono', monospace;
            font-size: 10px;
            color: var(--text-secondary);
            opacity: 0.6;
        }

        #file-input {
            display: none;
        }

        .action-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 12px;
        }

        .action-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 0.5px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
        }

        .action-btn:hover {
            background: rgba(0, 245, 255, 0.1);
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        .action-btn.secondary {
            background: transparent;
        }

        .action-btn.project {
            background: rgba(168, 85, 247, 0.1);
            border-color: var(--accent-purple);
            color: var(--accent-purple);
            grid-column: 1 / -1;
        }

        .action-btn.project:hover {
            background: rgba(168, 85, 247, 0.2);
        }

        .action-btn.export-stl {
            background: rgba(255, 215, 0, 0.1);
            border-color: var(--accent-yellow);
            color: var(--accent-yellow);
        }

        .action-btn.export-stl:hover {
            background: rgba(255, 215, 0, 0.2);
        }

        .action-btn.arrangement {
            background: rgba(0, 255, 136, 0.1);
            border-color: var(--accent-green);
            color: var(--accent-green);
            font-size: 11px;
        }

        .action-btn.arrangement:hover {
            background: rgba(0, 255, 136, 0.2);
        }

        /* Group Management */
        .group-management {
            margin-bottom: 24px;
        }

        #group-color-dropdown {
            transition: all 0.2s;
            color: white;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }

        #group-color-dropdown:hover {
            border-color: var(--accent-cyan);
            transform: scale(1.02);
        }

        #group-color-dropdown option {
            padding: 8px;
            font-weight: 600;
        }

        .apply-multi-btn {
            flex: 1;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid var(--accent-green);
            color: var(--accent-green);
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        .apply-multi-btn:hover:not(:disabled) {
            background: rgba(0, 255, 136, 0.2);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 255, 136, 0.3);
        }

        .apply-multi-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* Color Management */
        .color-management {
            margin-bottom: 24px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px;
        }

        .color-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            user-select: none;
        }

        .color-title {
            font-size: 13px;
            font-weight: 600;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .collapse-btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-size: 12px;
        }

        .collapse-btn:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        .color-content {
            max-height: 500px;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .color-content.collapsed {
            max-height: 0;
        }

        .color-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            margin-bottom: 12px;
        }

        .color-item {
            position: relative;
            aspect-ratio: 1;
            border-radius: 6px;
            border: 2px solid var(--border);
            cursor: pointer;
            transition: all 0.2s;
        }

        .color-item:hover {
            border-color: var(--accent-cyan);
            transform: scale(1.05);
        }

        .color-item.selected {
            border-color: var(--accent-green);
            border-width: 3px;
            box-shadow: 0 0 0 3px rgba(0, 255, 136, 0.3), 0 0 20px rgba(0, 255, 136, 0.5);
            transform: scale(1.1);
        }
        
        .color-item.selected::after {
            content: '‚úì';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.8), 0 0 8px rgba(0, 0, 0, 0.5);
            pointer-events: none;
        }

        .color-remove {
            position: absolute;
            top: -6px;
            right: -6px;
            background: var(--accent-magenta);
            border: 2px solid var(--bg-tertiary);
            color: white;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            z-index: 10;
        }

        .color-item:hover .color-remove {
            display: flex;
        }

        .color-add-section {
            display: flex;
            gap: 12px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border);
            align-items: flex-start;
        }

        .color-input-new {
            flex: 1;
            height: 36px;
            border-radius: 6px;
            border: 2px solid var(--border);
            cursor: pointer;
        }

        .add-color-btn {
            background: rgba(255, 0, 107, 0.1);
            border: 1px solid var(--accent-magenta);
            color: var(--accent-magenta);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-size: 11px;
            font-weight: 600;
            transition: all 0.2s;
            white-space: nowrap;
            align-self: flex-end;
            margin-top: 18px;
        }

        .add-color-btn:hover {
            background: rgba(255, 0, 107, 0.2);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(255, 0, 107, 0.3);
            border-color: var(--accent-magenta);
        }

        .group-color-section {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border);
        }

        .group-label {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 8px;
            font-family: 'Azeret Mono', monospace;
        }

        .apply-to-selected-btn {
            width: 100%;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid var(--accent-green);
            color: var(--accent-green);
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        .apply-to-selected-btn:hover {
            background: rgba(0, 255, 136, 0.2);
        }

        .apply-to-selected-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Parts Section - keeping styles minimal for brevity */
        .section-header {
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .section-header-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .section-header-left::before {
            content: '';
            width: 3px;
            height: 12px;
            background: var(--accent-cyan);
            border-radius: 2px;
        }

        .section-actions {
            display: flex;
            gap: 8px;
        }

        .section-btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-size: 10px;
            font-weight: 600;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        .section-btn:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        .selection-info {
            font-size: 11px;
            color: var(--accent-green);
            font-weight: 600;
        }

        .part-section {
            margin-bottom: 24px;
            position: relative;
        }
        
        .part-section-sticky-header {
            position: sticky;
            top: 0;
            background: var(--bg-secondary);
            z-index: 10;
            padding-bottom: 8px;
            border-bottom: 2px solid var(--border);
            transition: all 0.3s ease;
        }
        
        /* Floating/elevated state when scrolled */
        .part-section-sticky-header.is-floating {
            background: rgba(15, 20, 30, 0.98);
            border-bottom: 2px solid rgba(0, 245, 255, 0.3);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4), 0 0 24px rgba(0, 245, 255, 0.1);
        }
        
        #parts-container {
            padding-top: 12px;
        }
        
        .parts-back-to-top {
            position: sticky;
            bottom: 16px;
            left: calc(100% - 80px);
            width: fit-content;
            margin-left: auto;
            margin-top: -40px;
            z-index: 9;
        }
        
        .parts-back-to-top button {
            background: rgba(138, 85, 247, 0.9);
            border: 1px solid var(--accent-purple);
            color: white;
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-size: 12px;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            transition: all 0.2s ease;
        }
        
        .parts-back-to-top button:hover {
            background: rgba(138, 85, 247, 1);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(138, 85, 247, 0.5);
        }
        
        .parts-back-to-top button:active {
            transform: translateY(0);
        }
        }

        .empty-state {
            text-align: center;
            padding: 32px 16px;
            color: var(--text-secondary);
            font-size: 13px;
            opacity: 0.6;
        }

        .part-card {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .part-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 3px;
            height: 100%;
            background: var(--accent-cyan);
            transform: scaleY(0);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .part-card:hover {
            border-color: var(--accent-cyan);
            box-shadow: 0 4px 20px rgba(0, 245, 255, 0.1);
        }

        .part-card:hover::before {
            transform: scaleY(1);
        }

        .part-card.expanded {
            border-color: var(--accent-cyan);
        }

        .part-card.hidden-part {
            opacity: 0.5;
        }

        .part-card.selected {
            border-color: var(--accent-green);
            background: rgba(0, 255, 136, 0.05);
        }

        .part-card.locked {
            border-color: var(--accent-orange);
            background: rgba(255, 107, 53, 0.05);
        }

        .part-card.minimized .part-content {
            max-height: 0;
            opacity: 0;
            margin-top: 0;
        }

        .part-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .part-name-section {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
        }

        .select-checkbox {
            width: 24px;
            height: 24px;
            border: 2px solid var(--border);
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-size: 14px;
            font-weight: bold;
            background: var(--bg-primary);
            flex-shrink: 0;
        }

        .select-checkbox:hover {
            border-color: var(--accent-green);
            background: rgba(0, 255, 136, 0.1);
        }

        .select-checkbox.checked {
            background: var(--accent-green);
            border-color: var(--accent-green);
            color: var(--bg-primary);
        }

        .part-name {
            font-size: 15px;
            font-weight: 600;
            letter-spacing: 0.3px;
        }

        .part-actions {
            display: flex;
            gap: 8px;
        }

        .icon-btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            width: 32px;
            height: 32px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-size: 14px;
            font-weight: 600;
        }

        .icon-btn:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        .icon-btn.danger:hover {
            border-color: var(--accent-magenta);
            color: var(--accent-magenta);
        }

        .icon-btn.active {
            background: rgba(0, 245, 255, 0.1);
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        .icon-btn.visibility {
            background: rgba(0, 255, 136, 0.1);
            border-color: var(--accent-green);
            color: var(--accent-green);
        }

        .icon-btn.visibility.hidden-btn {
            background: rgba(255, 0, 107, 0.1);
            border-color: var(--accent-magenta);
            color: var(--accent-magenta);
        }

        .icon-btn.lock-btn {
            background: rgba(255, 107, 53, 0.1);
            border-color: var(--accent-orange);
            color: var(--accent-orange);
        }

        .icon-btn.lock-btn.locked {
            background: rgba(255, 107, 53, 0.2);
        }

        .part-content {
            max-height: 2000px;
            opacity: 1;
            overflow: hidden;
            transition: all 0.3s ease;
            margin-top: 12px;
        }

        /* Coordinate Display */
        .coordinate-display {
            background: rgba(0, 245, 255, 0.05);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 12px;
            font-family: 'Azeret Mono', monospace;
            font-size: 11px;
        }

        .coord-title {
            color: var(--accent-cyan);
            font-weight: 600;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .coord-values {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .coord-item {
            text-align: center;
        }

        .coord-label {
            color: var(--text-secondary);
            font-size: 9px;
            margin-bottom: 2px;
        }

        .coord-value {
            color: var(--text-primary);
            font-weight: 600;
        }

        .color-picker-container {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .color-input-wrapper {
            position: relative;
            flex: 1;
        }

        .color-preview {
            width: 100%;
            height: 40px;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid var(--border);
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }

        .color-preview::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, transparent 0%, rgba(255, 255, 255, 0.1) 100%);
            pointer-events: none;
        }

        .color-preview:hover {
            border-color: var(--accent-cyan);
            transform: scale(1.02);
        }

        input[type="color"] {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .color-hex {
            font-family: 'Azeret Mono', monospace;
            font-size: 11px;
            color: var(--text-secondary);
            text-align: center;
            margin-top: 6px;
            letter-spacing: 0.5px;
        }

        .preset-colors {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 6px;
            margin-top: 12px;
        }

        .preset-color {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .preset-color:hover {
            border-color: var(--accent-cyan);
            transform: scale(1.1);
        }

        /* Transform Controls - minimal for space */
        .transform-controls {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border);
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .transform-controls.show {
            max-height: 800px;
        }

        .transform-controls.disabled {
            pointer-events: none;
            opacity: 0.3;
        }

        .transform-section {
            margin-bottom: 16px;
        }

        .transform-label {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 8px;
            font-family: 'Azeret Mono', monospace;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .transform-label::before {
            content: '';
            width: 2px;
            height: 10px;
            background: var(--accent-cyan);
        }

        .transform-sliders {
            display: grid;
            gap: 10px;
        }

        .slider-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .slider-label {
            font-family: 'Azeret Mono', monospace;
            font-size: 11px;
            color: var(--accent-cyan);
            width: 12px;
            font-weight: 600;
        }

        .slider-label.rotation {
            color: var(--accent-magenta);
        }

        .slider-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: var(--bg-primary);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--accent-cyan);
            cursor: pointer;
        }

        input[type="range"].rotation::-webkit-slider-thumb {
            background: var(--accent-magenta);
        }

        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--accent-cyan);
            cursor: pointer;
            border: none;
        }

        input[type="range"].rotation::-moz-range-thumb {
            background: var(--accent-magenta);
        }

        .input-controls {
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .number-input {
            flex: 1;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 4px 8px;
            border-radius: 4px;
            font-family: 'Azeret Mono', monospace;
            font-size: 11px;
            text-align: center;
        }

        .number-input:focus {
            outline: none;
            border-color: var(--accent-cyan);
        }

        .arrow-btn {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-size: 12px;
            font-weight: 600;
        }

        .arrow-btn:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
            background: rgba(0, 245, 255, 0.1);
        }

        .arrow-btn:active {
            transform: scale(0.95);
        }

        .transform-reset {
            margin-top: 12px;
            width: 100%;
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        .transform-reset:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        /* Viewer */
        .viewer {
            position: relative;
            background: radial-gradient(ellipse at center, #1a2030 0%, var(--bg-primary) 100%);
        }

        #canvas-container {
            width: 100%;
            height: 100%;
        }

        .viewer-controls {
            position: absolute;
            top: 24px;
            right: 24px;
            display: flex;
            gap: 12px;
        }

        .control-btn {
            background: rgba(20, 25, 34, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 10px 18px;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-size: 13px;
            font-weight: 600;
            letter-spacing: 0.5px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
        }

        .control-btn:hover {
            background: rgba(0, 245, 255, 0.1);
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
            box-shadow: 0 4px 20px rgba(0, 245, 255, 0.2);
        }

        .control-btn.active {
            background: rgba(255, 215, 0, 0.2);
            border-color: var(--accent-yellow);
            color: var(--accent-yellow);
        }

        .info-overlay {
            position: absolute;
            bottom: 24px;
            left: 24px;
            background: rgba(20, 25, 34, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px 20px;
            font-family: 'Azeret Mono', monospace;
            font-size: 11px;
            color: var(--text-secondary);
            transition: all 0.3s ease;
        }
        
        .info-overlay.minimized {
            padding: 8px 12px;
        }
        
        .info-overlay.minimized .info-content {
            display: none;
        }
        
        .info-overlay-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid var(--border);
        }
        
        .info-overlay.minimized .info-overlay-header {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
        
        .info-overlay-title {
            color: var(--accent-cyan);
            font-weight: 600;
            text-transform: uppercase;
            font-size: 10px;
        }
        
        .info-toggle-btn {
            background: rgba(0, 245, 255, 0.1);
            border: 1px solid var(--accent-cyan);
            color: var(--accent-cyan);
            cursor: pointer;
            font-size: 14px;
            padding: 2px 8px;
            line-height: 1;
            border-radius: 4px;
            font-weight: bold;
            font-family: monospace;
            transition: all 0.2s;
        }
        
        .info-toggle-btn:hover {
            background: rgba(0, 245, 255, 0.2);
            transform: scale(1.05);
        }

        .info-overlay div {
            margin-bottom: 4px;
        }

        .info-overlay div:last-child {
            margin-bottom: 0;
        }

        .info-label {
            color: var(--accent-cyan);
            margin-right: 8px;
        }

        /* Measurement Overlay */
        .measurement-overlay {
            position: absolute;
            top: 24px;
            left: 24px;
            background: rgba(20, 25, 34, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid var(--accent-yellow);
            border-radius: 8px;
            padding: 16px 20px;
            font-family: 'Azeret Mono', monospace;
            font-size: 11px;
            color: var(--text-primary);
            display: none;
        }

        .measurement-overlay.active {
            display: block;
        }

        .measurement-title {
            color: var(--accent-yellow);
            font-weight: 600;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .measurement-value {
            font-size: 18px;
            color: var(--accent-yellow);
            margin: 8px 0;
            font-weight: 600;
        }

        .measurement-hint {
            color: var(--text-secondary);
            font-size: 10px;
            margin-top: 8px;
        }

        /* Animations */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .part-card {
            animation: fadeInUp 0.5s cubic-bezier(0.4, 0, 0.2, 1) backwards;
        }

        /* Custom Scrollbar */
        .sidebar::-webkit-scrollbar {
            width: 6px;
        }

        .sidebar::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }

        .sidebar::-webkit-scrollbar-thumb {
            background: var(--accent-cyan);
            border-radius: 3px;
        }

        .sidebar::-webkit-scrollbar-thumb:hover {
            background: var(--accent-magenta);
        }

        /* Toast Notification */
        /* Disclaimer Modal */
        .disclaimer-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: fadeIn 0.3s ease;
        }

        .disclaimer-modal.hidden {
            display: none;
        }

        .disclaimer-content {
            background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-primary) 100%);
            border: 2px solid var(--accent-cyan);
            border-radius: 12px;
            padding: 40px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 245, 255, 0.3);
            animation: slideUp 0.4s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from { 
                transform: translateY(50px);
                opacity: 0;
            }
            to { 
                transform: translateY(0);
                opacity: 1;
            }
        }

        .disclaimer-title {
            font-family: 'Rajdhani', sans-serif;
            font-size: 32px;
            font-weight: 700;
            color: var(--accent-cyan);
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .disclaimer-subtitle {
            font-family: 'Azeret Mono', monospace;
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 25px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .disclaimer-text {
            font-family: 'Rajdhani', sans-serif;
            font-size: 15px;
            line-height: 1.8;
            color: var(--text-primary);
            margin-bottom: 20px;
        }

        .disclaimer-text strong {
            color: var(--accent-cyan);
            font-weight: 600;
        }

        .disclaimer-list {
            list-style: none;
            padding: 0;
            margin: 20px 0;
        }

        .disclaimer-list li {
            padding: 8px 0 8px 25px;
            position: relative;
            color: var(--text-primary);
            font-family: 'Rajdhani', sans-serif;
            font-size: 15px;
            line-height: 1.6;
        }

        .disclaimer-list li:before {
            content: "‚Ä∫";
            position: absolute;
            left: 0;
            color: var(--accent-cyan);
            font-size: 20px;
            font-weight: 700;
        }

        .disclaimer-warning {
            background: rgba(255, 193, 7, 0.1);
            border-left: 3px solid var(--accent-yellow);
            padding: 15px 20px;
            margin: 20px 0;
            border-radius: 6px;
        }

        .disclaimer-warning-text {
            font-family: 'Azeret Mono', monospace;
            font-size: 12px;
            color: var(--accent-yellow);
            font-weight: 600;
            margin: 0;
        }

        .disclaimer-actions {
            display: flex;
            gap: 15px;
            margin-top: 30px;
        }

        .disclaimer-btn {
            flex: 1;
            padding: 15px 25px;
            border: none;
            border-radius: 8px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .disclaimer-btn.accept {
            background: var(--accent-cyan);
            color: var(--bg-primary);
        }

        .disclaimer-btn.accept:hover {
            background: rgba(0, 245, 255, 0.8);
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0, 245, 255, 0.3);
        }

        .disclaimer-btn.decline {
            background: transparent;
            color: var(--text-secondary);
            border: 1px solid var(--border);
        }

        .disclaimer-btn.decline:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
        }

        .disclaimer-content::-webkit-scrollbar {
            width: 8px;
        }

        .disclaimer-content::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }

        .disclaimer-content::-webkit-scrollbar-thumb {
            background: var(--accent-cyan);
            border-radius: 4px;
        }

        /* License Modal */
        .license-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            animation: fadeIn 0.3s ease;
        }

        .license-modal.hidden {
            display: none;
        }

        .license-content {
            background: var(--bg-secondary);
            border: 2px solid var(--accent-yellow);
            border-radius: 12px;
            padding: 30px;
            max-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(255, 193, 7, 0.3);
            animation: slideUp 0.4s ease;
        }

        .license-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--accent-yellow);
        }

        .license-title {
            font-family: 'Rajdhani', sans-serif;
            font-size: 28px;
            font-weight: 700;
            color: var(--accent-yellow);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .license-close {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 24px;
            cursor: pointer;
            padding: 5px 10px;
            transition: all 0.3s ease;
        }

        .license-close:hover {
            color: var(--accent-yellow);
            transform: rotate(90deg);
        }

        .license-body {
            font-family: 'Azeret Mono', monospace;
            font-size: 13px;
            line-height: 1.8;
            color: var(--text-primary);
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .license-footer {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid var(--border);
            text-align: center;
        }

        .license-btn {
            padding: 12px 30px;
            background: var(--accent-yellow);
            color: var(--bg-primary);
            border: none;
            border-radius: 6px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        .license-btn:hover {
            background: rgba(255, 193, 7, 0.8);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 193, 7, 0.3);
        }

        .license-content::-webkit-scrollbar {
            width: 8px;
        }

        .license-content::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }

        .license-content::-webkit-scrollbar-thumb {
            background: var(--accent-yellow);
            border-radius: 4px;
        }

        .toast {
            position: fixed;
            bottom: 24px;
            right: 24px;
            background: rgba(20, 25, 34, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid var(--accent-cyan);
            border-radius: 8px;
            padding: 16px 20px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            transform: translateY(150%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1000;
            box-shadow: 0 8px 32px rgba(0, 245, 255, 0.2);
        }

        .toast.show {
            transform: translateY(0);
        }

        /* Measurement Line */
        .measurement-line {
            position: absolute;
            height: 2px;
            background: var(--accent-yellow);
            transform-origin: 0 0;
            pointer-events: none;
            z-index: 100;
        }

        .measurement-point {
            position: absolute;
            width: 8px;
            height: 8px;
            background: var(--accent-yellow);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 101;
        }
    </style>
</head>
<body>
    <!-- Disclaimer Modal -->
    <div class="disclaimer-modal hidden" id="disclaimer-modal">
        <div class="disclaimer-content">
            <div class="disclaimer-title">Important Notice</div>
            <div class="disclaimer-subtitle">Please Read Before Continuing</div>
            
            <div class="disclaimer-text">
                <strong>Print Palette</strong> is a preview and colour selection tool for 3D printing enthusiasts. This application is provided for <strong>visualization purposes only</strong>.
            </div>

            <div class="disclaimer-warning">
                <p class="disclaimer-warning-text">‚ö†Ô∏è DISCLAIMER</p>
            </div>

            <ul class="disclaimer-list">
                <li>Print Palette is <strong>NOT</strong> the developer, creator, or owner of any 3D models displayed in this application.</li>
                <li>All 3D models, STL files, and associated intellectual property remain the <strong>property of their respective creators and rights holders</strong>.</li>
                <li>Any and all licenses, terms of use, and restrictions are set by the <strong>original model owners</strong>.</li>
                <li>Users are responsible for ensuring they have <strong>proper licenses and permissions</strong> to use any 3D models loaded into this application.</li>
                <li>This tool does not grant, imply, or transfer any rights to reproduce, distribute, or commercially use any 3D models.</li>
                <li>Encrypted project files (.stlproject) are for <strong>personal preview purposes only</strong> and do not constitute a license to use the models.</li>
            </ul>

            <div class="disclaimer-text">
                <strong>File Protection:</strong> STL files saved in .stlproject format are encrypted to prevent unauthorized extraction. This is a technical measure, not a license grant. You must obtain proper licenses directly from model creators.
            </div>

            <div class="disclaimer-text">
                <strong>No Warranty:</strong> This software is provided "as is" without warranty of any kind. Use at your own risk.
            </div>

            <div class="disclaimer-actions">
                <button class="disclaimer-btn decline" onclick="declineDisclaimer()">I Do Not Agree</button>
                <button class="disclaimer-btn accept" onclick="acceptDisclaimer()">I Understand & Agree</button>
            </div>
        </div>
    </div>

    <!-- License Modal -->
    <div class="license-modal hidden" id="license-modal">
        <div class="license-content">
            <div class="license-header">
                <div class="license-title">üìÑ Model License</div>
                <button class="license-close" onclick="hideLicense()">√ó</button>
            </div>
            <div class="license-body" id="license-body">
                No license information available.
            </div>
            <div class="license-footer">
                <button class="license-btn" id="license-accept-btn" onclick="acceptAndLoadProject()">I Understand & Load Project</button>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="sidebar">
            <div class="logo">PRINT PALETTE</div>
            <div class="subtitle">3D Print Colour Preview</div>
            
            <!-- Project Name Section -->
            <div class="project-name-section">
                <div class="project-label">Project Name</div>
                <input type="text" class="project-name-input" id="project-name" placeholder="My Blaster Assembly" value="Untitled Project">
            </div>

            <!-- Upload Section -->
            <div class="upload-section">
                <div class="upload-zone" id="upload-zone" onclick="document.getElementById('file-input').click()">
                    <div class="upload-icon">üì¶</div>
                    <div class="upload-text">Load STL Parts</div>
                    <div class="upload-hint">Or load a project file (.stlproject)</div>
                </div>
                <input type="file" id="file-input" accept=".stl,.stlproject" multiple>
            </div>

            <!-- Project Buttons -->
            <div class="action-buttons">
                <button class="action-btn project" onclick="saveProject()" title="Save project with encrypted STL files - preview only, no extraction">üíæ Save Project</button>
                <button class="action-btn project" onclick="loadProject()">üìÇ Load Project</button>
            </div>
            
            <!-- Load from URL Section -->
            <div style="margin: 12px 0; padding: 12px; background: rgba(0, 245, 255, 0.05); border: 1px solid var(--border); border-radius: 8px;">
                <div style="font-size: 10px; color: var(--text-secondary); font-family: 'Azeret Mono', monospace; text-transform: uppercase; margin-bottom: 6px;">Load from URL:</div>
                <div style="display: flex; gap: 8px;">
                    <input type="text" id="project-url-input" placeholder="https://raw.githubusercontent.com/.../project.stlproject" 
                           style="flex: 1; padding: 8px; background: var(--bg-primary); border: 1px solid var(--border); border-radius: 4px; color: var(--text-primary); font-size: 11px; font-family: 'Azeret Mono', monospace;">
                    <button class="action-btn project" onclick="loadProjectFromURL()" style="white-space: nowrap; padding: 8px 12px;">
                        üåê Load
                    </button>
                </div>
                <div style="font-size: 9px; color: var(--text-secondary); margin-top: 4px; opacity: 0.7;">Paste GitHub raw URL or direct .stlproject link</div>
            </div>
            
            <!-- Browse GitHub Projects -->
            <div style="margin: 12px 0; padding: 12px; background: rgba(138, 85, 247, 0.05); border: 1px solid var(--border); border-radius: 8px;">
                <div style="font-size: 10px; color: var(--text-secondary); font-family: 'Azeret Mono', monospace; text-transform: uppercase; margin-bottom: 6px;">Browse GitHub Repository:</div>
                
                <!-- Breadcrumb Navigation -->
                <div id="github-breadcrumb" style="display: flex; align-items: center; gap: 4px; padding: 8px; background: var(--bg-primary); border: 1px solid var(--border); border-radius: 6px; margin-bottom: 8px; flex-wrap: wrap; min-height: 36px;">
                    <span style="font-size: 10px; color: var(--text-secondary); font-family: 'Azeret Mono', monospace;">üìÅ Loading...</span>
                </div>
                
                <!-- Folder/Project List -->
                <div id="github-browser-list" style="max-height: 300px; overflow-y: auto; background: var(--bg-primary); border: 1px solid var(--border); border-radius: 6px; margin-bottom: 8px;">
                    <div style="padding: 20px; text-align: center; color: var(--text-secondary); font-size: 11px;">
                        Configure repository settings below ‚Üì
                    </div>
                </div>
                
                <button class="action-btn project" onclick="refreshGitHubBrowser()" style="width: 100%; padding: 8px; font-size: 11px;">
                    üîÑ Refresh Browser
                </button>
                <div style="font-size: 9px; color: var(--text-secondary); margin-top: 6px; opacity: 0.7;">
                    <span id="github-repo-info">Configure repo below ‚Üì</span>
                </div>
                <details style="margin-top: 8px;">
                    <summary style="cursor: pointer; font-size: 10px; color: var(--accent-cyan); font-family: 'Azeret Mono', monospace;">‚öôÔ∏è Repository Settings</summary>
                    <div style="margin-top: 8px; display: flex; flex-direction: column; gap: 6px;">
                        <div style="font-size: 9px; color: var(--accent-yellow); background: rgba(255, 215, 0, 0.1); padding: 6px; border-radius: 4px; margin-bottom: 4px;">
                            üí° <strong>Root Path:</strong><br>
                            Set the starting folder (e.g., "Projects")<br>
                            Navigate subfolders using the browser above
                        </div>
                        <input type="text" id="github-owner" placeholder="Repository Owner (e.g. MrBaristaNZ)" value="MrBaristaNZ"
                               style="padding: 6px; background: var(--bg-primary); border: 1px solid var(--border); border-radius: 4px; color: var(--text-primary); font-size: 10px;">
                        <input type="text" id="github-repo" placeholder="Repository Name (e.g. PrintPalette)" value="PrintPalette"
                               style="padding: 6px; background: var(--bg-primary); border: 1px solid var(--border); border-radius: 4px; color: var(--text-primary); font-size: 10px;">
                        <input type="text" id="github-path" placeholder="Root Path (e.g. Projects)" value="Projects"
                               style="padding: 6px; background: var(--bg-primary); border: 1px solid var(--border); border-radius: 4px; color: var(--text-primary); font-size: 10px;">
                        <button onclick="testGitHubPath()" style="padding: 6px; background: var(--accent-cyan); color: var(--bg-primary); border: none; border-radius: 4px; cursor: pointer; font-size: 10px; font-weight: 600;">
                            üß™ Test Path
                        </button>
                        <button onclick="saveGitHubSettings()" style="padding: 6px; background: var(--accent-green); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 10px; font-weight: 600;">
                            üíæ Save & Refresh
                        </button>
                    </div>
                </details>
                <div style="font-size: 9px; color: var(--text-secondary); background: rgba(255, 193, 7, 0.05); padding: 8px; border-radius: 4px; margin-top: 8px; border: 1px solid rgba(255, 193, 7, 0.2);">
                    üîç <strong style="color: var(--accent-cyan);">Folder Navigation:</strong><br>
                    Click folders to browse. Click projects to load.<br>
                    Organize projects in nested folders!<br><br>
                    üìÑ <strong style="color: var(--accent-yellow);">Auto License Detection:</strong><br>
                    Add <code style="background: rgba(0,0,0,0.3); padding: 2px 4px; border-radius: 2px;">LICENSE.txt</code> to any folder.<br>
                    All projects in that folder will use it automatically.
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="action-buttons">
                <button class="action-btn secondary" onclick="exportImage()">üì∏ Image</button>
                <button class="action-btn secondary" onclick="randomizeColors()">üé≤ Random Colour</button>
                <button class="action-btn secondary" onclick="clearAll()">üìÑ New Project</button>
            </div>

            <!-- Group Management -->
            <div class="group-management">
                <div class="section-header">
                    <div class="section-header-left">
                        <span>üìÅ Part Groups</span>
                    </div>
                </div>
                <div style="background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 8px; padding: 16px;">
                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 8px; font-family: 'Azeret Mono', monospace;">
                        1. Check parts below (‚úì) ‚Üí 2. Name group ‚Üí 3. Pick colour ‚Üí 4. Create
                    </div>
                    <input type="text" id="new-group-name" placeholder="Group name (e.g. 'Metal Parts')" 
                           style="width: 100%; padding: 10px; margin-bottom: 8px; background: var(--bg-primary); border: 1px solid var(--border); color: var(--text-primary); border-radius: 6px; font-family: 'Rajdhani', sans-serif;">
                    
                    <button class="action-btn secondary" onclick="createGroup()" style="width: 100%; margin-bottom: 16px;">
                        ‚ûï Create Group from Selected Parts
                    </button>
                    
                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 8px; font-family: 'Azeret Mono', monospace; border-top: 1px solid var(--border); padding-top: 16px;">
                        Group colour (create new or edit existing):
                    </div>
                    <select id="group-selector" onchange="selectGroup(this.value)" 
                            style="width: 100%; padding: 10px; margin-bottom: 8px; background: var(--bg-primary); border: 1px solid var(--border); color: var(--text-primary); border-radius: 6px; font-family: 'Rajdhani', sans-serif; cursor: pointer;">
                        <option value="">Select a group...</option>
                    </select>
                    
                    <div style="margin-bottom: 8px;">
                        <div style="font-size: 9px; color: var(--text-secondary); font-family: 'Azeret Mono', monospace; text-transform: uppercase; margin-bottom: 4px;">Group Colour:</div>
                        <select id="group-color-dropdown" onchange="updateGroupColorFromDropdown()" style="width: 100%; padding: 10px; border-radius: 6px; background: var(--bg-primary); border: 1px solid var(--border); color: var(--text-primary); font-family: 'Rajdhani', sans-serif; cursor: pointer; font-size: 12px;">
                            <option value="">Pick a colour</option>
                        </select>
                    </div>
                    
                    <button class="action-btn secondary" onclick="deleteGroup()" id="delete-group-btn" disabled style="width: 100%; background: rgba(255, 0, 107, 0.1); border-color: var(--accent-magenta); color: var(--accent-magenta);">
                        üóë Delete Selected Group
                    </button>
                    
                    <button class="apply-multi-btn" onclick="colorAllGroupsRandomly()" style="width: 100%; margin-top: 8px; background: linear-gradient(135deg, rgba(138, 85, 247, 0.2), rgba(255, 107, 53, 0.2)); border-color: var(--accent-purple); color: var(--accent-purple);">
                        üé≤ Randomize All Group Colours
                    </button>
                </div>
            </div>

            <!-- Parts Section -->
            <div class="part-section">
                <!-- Sticky Header Container -->
                <div class="part-section-sticky-header">
                    <div class="section-header">
                        <div class="section-header-left">
                            <span>Assembly Parts</span>
                        </div>
                        <div class="section-actions">
                            <button class="section-btn" onclick="expandAllParts()">Expand</button>
                            <button class="section-btn" onclick="collapseAllParts()">Collapse</button>
                            <button class="section-btn" onclick="lockAllParts()" title="Lock all parts">üîí Lock</button>
                            <button class="section-btn" onclick="unlockAllParts()" title="Unlock all parts">üîì Unlock</button>
                        </div>
                    </div>
                    
                    <!-- Search Filter -->
                    <div style="padding: 8px 12px; background: var(--bg-secondary); border-bottom: 1px solid var(--border);">
                        <div style="position: relative;">
                            <input 
                                type="text" 
                                id="part-search" 
                                placeholder="üîç Search parts..." 
                                oninput="filterParts(this.value)"
                                style="width: 100%; padding: 8px 36px 8px 12px; background: var(--bg-primary); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); font-family: 'Rajdhani', sans-serif; font-size: 13px;"
                            />
                            <button 
                                onclick="clearPartSearch()" 
                                style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); background: none; border: none; color: var(--text-secondary); cursor: pointer; font-size: 16px; padding: 4px 8px; line-height: 1;"
                                title="Clear search"
                            >√ó</button>
                        </div>
                        <div id="search-results-count" style="font-size: 10px; color: var(--text-secondary); margin-top: 4px; font-family: 'Azeret Mono', monospace;"></div>
                    </div>
                </div>
                
                <div id="parts-container">
                    <div class="empty-state">
                        No parts loaded yet.<br>
                        Upload STL files or load a project.
                    </div>
                </div>
                
                <!-- Back to Top Button - Always Visible -->
                <div class="parts-back-to-top">
                    <button onclick="scrollPartsToTop()" title="Back to top">
                        ‚Üë Top
                    </button>
                </div>
            </div>
        </div>

        <div class="viewer">
            <div id="canvas-container"></div>
            
            <div style="position: absolute; top: 10px; left: 10px; background: rgba(10, 14, 23, 0.9); padding: 8px 12px; border-radius: 6px; border: 1px solid var(--border); font-size: 11px; color: var(--text-secondary); font-family: 'Azeret Mono', monospace; pointer-events: none; opacity: 0.8;">
                üí° Double-click a part to find it in the list
            </div>
            
            <!-- Combined View & Rotation Controls Panel -->
            <div id="control-panel" style="position: absolute; top: 10px; right: 10px; background: rgba(10, 14, 23, 0.95); padding: 12px; border-radius: 8px; border: 1px solid var(--border); z-index: 100; max-width: 240px;">
                
                <!-- View Section -->
                <div style="margin-bottom: 12px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; border-bottom: 1px solid var(--border); padding-bottom: 6px;">
                        <div style="font-size: 10px; color: var(--text-secondary); font-family: 'Azeret Mono', monospace; text-transform: uppercase;">
                            üëÅÔ∏è View Controls
                        </div>
                        <button onclick="toggleControlPanel()" style="background: transparent; border: 1px solid var(--border); color: var(--text-secondary); cursor: pointer; font-size: 12px; padding: 1px 6px; line-height: 1; border-radius: 3px; font-family: monospace; opacity: 0.7; transition: opacity 0.2s;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.7'" title="Minimize">‚àí</button>
                    </div>
                    
                    <div id="view-controls-content">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-bottom: 4px;">
                            <button class="control-btn" onclick="resetCamera()" style="padding: 6px; font-size: 9px;">Reset View</button>
                            <button class="control-btn" onclick="frameModel()" style="padding: 6px; font-size: 9px;">Frame All</button>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-bottom: 4px;">
                            <button class="control-btn" id="undo-btn" onclick="undo()" disabled style="padding: 6px; font-size: 9px;" title="Undo (Ctrl+Z)">‚Ü∂ Undo</button>
                            <button class="control-btn" id="redo-btn" onclick="redo()" disabled style="padding: 6px; font-size: 9px;" title="Redo (Ctrl+Y)">‚Ü∑ Redo</button>
                        </div>
                        <button class="control-btn" id="measure-btn" onclick="toggleMeasure()" style="width: 100%; padding: 6px; font-size: 9px;">üìè Measure</button>
                    </div>
                </div>
                
                <!-- Rotate Section -->
                <div id="rotate-section">
                    <div style="font-size: 10px; color: var(--text-secondary); font-family: 'Azeret Mono', monospace; text-transform: uppercase; margin-bottom: 8px; text-align: center; border-bottom: 1px solid var(--border); padding-bottom: 6px;">
                        üîÑ Rotate Model
                    </div>
                    
                    <div id="rotate-controls-content">
                        <!-- Preset Views -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 4px; margin-bottom: 8px;">
                            <button class="control-btn" onclick="setTopView()" style="padding: 6px; font-size: 9px;" title="Top View">Top</button>
                            <button class="control-btn" onclick="setFrontView()" style="padding: 6px; font-size: 9px;" title="Front View">Front</button>
                            <button class="control-btn" onclick="setSideView()" style="padding: 6px; font-size: 9px;" title="Side View">Side</button>
                            <button class="control-btn" onclick="setBottomView()" style="padding: 6px; font-size: 9px;" title="Bottom View">Bottom</button>
                            <button class="control-btn" onclick="setBackView()" style="padding: 6px; font-size: 9px;" title="Back View">Back</button>
                            <button class="control-btn" onclick="setOtherSideView()" style="padding: 6px; font-size: 9px;" title="Other Side View">Other</button>
                        </div>
                        
                        <div style="border-top: 1px solid var(--border); padding-top: 8px; margin-bottom: 8px;"></div>
                        
                        <!-- Y-axis rotation (horizontal spin) -->
                        <div style="display: flex; gap: 6px; margin-bottom: 6px;">
                            <button class="control-btn" onclick="rotateLeft90()" style="flex: 1; padding: 8px; font-size: 16px;" title="Rotate 90¬∞ Left (Y-axis)">‚Ü∂</button>
                            <button class="control-btn" onclick="rotateRight90()" style="flex: 1; padding: 8px; font-size: 16px;" title="Rotate 90¬∞ Right (Y-axis)">‚Ü∑</button>
                        </div>
                        
                        <!-- X-axis rotation (vertical tilt) -->
                        <div style="display: flex; gap: 6px; margin-bottom: 6px;">
                            <button class="control-btn" onclick="rotateUp90()" style="flex: 1; padding: 8px; font-size: 16px;" title="Rotate 90¬∞ Up (X-axis)">‚Üë</button>
                            <button class="control-btn" onclick="rotateDown90()" style="flex: 1; padding: 8px; font-size: 16px;" title="Rotate 90¬∞ Down (X-axis)">‚Üì</button>
                        </div>
                        
                        <!-- Fine rotation controls -->
                        <div style="font-size: 9px; color: var(--text-secondary); font-family: 'Azeret Mono', monospace; margin-bottom: 4px; text-align: center;">
                            Fine Tune (15¬∞)
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-bottom: 6px;">
                            <button class="control-btn" onclick="rotateLeft15()" style="padding: 4px; font-size: 9px;">‚Ü∂ 15¬∞</button>
                            <button class="control-btn" onclick="rotateRight15()" style="padding: 4px; font-size: 9px;">‚Ü∑ 15¬∞</button>
                            <button class="control-btn" onclick="rotateUp15()" style="padding: 4px; font-size: 9px;">‚Üë 15¬∞</button>
                            <button class="control-btn" onclick="rotateDown15()" style="padding: 4px; font-size: 9px;">‚Üì 15¬∞</button>
                        </div>
                        
                        <!-- Additional rotation options -->
                        <div style="font-size: 9px; color: var(--text-secondary); font-family: 'Azeret Mono', monospace; margin-bottom: 4px; text-align: center;">
                            More Angles
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 4px; margin-bottom: 6px;">
                            <button class="control-btn" onclick="rotateLeft30()" style="padding: 4px; font-size: 9px;">‚Ü∂ 30¬∞</button>
                            <button class="control-btn" onclick="rotateLeft45()" style="padding: 4px; font-size: 9px;">‚Ü∂ 45¬∞</button>
                            <button class="control-btn" onclick="rotateLeft60()" style="padding: 4px; font-size: 9px;">‚Ü∂ 60¬∞</button>
                            <button class="control-btn" onclick="rotateRight30()" style="padding: 4px; font-size: 9px;">‚Ü∑ 30¬∞</button>
                            <button class="control-btn" onclick="rotateRight45()" style="padding: 4px; font-size: 9px;">‚Ü∑ 45¬∞</button>
                            <button class="control-btn" onclick="rotateRight60()" style="padding: 4px; font-size: 9px;">‚Ü∑ 60¬∞</button>
                        </div>
                        
                        <!-- Flip controls -->
                        <div style="display: flex; gap: 6px; margin-bottom: 6px;">
                            <button class="control-btn" onclick="flipHorizontal()" style="flex: 1; padding: 6px; font-size: 10px;" title="Flip 180¬∞ Horizontal">‚Üî Flip H</button>
                            <button class="control-btn" onclick="flipVertical()" style="flex: 1; padding: 6px; font-size: 10px;" title="Flip 180¬∞ Vertical">‚Üï Flip V</button>
                        </div>
                        
                        <!-- Reset rotation -->
                        <button class="control-btn" onclick="resetRotation()" style="width: 100%; padding: 6px; font-size: 10px; background: rgba(255, 107, 53, 0.1); border-color: var(--accent-orange); color: var(--accent-orange);">
                            ‚ü≤ Reset Rotation
                        </button>
                    </div>
                </div>
            </div>

            <div class="measurement-overlay" id="measurement-overlay">
                <div class="measurement-title">Measurement Tool</div>
                <div class="measurement-hint">Click two points to measure distance</div>
                <div class="measurement-value" id="measurement-value">--</div>
                <div id="bounding-box-info"></div>
            </div>

            <div class="info-overlay" id="info-overlay">
                <div class="info-overlay-header">
                    <div class="info-overlay-title">‚å®Ô∏è Keyboard Shortcuts</div>
                    <button class="info-toggle-btn" onclick="toggleInfoOverlay()" title="Minimize">‚àí</button>
                </div>
                <div class="info-content">
                    <div><span class="info-label">UNDO/REDO:</span>Ctrl+Z / Ctrl+Y</div>
                    <div><span class="info-label">MOVE PARTS:</span>Shift + Left drag (horizontal)</div>
                    <div><span class="info-label">MOVE UP/DOWN:</span>Shift + Right drag (vertical)</div>
                    <div><span class="info-label">VIEWS:</span>1-6 keys (Top/Front/Side/Bottom/Back)</div>
                    <div><span class="info-label">ROTATE:</span>Left drag or Arrow keys</div>
                    <div><span class="info-label">SNAP 90¬∞:</span>Shift + Arrows</div>
                    <div><span class="info-label">FINE 15¬∞:</span>Ctrl + Arrows</div>
                    <div><span class="info-label">ROLL:</span>Q/E keys</div>
                    <div><span class="info-label">FLIP:</span>H (horizontal) / V (vertical)</div>
                    <div><span class="info-label">RESET:</span>R key</div>
                    <div><span class="info-label">MINIMIZE PANELS:</span>M key</div>
                    <div><span class="info-label">PAN:</span>Right drag</div>
                    <div><span class="info-label">ZOOM:</span>Scroll wheel</div>
                    <div><span class="info-label">PARTS:</span><span id="part-count">0</span> loaded</div>
                    <div id="project-name-display"></div>
                </div>
            </div>
            
            <!-- View Disclaimer Link -->
            <div style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 10;">
                <a href="javascript:void(0)" onclick="showDisclaimer()" style="
                    display: inline-block;
                    padding: 8px 16px;
                    background: rgba(10, 14, 23, 0.95);
                    backdrop-filter: blur(10px);
                    border: 1px solid var(--accent-cyan);
                    border-radius: 6px;
                    color: var(--accent-cyan);
                    text-decoration: none;
                    font-family: 'Rajdhani', sans-serif;
                    font-size: 12px;
                    font-weight: 600;
                    transition: all 0.3s ease;
                    text-transform: uppercase;
                    letter-spacing: 0.5px;
                " 
                onmouseover="this.style.background='rgba(0, 245, 255, 0.1)'; this.style.borderColor='var(--accent-cyan)'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0, 245, 255, 0.3)'"
                onmouseout="this.style.background='rgba(10, 14, 23, 0.95)'; this.style.borderColor='var(--accent-cyan)'; this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                    üìã View Disclaimer
                </a>
            </div>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <script type="module">
        // Import Three.js r170 and addons
        import * as THREE from 'three';
        import { STLLoader } from 'three/addons/loaders/STLLoader.js';
        import { STLExporter } from 'three/addons/exporters/STLExporter.js';
        
        // Make THREE globally available for compatibility
        window.THREE = THREE;
        
        // Scene setup
        let scene, camera, renderer, raycaster, mouse;
        let parts = [];
        let partFiles = {}; // Store original STL files
        let loader, exporter;
        let modelGroup;
        let measureMode = false;
        let measurePoints = [];
        let selectedParts = new Set();
        let groups = []; // Array of { name: string, parts: Set<number>, color: string }
        let selectedGroup = null;
        let animationFrameId = null; // Track animation frame for cleanup
        
        // Part movement/dragging system
        let isDragging = false;
        let draggedPart = null;
        let dragMode = null; // 'horizontal' for left click, 'vertical' for right click
        let dragPlane = new THREE.Plane();
        let dragIntersection = new THREE.Vector3();
        let dragOffset = new THREE.Vector3();
        
        // Project state tracking
        let hasUnsavedChanges = false; // Track if current project has unsaved changes
        let currentProjectName = null; // Track current project name
        let isGitHubProject = false; // Track if current project was loaded from GitHub
        let projectLicenseToEmbed = null; // License text to embed when saving GitHub projects
        
        // Undo/Redo system
        let history = []; // Array of state snapshots
        let historyIndex = -1; // Current position in history
        const MAX_HISTORY = 50; // Maximum number of undo steps
        let isApplyingHistory = false; // Flag to prevent saving state during undo/redo
        
        // Folder-based license system (from GitHub LICENSE.txt)
        let currentFolderLicense = null; // License text from LICENSE.txt in current GitHub folder
        let currentFolderPath = null; // Current GitHub folder path
        let pendingProjectUrl = null; // URL of project waiting for license acceptance
        let pendingManualUrl = null; // Manual URL as fallback
        let licenseAlreadyShown = false; // Track if we already showed license for this load
        
        // GitHub folder browser state
        let githubBrowserCurrentPath = null; // Current browsing path
        let githubBrowserCache = {}; // Cache folder contents
        
        let presetColors = [
            // Row 1: Basic colors (most common)
            '#FFFFFF', // White (Pure White PLA)
            '#1C1C1C', // Black (True Black PLA)
            '#E63946', // Red (Fire Engine Red)
            '#2563EB', // Blue (Royal Blue)
            '#22C55E', // Green (Grass Green)
            
            // Row 2: Bright colors
            '#FCD34D', // Yellow (Bright Yellow)
            '#F97316', // Orange (Safety Orange)
            '#EC4899', // Pink (Hot Pink)
            '#7C3AED', // Purple (Deep Purple)
            '#38BDF8', // Sky Blue (Light Blue)
            
            // Row 3: Specialty colors
            '#9CA3AF', // Gray (Silver Gray)
            '#047857', // Dark Green (Forest Green)
            '#92400E', // Brown (Chocolate Brown)
            '#D4AF37', // Gold (Metallic Gold)
            '#F5F5DC'  // Natural/Beige (Transparent/Natural PLA)
        ];

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0e17);
            
            modelGroup = new THREE.Group();
            scene.add(modelGroup);
            
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 50, 150);
            camera.lookAt(0, 0, 0);
            
            const container = document.getElementById('canvas-container');
            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);
            
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(100, 100, 100);
            scene.add(mainLight);
            
            const fillLight = new THREE.DirectionalLight(0x00f5ff, 0.3);
            fillLight.position.set(-100, 0, -100);
            scene.add(fillLight);
            
            const rimLight = new THREE.DirectionalLight(0xff006b, 0.2);
            rimLight.position.set(0, -100, -100);
            scene.add(rimLight);
            
            loader = new STLLoader();
            exporter = new STLExporter();
            
            setupFileUpload();
            setupControls();
            animate();
            updateProjectDisplay();
            
            window.addEventListener('resize', onWindowResize);
            
            // Check if project URL is in URL parameters
            checkURLParameters();
            
            // Initialize GitHub project browser
            setTimeout(() => {
                initGitHubBrowser();
            }, 500);
            
            // Setup sticky header floating detection
            setupStickyHeaderDetection();
        }

        function updateProjectDisplay() {
            const projectName = document.getElementById('project-name').value;
            document.getElementById('project-name-display').innerHTML = 
                `<span class="info-label">PROJECT:</span>${projectName}`;
        }

        // PROJECT STATE MANAGEMENT
        function markAsModified() {
            hasUnsavedChanges = true;
            saveState(); // Save to undo history
            console.log('üìù Project marked as modified');
        }
        
        function setAsGitHubProject(license = null) {
            // Mark project as loaded from GitHub
            isGitHubProject = true;
            projectLicenseToEmbed = license;
            
            // Lock project name (make read-only)
            const nameInput = document.getElementById('project-name');
            if (nameInput) {
                nameInput.readOnly = true;
                nameInput.style.cursor = 'not-allowed';
                nameInput.style.opacity = '0.7';
                nameInput.title = 'Project name cannot be changed for GitHub projects';
                console.log('üîí Project name locked (GitHub project)');
            }
            
            // Add GitHub badge to project label
            const projectLabel = document.querySelector('.project-label');
            if (projectLabel && !projectLabel.querySelector('.github-badge')) {
                const badge = document.createElement('span');
                badge.className = 'github-badge';
                badge.innerHTML = ' <span style="display: inline-block; padding: 2px 6px; background: rgba(138, 85, 247, 0.2); border: 1px solid var(--accent-purple); border-radius: 4px; font-size: 9px; color: var(--accent-purple); font-weight: 600; margin-left: 6px;">üìÇ GITHUB</span>';
                projectLabel.appendChild(badge);
            }
        }
        
        function clearGitHubProjectStatus() {
            // Clear GitHub project status
            isGitHubProject = false;
            projectLicenseToEmbed = null;
            
            // Unlock project name
            const nameInput = document.getElementById('project-name');
            if (nameInput) {
                nameInput.readOnly = false;
                nameInput.style.cursor = 'text';
                nameInput.style.opacity = '1';
                nameInput.title = '';
                console.log('üîì Project name unlocked');
            }
            
            // Remove GitHub badge
            const badge = document.querySelector('.github-badge');
            if (badge) {
                badge.remove();
            }
        }
        
        function resetGitHubFolderState() {
            // Clear GitHub folder state to prevent wrong license being applied
            currentFolderLicense = null;
            currentFolderPath = null;
            licenseAlreadyShown = false;
            console.log('üîÑ GitHub folder state reset');
        }
        
        async function promptBeforeLoad(loadCallback) {
            // Check if there are unsaved changes
            if (hasUnsavedChanges && parts.length > 0) {
                const projectName = currentProjectName || 'Current Project';
                const message = `You have unsaved changes in "${projectName}".\n\nWhat would you like to do?`;
                
                // Custom prompt with three options
                const result = confirm(message + '\n\nClick OK to SAVE first, or Cancel to DISCARD changes and load new project.');
                
                if (result) {
                    // User wants to save first
                    console.log('üíæ User chose to save before loading');
                    
                    // Save the project
                    await saveProject();
                    
                    // Ask if they still want to continue loading
                    const continueLoad = confirm('Project saved! Continue loading new project?');
                    if (continueLoad) {
                        resetGitHubFolderState();
                        hasUnsavedChanges = false;
                        loadCallback();
                    }
                } else {
                    // User chose to discard changes
                    console.log('üóëÔ∏è User chose to discard changes');
                    resetGitHubFolderState();
                    hasUnsavedChanges = false;
                    loadCallback();
                }
            } else {
                // No unsaved changes, load directly
                resetGitHubFolderState();
                hasUnsavedChanges = false;
                loadCallback();
            }
        }

        // Update project name when changed
        // DISCLAIMER FUNCTIONS
        function showDisclaimer() {
            const modal = document.getElementById('disclaimer-modal');
            if (modal) {
                modal.classList.remove('hidden');
                console.log('üìã Disclaimer modal shown');
            } else {
                console.error('‚ùå Disclaimer modal element not found');
            }
        }

        function hideDisclaimer() {
            const modal = document.getElementById('disclaimer-modal');
            if (modal) {
                modal.classList.add('hidden');
                console.log('üìã Disclaimer modal hidden');
            }
        }

        function acceptDisclaimer() {
            // Store acceptance in localStorage
            const timestamp = new Date().toISOString();
            localStorage.setItem('printPaletteDisclaimerAccepted', 'true');
            localStorage.setItem('printPaletteDisclaimerDate', timestamp);
            
            console.log('‚úì Disclaimer accepted at:', timestamp);
            
            hideDisclaimer();
            showToast('‚úì Welcome to Print Palette');
        }

        function declineDisclaimer() {
            // Redirect away or show message
            console.log('‚ùå User declined disclaimer');
            if (confirm('You must agree to the terms to use Print Palette.\n\nClick OK to close this page.')) {
                window.location.href = 'about:blank';
            }
        }

        function checkDisclaimer() {
            const accepted = localStorage.getItem('printPaletteDisclaimerAccepted');
            
            if (accepted !== 'true') {
                // Show disclaimer if not previously accepted
                console.log('üìã First visit detected - showing disclaimer');
                showDisclaimer();
            } else {
                // Hide disclaimer if already accepted
                console.log('‚úì Disclaimer previously accepted');
                hideDisclaimer();
            }
        }
        
        // Helper function to reset disclaimer acceptance (for testing)
        // Call this in browser console: resetDisclaimer()
        function resetDisclaimer() {
            localStorage.removeItem('printPaletteDisclaimerAccepted');
            localStorage.removeItem('printPaletteDisclaimerDate');
            console.log('‚úì Disclaimer reset - refresh page to see it again');
            alert('Disclaimer acceptance reset!\n\nRefresh the page to see the disclaimer again.');
        }

        // FOLDER LICENSE FUNCTIONS (GitHub-based)

        // Show license modal
        function showLicense(licenseText, title = "Model License") {
            console.log('üìÑ Showing license modal:', title);
            console.log('License text length:', licenseText ? licenseText.length : 'characters');
            console.log('licenseAlreadyShown flag:', licenseAlreadyShown);
            
            const modal = document.getElementById('license-modal');
            const body = document.getElementById('license-body');
            const titleEl = document.querySelector('.license-title');
            
            if (titleEl) {
                titleEl.textContent = `üìÑ ${title}`;
            }
            
            if (body) {
                body.textContent = licenseText || "No license information available.";
            }
            
            if (modal) {
                modal.classList.remove('hidden');
                console.log('‚úì License modal displayed');
            } else {
                console.error('‚ùå License modal element not found');
            }
        }

        // Hide license modal
        function hideLicense() {
            const modal = document.getElementById('license-modal');
            if (modal) {
                modal.classList.add('hidden');
                console.log('üìÑ License modal hidden');
            }
            pendingProjectUrl = null; // Clear pending project
            pendingManualUrl = null; // Clear pending manual URL
        }

        // Accept license and load pending project
        function acceptAndLoadProject() {
            console.log('‚úì License accepted, loading project...');
            console.log('licenseAlreadyShown flag before load:', licenseAlreadyShown);
            
            // Save URLs before hiding modal (hideLicense clears pending URLs)
            const url = pendingProjectUrl;
            const manualUrl = pendingManualUrl;
            
            // Hide modal and clear pending URLs
            hideLicense();
            
            // Load project if we had a pending URL
            if (url) {
                console.log('Loading project from URL:', url);
                console.log('Manual URL fallback:', manualUrl);
                console.log('licenseAlreadyShown flag at loadProjectFromURL call:', licenseAlreadyShown);
                loadProjectFromURL(url, manualUrl);
            } else {
                console.error('‚ùå No pending project URL found');
            }
        }

        // Update GitHub browser info display
        function updateGitHubBrowserInfo() {
            const infoSpan = document.getElementById('github-repo-info');
            if (!infoSpan) return;
            
            const settings = getGitHubSettings();
            const licenseIndicator = currentFolderLicense ? ' <span style="color: var(--accent-yellow);">üìÑ License</span>' : '';
            
            if (currentFolderPath) {
                const dropdown = document.getElementById('github-project-dropdown');
                const projectCount = dropdown ? dropdown.options.length - 1 : 0; // -1 for "Select a project" option
                
                if (projectCount > 0) {
                    infoSpan.innerHTML = `<span style="color: var(--accent-green);">‚úì</span> ${projectCount} project(s) in ${settings.owner}/${settings.repo}${licenseIndicator}`;
                } else {
                    infoSpan.innerHTML = `<span style="color: var(--accent-yellow);">‚ö†</span> No .stlproject files found`;
                }
            } else {
                infoSpan.textContent = 'Configure repo below ‚Üì';
            }
        }

        // Check disclaimer on page load
        window.addEventListener('load', () => {
            checkDisclaimer();
        });

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('project-name').addEventListener('input', updateProjectDisplay);
        });

        // PROJECT SAVE/LOAD FUNCTIONS
        
        // Simple XOR encryption to protect STL files in project archives
        function encryptBuffer(buffer, key) {
            const data = new Uint8Array(buffer);
            const encrypted = new Uint8Array(data.length);
            const keyBytes = new TextEncoder().encode(key);
            
            for (let i = 0; i < data.length; i++) {
                encrypted[i] = data[i] ^ keyBytes[i % keyBytes.length];
            }
            
            return encrypted.buffer;
        }
        
        function decryptBuffer(buffer, key) {
            // XOR encryption is symmetric - same operation for decrypt
            return encryptBuffer(buffer, key);
        }
        
        function generateEncryptionKey(projectName) {
            // Generate a consistent key from project name
            // This isn't cryptographically secure, but prevents casual extraction
            return `PP_${projectName}_2026_${projectName.length}`;
        }
        
        async function saveProject() {
            if (parts.length === 0) {
                showToast('‚ö†Ô∏è No parts to save');
                return;
            }

            // Auto-apply folder license if available
            let projectLicense = null;
            
            if (isGitHubProject && projectLicenseToEmbed) {
                // GitHub project - automatically include the license
                projectLicense = projectLicenseToEmbed;
                console.log('üìÑ GitHub project: Auto-embedding license from GitHub folder');
            } else if (currentFolderLicense && currentFolderPath) {
                // Not a GitHub project, but folder has license - ask user
                const folderName = currentFolderPath.split('/').pop();
                if (confirm(`This GitHub folder (${folderName}) has LICENSE.txt.\n\nInclude it in this project?`)) {
                    projectLicense = currentFolderLicense;
                    showToast(`‚úì GitHub folder license applied`);
                }
            }

            try {
                const projectName = document.getElementById('project-name').value || 'Untitled Project';
                showToast('üíæ Saving project...');

                const zip = new JSZip();
                const dataFolder = zip.folder("data");  // Changed from "stl_files" to "data"
                
                const encryptionKey = generateEncryptionKey(projectName);

                // Save all original STL files with encryption and obfuscation
                for (let i = 0; i < parts.length; i++) {
                    const part = parts[i];
                    const obfuscatedName = `part_${i}.dat`;  // Obfuscated filename
                    
                    console.log(`Exporting part ${i}: ${part.userData.name} as ${obfuscatedName}`);
                    
                    // Check if geometry is centered or not
                    const tempGeometry = part.geometry.clone();
                    tempGeometry.computeBoundingBox();
                    const geomCenter = new THREE.Vector3();
                    tempGeometry.boundingBox.getCenter(geomCenter);
                    const isCentered = Math.abs(geomCenter.x) < 0.1 && Math.abs(geomCenter.y) < 0.1 && Math.abs(geomCenter.z) < 0.1;
                    
                    if (isCentered) {
                        // Geometry is centered (v1.1), need to un-center it
                        const offset = part.userData.centerOffset || { x: 0, y: 0, z: 0 };
                        if (offset.x !== 0 || offset.y !== 0 || offset.z !== 0) {
                            console.log(`Un-centering geometry for ${part.userData.name}, offset:`, offset);
                            
                            // Manually move vertices back to original position
                            const positions = tempGeometry.attributes.position;
                            for (let j = 0; j < positions.count; j++) {
                                positions.setX(j, positions.getX(j) + offset.x);
                                positions.setY(j, positions.getY(j) + offset.y);
                                positions.setZ(j, positions.getZ(j) + offset.z);
                            }
                            positions.needsUpdate = true;
                            tempGeometry.computeBoundingBox();
                            console.log(`Geometry un-centered for export`);
                        }
                    } else {
                        // Geometry is already uncentered (v1.0 part), export as-is
                        console.log(`Geometry for ${part.userData.name} already uncentered, exporting as-is`);
                    }
                    
                    const tempMesh = new THREE.Mesh(tempGeometry, new THREE.MeshBasicMaterial());
                    
                    // Export as binary STL
                    const stlData = exporter.parse(tempMesh, { binary: true });
                    
                    console.log(`STL data type: ${stlData.constructor.name}, length: ${stlData.byteLength || stlData.length}`);
                    
                    // Get the buffer
                    let buffer;
                    if (stlData instanceof DataView) {
                        buffer = stlData.buffer;
                    } else if (stlData instanceof ArrayBuffer) {
                        buffer = stlData;
                    } else if (stlData instanceof Uint8Array) {
                        buffer = stlData.buffer;
                    } else {
                        buffer = new Uint8Array(stlData).buffer;
                    }
                    
                    // Encrypt the buffer
                    const encryptedBuffer = encryptBuffer(buffer, encryptionKey);
                    
                    // Add encrypted data with obfuscated name
                    dataFolder.file(obfuscatedName, encryptedBuffer, { binary: true });
                    
                    // Cleanup
                    tempGeometry.dispose();
                    tempMesh.geometry.dispose();
                    tempMesh.material.dispose();
                }

                // Save project configuration with obfuscated file mapping
                const projectData = {
                    projectName: projectName,
                    version: "1.1",  // Version 1.1: Added geometry centering for proper rotation
                    created: new Date().toISOString(),
                    protected: true,  // Flag indicating files are encrypted
                    license: projectLicense || null,  // Include license if present
                    assemblyRotation: {  // Save overall assembly rotation
                        x: modelGroup.rotation.x,
                        y: modelGroup.rotation.y,
                        z: modelGroup.rotation.z
                    },
                    parts: parts.map((part, i) => {
                        // Check if this part has centered geometry or not
                        const tempGeom = part.geometry.clone();
                        tempGeom.computeBoundingBox();
                        const geomCenter = new THREE.Vector3();
                        tempGeom.boundingBox.getCenter(geomCenter);
                        const isCentered = Math.abs(geomCenter.x) < 0.1 && Math.abs(geomCenter.y) < 0.1 && Math.abs(geomCenter.z) < 0.1;
                        
                        let savedPosition = part.userData.position;
                        
                        if (!isCentered) {
                            // This is a v1.0 part (uncentered geometry), convert absolute ‚Üí logical
                            const offset = part.userData.centerOffset || { x: 0, y: 0, z: 0 };
                            savedPosition = {
                                x: part.userData.position.x - offset.x,
                                y: part.userData.position.y - offset.y,
                                z: part.userData.position.z - offset.z
                            };
                            console.log(`Converting v1.0 to v1.1 position for ${part.userData.name}:`,
                                `absolute=(${part.userData.position.x},${part.userData.position.y},${part.userData.position.z})`,
                                `- offset=(${offset.x},${offset.y},${offset.z})`,
                                `= logical=(${savedPosition.x},${savedPosition.y},${savedPosition.z})`);
                        }
                        
                        return {
                            name: part.userData.name,
                            fileName: `part_${i}.dat`,  // Obfuscated filename
                            color: part.userData.color,
                            visible: part.userData.visible,
                            position: savedPosition,
                            rotation: part.userData.rotation,
                            locked: part.userData.locked
                        };
                    }),
                    groups: groups.map(g => ({
                        name: g.name,
                        parts: Array.from(g.parts),
                        color: g.color || '#ffffff'
                    }))
                };

                // Log project save details
                console.log('=== Saving Project ===');
                console.log('Project name:', projectName);
                console.log('Is GitHub project:', isGitHubProject);
                console.log('License included:', !!projectLicense);
                if (projectLicense) {
                    console.log('License length:', projectLicense.length, 'characters');
                    if (isGitHubProject) {
                        console.log('üìÑ License auto-embedded from GitHub folder');
                    }
                }

                zip.file("project.json", JSON.stringify(projectData, null, 2));
                
                // Add LICENSE.txt if license is present
                if (projectLicense) {
                    zip.file("LICENSE.txt", projectLicense);
                    console.log('‚úì LICENSE.txt added to project file');
                }
                
                // Add README explaining the protection
                const readmeText = `Print Palette Project File
=============================

This .stlproject file contains 3D model data for preview purposes only.

IMPORTANT NOTES:
- Files are encrypted and obfuscated to prevent unauthorized extraction
- This project can only be opened with Print Palette
- Individual STL files cannot be exported from this application
- To obtain print files, please purchase them from the original source
${projectLicense ? '\n‚ö†Ô∏è  MODEL LICENSE: See LICENSE.txt for usage terms and restrictions' : ''}
${projectLicense && currentFolderPath ? `\n    (License from GitHub folder: ${currentFolderPath})` : ''}

Project: ${projectName}
Created: ${new Date().toISOString()}
Protected: Yes
Version: 1.1

¬© Print Palette - For preview and color selection only
`;
                
                zip.file("README.txt", readmeText);

                console.log('Generating ZIP file...');
                
                // Generate and download zip
                const content = await zip.generateAsync({ 
                    type: "blob",
                    compression: "DEFLATE",
                    compressionOptions: { level: 6 }
                });
                
                console.log('ZIP generated, size:', content.size);
                
                const url = URL.createObjectURL(content);
                const link = document.createElement('a');
                link.href = url;
                link.download = `${projectName.replace(/[^a-z0-9]/gi, '_')}.stlproject`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                setTimeout(() => {
                    URL.revokeObjectURL(url);
                }, 100);

                showToast(`üîí Project "${projectName}" saved securely!`);
                console.log('Project saved successfully');
                
                // Reset unsaved changes flag and update current project name
                hasUnsavedChanges = false;
                currentProjectName = projectName;
                console.log('üìù Unsaved changes flag reset');
                
            } catch (err) {
                console.error('Save project error:', err);
                console.error('Error stack:', err.stack);
                showToast('‚ö†Ô∏è Error saving project: ' + err.message);
            }
        }

        async function loadProject() {
            // Check for unsaved changes first
            if (hasUnsavedChanges && parts.length > 0) {
                const projectName = currentProjectName || 'Current Project';
                const message = `You have unsaved changes in "${projectName}".\n\nClick OK to SAVE first, or Cancel to DISCARD and load new project.`;
                
                const saveFirst = confirm(message);
                
                if (saveFirst) {
                    // Save first
                    await saveProject();
                    const continueLoad = confirm('Project saved! Continue loading new project?');
                    if (!continueLoad) return;
                }
                
                // Reset state
                resetGitHubFolderState();
                hasUnsavedChanges = false;
            }
            
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.stlproject';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                showToast('üìÇ Loading project...');

                try {
                    console.log('=== Loading Project ===');
                    console.log('File:', file.name, 'Size:', file.size);
                    
                    const zip = await JSZip.loadAsync(file);
                    console.log('ZIP loaded successfully');
                    
                    // Read project configuration
                    const projectJsonFile = zip.file("project.json");
                    if (!projectJsonFile) {
                        throw new Error('Invalid project file - missing project.json');
                    }

                    const projectJsonText = await projectJsonFile.async("text");
                    const projectData = JSON.parse(projectJsonText);
                    console.log('Project data:', projectData);

                    // Validate project data
                    if (!projectData.parts || projectData.parts.length === 0) {
                        throw new Error('Project has no parts');
                    }

                    // Clear existing parts
                    clearAllSilent();

                    // Set project name
                    document.getElementById('project-name').value = projectData.projectName;
                    currentProjectName = projectData.projectName;
                    hasUnsavedChanges = false; // Fresh project load
                    clearGitHubProjectStatus(); // Not a GitHub project - unlock name
                    resetGitHubFolderState(); // Clear any GitHub folder state
                    updateProjectDisplay();

                    // Determine if project is encrypted
                    const isProtected = projectData.protected === true;
                    const folderName = isProtected ? "data" : "stl_files";
                    const encryptionKey = isProtected ? generateEncryptionKey(projectData.projectName) : null;

                    // Load STL files
                    const stlFolder = zip.folder(folderName);
                    if (!stlFolder) {
                        throw new Error(`Invalid project file - missing ${folderName} folder`);
                    }
                    
                    console.log(`Loading ${projectData.parts.length} parts... ${isProtected ? '(encrypted)' : '(unencrypted)'}`);
                    
                    const loadedParts = [];
                    const failedParts = [];

                    // Load parts sequentially for better error handling
                    for (const partData of projectData.parts) {
                        try {
                            console.log(`Loading part: ${partData.name} (${partData.fileName})`);
                            
                            const stlFile = stlFolder.file(partData.fileName);
                            if (!stlFile) {
                                console.warn(`STL file not found: ${partData.fileName}`);
                                failedParts.push(partData.name);
                                continue;
                            }
                            
                            // Get the file as arraybuffer with validation
                            let arrayBuffer = await stlFile.async("arraybuffer");
                            
                            if (!arrayBuffer || arrayBuffer.byteLength === 0) {
                                console.error(`Empty STL file: ${partData.fileName}`);
                                failedParts.push(partData.name);
                                continue;
                            }
                            
                            // Decrypt if protected
                            if (isProtected) {
                                arrayBuffer = decryptBuffer(arrayBuffer, encryptionKey);
                                console.log(`Decrypted STL data: ${arrayBuffer.byteLength} bytes`);
                            } else {
                                console.log(`STL data loaded: ${arrayBuffer.byteLength} bytes`);
                            }
                            
                            await loadSTLFromBuffer(arrayBuffer, partData, projectData.version || "1.0");
                            loadedParts.push(partData.name);
                            
                        } catch (partErr) {
                            console.error(`Failed to load part ${partData.name}:`, partErr);
                            failedParts.push(partData.name);
                        }
                    }

                    console.log(`Parts loaded: ${loadedParts.length}/${projectData.parts.length}`);
                    
                    if (loadedParts.length === 0) {
                        throw new Error('No parts could be loaded from project');
                    }

                    frameModel();
                    
                    // Restore groups if present
                    if (projectData.groups && Array.isArray(projectData.groups)) {
                        groups = projectData.groups.map(g => ({
                            name: g.name,
                            parts: new Set(g.parts),
                            color: g.color || '#ffffff'
                        }));
                        renderGroupSelector();
                        console.log('Groups restored:', groups.length);
                    }
                    
                    // Restore assembly rotation if present
                    if (projectData.assemblyRotation) {
                        modelGroup.rotation.set(
                            projectData.assemblyRotation.x,
                            projectData.assemblyRotation.y,
                            projectData.assemblyRotation.z
                        );
                        console.log('Assembly rotation restored:', projectData.assemblyRotation);
                    } else {
                        // No rotation saved, reset to default
                        modelGroup.rotation.set(0, 0, 0);
                    }
                    
                    // Display license if present
                    // (Always show for file uploads since they don't go through GitHub browser)
                    licenseAlreadyShown = false; // Reset flag
                    if (projectData.license) {
                        console.log('‚úì License found in project');
                        setTimeout(() => {
                            showLicense(projectData.license, `${projectData.projectName} - License`);
                        }, 500);
                    }
                    
                    // Show success/warning message
                    if (failedParts.length === 0) {
                        showToast(`üìÇ Project "${projectData.projectName}" loaded successfully!`);
                    } else {
                        showToast(`‚ö†Ô∏è Loaded ${loadedParts.length}/${projectData.parts.length} parts (${failedParts.length} failed)`);
                        console.warn('Failed parts:', failedParts);
                    }
                    
                    // Initialize undo/redo history
                    initializeHistory();
                    
                    console.log('=== Project Load Complete ===');

                } catch (err) {
                    console.error('=== Load Project Error ===');
                    console.error('Error:', err);
                    console.error('Stack:', err.stack);
                    
                    showToast('‚ö†Ô∏è Error loading project: ' + err.message);
                    
                    // Show detailed error in UI
                    const errorDetail = document.createElement('div');
                    errorDetail.style.cssText = 'position: fixed; top: 100px; left: 50%; transform: translateX(-50%); background: rgba(255, 0, 107, 0.95); color: white; padding: 20px; border-radius: 8px; z-index: 10000; max-width: 500px; box-shadow: 0 8px 32px rgba(0,0,0,0.5);';
                    errorDetail.innerHTML = `
                        <strong style="font-size: 18px;">Project Load Error:</strong><br><br>
                        <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 4px; margin: 10px 0;">
                            ${err.message}
                        </div>
                        <small style="opacity: 0.8;">Check console (F12) for detailed error information</small><br><br>
                        <button onclick="this.parentElement.remove()" style="width: 100%; margin-top: 10px; padding: 10px; background: white; color: #ff006b; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 14px;">Close</button>
                    `;
                    document.body.appendChild(errorDetail);
                    setTimeout(() => errorDetail.remove(), 15000);
                }
            };
            input.click();
        }
        
        // Load project from URL (GitHub, direct link, etc.)
        async function loadProjectFromURL(urlParam = null, manualUrlParam = null) {
            let url = urlParam;
            let manualUrl = manualUrlParam;
            
            // If no URL provided, get from input field (user-initiated manual load)
            if (!url) {
                // Check for unsaved changes first
                if (hasUnsavedChanges && parts.length > 0) {
                    const projectName = currentProjectName || 'Current Project';
                    const message = `You have unsaved changes in "${projectName}".\n\nClick OK to SAVE first, or Cancel to DISCARD and load new project.`;
                    
                    const saveFirst = confirm(message);
                    
                    if (saveFirst) {
                        // Save first
                        await saveProject();
                        const continueLoad = confirm('Project saved! Continue loading new project?');
                        if (!continueLoad) return;
                    }
                    
                    // Reset state
                    resetGitHubFolderState();
                    hasUnsavedChanges = false;
                }
                
                const urlInput = document.getElementById('project-url-input');
                url = urlInput ? urlInput.value.trim() : '';
            }
            
            if (!url) {
                showToast('‚ö†Ô∏è Please enter a project URL');
                return;
            }
            
            // Validate and normalize URL
            try {
                const urlObj = new URL(url);
                
                // For GitHub raw URLs, ensure proper encoding
                if (urlObj.hostname === 'raw.githubusercontent.com') {
                    console.log('GitHub raw URL detected');
                    const pathParts = urlObj.pathname.split('/').map(part => {
                        // Each part should be properly URI encoded
                        // Decode first in case it's already encoded, then re-encode properly
                        return encodeURIComponent(decodeURIComponent(part));
                    });
                    urlObj.pathname = pathParts.join('/');
                    url = urlObj.toString();
                    console.log('Normalized GitHub URL:', url);
                }
            } catch (e) {
                showToast('‚ö†Ô∏è Invalid URL format');
                console.error('Invalid URL:', url, e);
                return;
            }
            
            showToast('üåê Loading project from URL...');
            console.log('=== Loading Project from URL ===');
            console.log('URL:', url);
            
            let contentLength = null; // Store for error handling
            
            try {
                // Try to fetch with detailed error handling
                console.log('Fetching URL:', url);
                
                let response;
                let lastError;
                
                // Try primary URL first
                try {
                    response = await fetch(url, {
                        method: 'GET',
                        mode: 'cors',
                        cache: 'no-cache',
                        headers: {
                            'Accept': 'application/octet-stream, application/zip, */*'
                        }
                    });
                    
                    console.log('Primary URL response status:', response.status);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                } catch (fetchError) {
                    console.error('Primary URL fetch failed:', fetchError);
                    lastError = fetchError;
                    
                    // If we have a manual URL and primary failed, try it
                    if (manualUrl && manualUrl !== url) {
                        console.warn('‚ö†Ô∏è Primary URL failed, trying manual URL...');
                        console.log('Manual URL:', manualUrl);
                        
                        try {
                            response = await fetch(manualUrl, {
                                method: 'GET',
                                mode: 'cors',
                                cache: 'no-cache',
                                headers: {
                                    'Accept': 'application/octet-stream, application/zip, */*'
                                }
                            });
                            
                            console.log('Manual URL response status:', response.status);
                            
                            if (!response.ok) {
                                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                            }
                            
                            console.log('‚úì Manual URL succeeded!');
                        } catch (manualFetchError) {
                            console.error('Manual URL also failed:', manualFetchError);
                            // Both failed, throw the original error with both URLs
                            throw new Error(`Both URLs failed. Primary: ${fetchError.message}. Manual: ${manualFetchError.message}`);
                        }
                    } else {
                        // No manual URL to try, re-throw the error
                        throw new Error(`Network error: ${fetchError.message}. This may be due to CORS restrictions, network issues, or the file not existing on GitHub.`);
                    }
                }
                
                console.log('Response headers:', [...response.headers.entries()]);
                
                // Check content-length if available
                contentLength = response.headers.get('content-length');
                if (contentLength) {
                    console.log('Content-Length:', contentLength, 'bytes');
                    if (parseInt(contentLength) === 0) {
                        throw new Error('Server reports file is empty (Content-Length: 0)');
                    }
                }
                
                // Try to download the blob with timeout
                console.log('Downloading file blob...');
                let blob;
                try {
                    // Add timeout for blob download (30 seconds)
                    const blobPromise = response.blob();
                    const timeoutPromise = new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Blob download timeout')), 30000)
                    );
                    
                    blob = await Promise.race([blobPromise, timeoutPromise]);
                    console.log('‚úì Downloaded blob, size:', blob.size, 'type:', blob.type);
                } catch (blobError) {
                    console.error('Blob download failed:', blobError);
                    
                    // If we have a manual URL and blob download failed, try manual URL
                    if (manualUrl && manualUrl !== url) {
                        console.warn('‚ö†Ô∏è Blob download failed on primary URL, trying manual URL...');
                        
                        try {
                            const manualResponse = await fetch(manualUrl, {
                                method: 'GET',
                                mode: 'cors',
                                cache: 'no-cache',
                                headers: {
                                    'Accept': 'application/octet-stream, application/zip, */*'
                                }
                            });
                            
                            console.log('Manual URL response status:', manualResponse.status);
                            
                            if (!manualResponse.ok) {
                                throw new Error(`HTTP ${manualResponse.status}: ${manualResponse.statusText}`);
                            }
                            
                            console.log('Downloading blob from manual URL...');
                            blob = await manualResponse.blob();
                            console.log('‚úì Manual URL blob download succeeded! Size:', blob.size);
                        } catch (manualError) {
                            console.error('Manual URL also failed:', manualError);
                            throw new Error(`Both URLs failed during download. Primary: ${blobError.message}. Manual: ${manualError.message}`);
                        }
                    } else {
                        throw blobError;
                    }
                }
                
                if (blob.size === 0) {
                    throw new Error('Downloaded file is empty (0 bytes)');
                }
                
                // Convert blob to file for consistent handling
                const file = new File([blob], 'project.stlproject', { type: 'application/zip' });
                
                // Load using existing logic
                const zip = await JSZip.loadAsync(file);
                console.log('ZIP loaded successfully');
                
                // Read project configuration
                const projectJsonFile = zip.file("project.json");
                if (!projectJsonFile) {
                    throw new Error('Invalid project file - missing project.json');
                }

                const projectJsonText = await projectJsonFile.async("text");
                const projectData = JSON.parse(projectJsonText);
                console.log('Project data:', projectData);

                // Validate project data
                if (!projectData.parts || projectData.parts.length === 0) {
                    throw new Error('Project has no parts');
                }

                // Clear existing parts
                clearAllSilent();

                // Set project name
                document.getElementById('project-name').value = projectData.projectName;
                currentProjectName = projectData.projectName;
                hasUnsavedChanges = false; // Fresh project load
                
                // Check if this is a GitHub project (loaded via GitHub browser)
                if (currentFolderLicense) {
                    setAsGitHubProject(currentFolderLicense);
                    console.log('üìÇ GitHub project detected - name locked, license will be embedded on save');
                } else {
                    clearGitHubProjectStatus();
                }
                
                resetGitHubFolderState(); // Clear any GitHub folder state
                updateProjectDisplay();

                // Determine if project is encrypted
                const isProtected = projectData.protected === true;
                const folderName = isProtected ? "data" : "stl_files";
                const encryptionKey = isProtected ? generateEncryptionKey(projectData.projectName) : null;

                // Load STL files
                const stlFolder = zip.folder(folderName);
                if (!stlFolder) {
                    throw new Error(`Invalid project file - missing ${folderName} folder`);
                }
                
                console.log(`Loading ${projectData.parts.length} parts... ${isProtected ? '(encrypted)' : '(unencrypted)'}`);
                
                const loadedParts = [];
                const failedParts = [];

                // Load parts sequentially
                for (const partData of projectData.parts) {
                    try {
                        console.log(`Loading part: ${partData.name} (${partData.fileName})`);
                        
                        const stlFile = stlFolder.file(partData.fileName);
                        if (!stlFile) {
                            console.warn(`STL file not found: ${partData.fileName}`);
                            failedParts.push(partData.name);
                            continue;
                        }
                        
                        let arrayBuffer = await stlFile.async("arraybuffer");
                        
                        // Decrypt if protected
                        if (isProtected) {
                            arrayBuffer = decryptBuffer(arrayBuffer, encryptionKey);
                        }
                        
                        await loadSTLFromBuffer(arrayBuffer, partData, projectData.version || "1.0");
                        loadedParts.push(partData.name);
                        
                    } catch (partErr) {
                        console.error(`Error loading part ${partData.name}:`, partErr);
                        failedParts.push(partData.name);
                    }
                }

                // Restore groups if present
                if (projectData.groups && Array.isArray(projectData.groups)) {
                    groups = projectData.groups.map(g => ({
                        name: g.name,
                        parts: new Set(g.parts),
                        color: g.color || '#ffffff'
                    }));
                    renderGroupSelector();
                    console.log('Groups restored:', groups.length);
                }
                
                // Restore assembly rotation if present
                if (projectData.assemblyRotation) {
                    modelGroup.rotation.set(
                        projectData.assemblyRotation.x,
                        projectData.assemblyRotation.y,
                        projectData.assemblyRotation.z
                    );
                    console.log('Assembly rotation restored:', projectData.assemblyRotation);
                } else {
                    // No rotation saved, reset to default
                    modelGroup.rotation.set(0, 0, 0);
                }
                
                // Display license if present (but not if already shown from GitHub folder)
                console.log('üîç License check:', {
                    'projectData.license exists': !!projectData.license,
                    'licenseAlreadyShown': licenseAlreadyShown
                });
                
                if (projectData.license && !licenseAlreadyShown) {
                    console.log('‚úì License found in project, showing embedded license');
                    setTimeout(() => {
                        showLicense(projectData.license, `${projectData.projectName} - License`);
                        // Reset flag AFTER showing license
                        setTimeout(() => {
                            licenseAlreadyShown = false;
                            console.log('üö© Reset licenseAlreadyShown = false (after showing embedded license)');
                        }, 100);
                    }, 500);
                } else if (projectData.license && licenseAlreadyShown) {
                    console.log('‚ÑπÔ∏è License already shown from GitHub folder, skipping embedded license');
                    // Reset flag after skip (no setTimeout needed)
                    setTimeout(() => {
                        licenseAlreadyShown = false;
                        console.log('üö© Reset licenseAlreadyShown = false (after skipping embedded license)');
                    }, 600);
                } else {
                    // No license at all, reset flag immediately
                    licenseAlreadyShown = false;
                    console.log('üö© Reset licenseAlreadyShown = false (no license in project)');
                }
                
                frameModel();
                
                if (failedParts.length === 0) {
                    showToast(`‚úì Project "${projectData.projectName}" loaded from URL!`);
                } else {
                    showToast(`‚ö†Ô∏è Loaded ${loadedParts.length}/${projectData.parts.length} parts (${failedParts.length} failed)`);
                    console.warn('Failed parts:', failedParts);
                }
                
                // Initialize undo/redo history
                initializeHistory();
                
                // Clear URL input on success
                const urlInput = document.getElementById('project-url-input');
                if (urlInput && !urlParam) urlInput.value = '';
                
                console.log('=== Project Load from URL Complete ===');

            } catch (err) {
                console.error('=== Load Project from URL Error ===');
                console.error('Error:', err);
                console.error('Stack:', err.stack);
                console.error('URL that failed:', url);
                
                let errorMsg = err.message;
                let troubleshootingTips = [];
                
                // Check if this was a large file (>10MB) based on Content-Length
                const isLargeFile = contentLength && parseInt(contentLength) > 10000000;
                const fileSizeMB = contentLength ? (parseInt(contentLength) / 1024 / 1024).toFixed(1) : '?';
                
                // Provide helpful error messages based on error type
                if (err.message.includes('Network error') || err.message.includes('Failed to fetch') || err.message.includes('Blob download')) {
                    if (isLargeFile) {
                        errorMsg = `‚ö†Ô∏è File is too large for browser download (${fileSizeMB} MB)`;
                        troubleshootingTips = [
                            'üéØ RECOMMENDED SOLUTION: Download manually from GitHub',
                            '',
                            'Steps:',
                            '  1. Go to your GitHub repo',
                            '  2. Navigate to the file location',
                            '  3. Click the Download button',
                            '  4. Drag the .stlproject file into Print Palette',
                            '',
                            'üìé Direct link to file:',
                            '  https://github.com/MrBaristaNZ/PrintPalette/blob/main/',
                            '  Projects/Blasters/Leedle%20Dynamics/Paid/',
                            '  Lanka%20II%20-%20Leedle%20Dynamic%20V1.1.stlproject',
                            '',
                            'üí° TIP: Large files (10+ MB) often fail in browser.',
                            '   Manual download is the most reliable method.'
                        ];
                    } else {
                        errorMsg = '‚ö†Ô∏è Cannot load file from GitHub';
                        troubleshootingTips = [
                            '1. The file might be too large - try downloading it manually first',
                            '2. Check if your browser is blocking the download',
                            '3. Disable browser extensions (ad blockers, etc.) temporarily',
                            '4. Try a different browser (Chrome, Firefox, Edge)',
                            '5. Check your antivirus/firewall settings',
                            '6. GitHub may be experiencing issues - try again later'
                        ];
                    }
                } else if (err.message.includes('timeout')) {
                    errorMsg = '‚ö†Ô∏è File download timed out or was interrupted';
                    troubleshootingTips = [
                        '1. The file may be very large - try again with a better connection',
                        '2. Download the .stlproject file manually from GitHub',
                        '3. Use drag & drop to load the downloaded file',
                        '4. Check your internet connection stability',
                        '5. Try again during off-peak hours'
                    ];
                } else if (err.message.includes('Invalid project file')) {
                    errorMsg = '‚ö†Ô∏è File is not a valid .stlproject format';
                } else if (err.message.includes('Project has no parts')) {
                    errorMsg = '‚ö†Ô∏è Project file contains no 3D parts';
                }
                
                showToast(errorMsg);
                
                // Show detailed troubleshooting in console
                if (troubleshootingTips.length > 0) {
                    console.warn('=== Troubleshooting Tips ===');
                    troubleshootingTips.forEach(tip => console.warn(tip));
                    
                    // Parse the URL to show the filename
                    try {
                        const urlObj = new URL(url);
                        const filename = decodeURIComponent(urlObj.pathname.split('/').pop());
                        console.warn('Filename:', filename);
                        
                        // Check for problematic characters
                        if (/[^a-zA-Z0-9._\-\s]/.test(filename)) {
                            console.warn('‚ö†Ô∏è WARNING: Filename contains special characters that may cause issues');
                            console.warn('Problematic characters detected:', filename.match(/[^a-zA-Z0-9._\-\s]/g));
                        }
                        
                        if (filename.includes(' ')) {
                            console.warn('‚ÑπÔ∏è Filename contains spaces - this is usually OK if properly encoded');
                        }
                    } catch (parseErr) {
                        console.error('Could not parse URL for debugging:', parseErr);
                    }
                }
                
                // Show detailed error
                const errorDetail = document.createElement('div');
                errorDetail.style.cssText = 'position: fixed; top: 100px; left: 50%; transform: translateX(-50%); background: rgba(255, 0, 107, 0.95); color: white; padding: 20px; border-radius: 8px; z-index: 10000; max-width: 600px; box-shadow: 0 8px 32px rgba(0,0,0,0.5);';
                
                // Special handling for large files
                let additionalInfo = '';
                if (isLargeFile) {
                    additionalInfo = `
                        <div style="background: rgba(255,255,255,0.15); padding: 15px; border-radius: 6px; margin: 15px 0; border-left: 4px solid #fff;">
                            <strong style="font-size: 16px;">üéØ Recommended Solution:</strong><br><br>
                            <strong>Download manually from GitHub:</strong>
                            <ol style="margin: 10px 0; padding-left: 20px; line-height: 1.8;">
                                <li>Click the button below to open the file on GitHub</li>
                                <li>Click the "Download" button on GitHub</li>
                                <li>Drag the downloaded .stlproject file into Print Palette</li>
                            </ol>
                            <a href="https://github.com/MrBaristaNZ/PrintPalette/blob/main/Projects/Blasters/Leedle%20Dynamics/Paid/Lanka%20II%20-%20Leedle%20Dynamic%20V1.1.stlproject" 
                               target="_blank" 
                               style="display: block; background: white; color: #ff006b; text-decoration: none; padding: 12px; border-radius: 6px; text-align: center; font-weight: bold; margin: 10px 0; transition: all 0.3s;"
                               onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.3)';"
                               onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none';">
                                üìÇ Open File on GitHub
                            </a>
                            <div style="font-size: 13px; opacity: 0.9; margin-top: 10px;">
                                üí° <strong>Why?</strong> Large files (${fileSizeMB}+ MB) often fail in browser downloads. Manual download is more reliable.
                            </div>
                        </div>
                    `;
                } else {
                    additionalInfo = `
                        <div style="font-size: 11px; opacity: 0.9; margin: 10px 0;">
                            <strong>For GitHub files:</strong><br>
                            Use "raw" URL format:<br>
                            <code style="background: rgba(0,0,0,0.3); padding: 4px; border-radius: 3px; display: block; margin: 4px 0;">
                            https://raw.githubusercontent.com/<br>username/repo/branch/file.stlproject
                            </code>
                        </div>
                    `;
                }
                
                errorDetail.innerHTML = `
                    <strong style="font-size: 18px;">Load from URL Error:</strong><br><br>
                    <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 4px; margin: 10px 0; word-break: break-all;">
                        ${errorMsg}
                    </div>
                    ${additionalInfo}
                    <small style="opacity: 0.8;">Check console (F12) for detailed error information</small><br><br>
                    <button onclick="this.parentElement.remove()" style="width: 100%; margin-top: 10px; padding: 10px; background: white; color: #ff006b; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 14px;">Close</button>
                `;
                document.body.appendChild(errorDetail);
                setTimeout(() => errorDetail.remove(), 30000); // Extended to 30s for large file instructions
            }
        }
        
        // Check URL parameters on page load for auto-loading
        function checkURLParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const projectURL = urlParams.get('project');
            
            if (projectURL) {
                console.log('Auto-loading project from URL parameter:', projectURL);
                // Wait a bit for page to fully load
                setTimeout(() => {
                    loadProjectFromURL(projectURL);
                }, 1000);
            }
        }
        
        // GitHub Repository Browser Functions
        function getGitHubSettings() {
            return {
                owner: localStorage.getItem('github-owner') || document.getElementById('github-owner')?.value || 'MrBaristaNZ',
                repo: localStorage.getItem('github-repo') || document.getElementById('github-repo')?.value || 'printpalette',
                path: localStorage.getItem('github-path') || document.getElementById('github-path')?.value || 'Projects'
            };
        }
        
        function saveGitHubSettings() {
            const owner = document.getElementById('github-owner').value.trim();
            const repo = document.getElementById('github-repo').value.trim();
            const path = document.getElementById('github-path').value.trim();
            
            if (!owner || !repo) {
                showToast('‚ö†Ô∏è Owner and Repository are required');
                return;
            }
            
            localStorage.setItem('github-owner', owner);
            localStorage.setItem('github-repo', repo);
            localStorage.setItem('github-path', path);
            
            showToast('‚úì Settings saved');
            refreshGitHubBrowser();
        }
        
        async function testGitHubPath() {
            const owner = document.getElementById('github-owner').value.trim();
            const repo = document.getElementById('github-repo').value.trim();
            const path = document.getElementById('github-path').value.trim();
            
            if (!owner || !repo) {
                showToast('‚ö†Ô∏è Owner and Repository are required');
                return;
            }
            
            console.log('=== Testing GitHub Path ===');
            console.log('Owner:', owner);
            console.log('Repo:', repo);
            console.log('Path:', path);
            
            // Encode path properly
            const pathSegments = path ? path.split('/').map(seg => encodeURIComponent(seg.trim())) : [];
            const encodedPath = pathSegments.join('/');
            
            const apiUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${encodedPath}`;
            console.log('Full API URL:', apiUrl);
            
            showToast('üß™ Testing path...');
            
            try {
                const response = await fetch(apiUrl, {
                    headers: {
                        'Accept': 'application/vnd.github.v3+json'
                    }
                });
                
                console.log('Response status:', response.status);
                console.log('Response headers:', response.headers);
                
                if (response.status === 200) {
                    const data = await response.json();
                    const fileCount = Array.isArray(data) ? data.length : 1;
                    const stlProjects = Array.isArray(data) ? data.filter(f => f.name.endsWith('.stlproject')).length : 0;
                    
                    console.log('Success! Found', fileCount, 'items');
                    console.log('STL projects:', stlProjects);
                    
                    showToast(`‚úì Path works! Found ${fileCount} files (${stlProjects} .stlproject)`);
                    
                    // Show detailed info
                    const infoDiv = document.createElement('div');
                    infoDiv.style.cssText = 'position: fixed; top: 100px; left: 50%; transform: translateX(-50%); background: rgba(0, 255, 136, 0.95); color: white; padding: 20px; border-radius: 8px; z-index: 10000; max-width: 500px; box-shadow: 0 8px 32px rgba(0,0,0,0.5);';
                    infoDiv.innerHTML = `
                        <strong style="font-size: 16px;">‚úì Path Test Successful!</strong><br><br>
                        <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 4px; font-size: 11px; font-family: monospace;">
                            ${owner}/${repo}/${path}
                        </div><br>
                        <strong>Found:</strong> ${fileCount} total files<br>
                        <strong>.stlproject files:</strong> ${stlProjects}<br><br>
                        ${stlProjects > 0 ? '‚úÖ Ready to use! Click "Save & Refresh"' : '‚ö†Ô∏è No .stlproject files in this folder'}
                        <br><br>
                        <button onclick="this.parentElement.remove()" style="width: 100%; padding: 10px; background: white; color: #00ff88; border: none; border-radius: 6px; cursor: pointer; font-weight: bold;">Close</button>
                    `;
                    document.body.appendChild(infoDiv);
                    setTimeout(() => infoDiv.remove(), 10000);
                    
                } else if (response.status === 404) {
                    const errorData = await response.json().catch(() => ({}));
                    console.error('404 error:', errorData);
                    
                    showToast('‚ùå Path not found');
                    
                    // Show help
                    const helpDiv = document.createElement('div');
                    helpDiv.style.cssText = 'position: fixed; top: 100px; left: 50%; transform: translateX(-50%); background: rgba(255, 0, 107, 0.95); color: white; padding: 20px; border-radius: 8px; z-index: 10000; max-width: 500px; box-shadow: 0 8px 32px rgba(0,0,0,0.5);';
                    helpDiv.innerHTML = `
                        <strong style="font-size: 16px;">‚ùå Path Not Found</strong><br><br>
                        <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 4px; font-size: 11px; font-family: monospace; word-break: break-all;">
                            ${apiUrl}
                        </div><br>
                        <strong>Possible issues:</strong><br>
                        ‚Ä¢ Owner/repo name wrong<br>
                        ‚Ä¢ Folder path wrong (case-sensitive!)<br>
                        ‚Ä¢ Folder doesn't exist<br>
                        ‚Ä¢ Repository is private<br><br>
                        <strong>How to find correct path:</strong><br>
                        1. Open your repo on GitHub<br>
                        2. Navigate to the folder<br>
                        3. Look at URL: <code style="background: rgba(0,0,0,0.3); padding: 2px 4px; border-radius: 3px;">.../tree/main/YOUR/PATH</code><br>
                        4. Copy "YOUR/PATH" part<br><br>
                        <button onclick="this.parentElement.remove()" style="width: 100%; padding: 10px; background: white; color: #ff006b; border: none; border-radius: 6px; cursor: pointer; font-weight: bold;">Close</button>
                    `;
                    document.body.appendChild(helpDiv);
                    setTimeout(() => helpDiv.remove(), 20000);
                    
                } else {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
            } catch (error) {
                console.error('Test failed:', error);
                showToast('‚ùå Test failed: ' + error.message);
            }
            
            console.log('=== Test Complete ===');
        }
        
        function loadGitHubSettings() {
            const settings = getGitHubSettings();
            
            const ownerInput = document.getElementById('github-owner');
            const repoInput = document.getElementById('github-repo');
            const pathInput = document.getElementById('github-path');
            
            if (ownerInput) ownerInput.value = settings.owner;
            if (repoInput) repoInput.value = settings.repo;
            if (pathInput) pathInput.value = settings.path;
            
            // Update info display
            const infoSpan = document.getElementById('github-repo-info');
            if (infoSpan) {
                infoSpan.textContent = `${settings.owner}/${settings.repo}/${settings.path}`;
            }
        }
        
        // Recursively find all .stlproject files in GitHub repository
        async function findAllProjectsRecursive(owner, repo, path, depth = 0, maxDepth = 5) {
            // Prevent infinite recursion
            if (depth > maxDepth) {
                console.warn(`Max depth ${maxDepth} reached at path: ${path}`);
                return [];
            }
            
            const projects = [];
            
            try {
                // Encode path properly
                const pathSegments = path.split('/').filter(s => s).map(seg => encodeURIComponent(seg.trim()));
                const encodedPath = pathSegments.join('/');
                
                const apiUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${encodedPath}`;
                console.log(`Searching at depth ${depth}: ${path}`);
                
                const response = await fetch(apiUrl, {
                    headers: { 'Accept': 'application/vnd.github.v3+json' }
                });
                
                if (!response.ok) {
                    console.warn(`Failed to fetch ${path}: ${response.status}`);
                    return [];
                }
                
                const items = await response.json();
                
                if (!Array.isArray(items)) return [];
                
                // Find LICENSE.txt in current folder
                const licenseFile = items.find(item => 
                    item.type === 'file' && 
                    (item.name.toLowerCase() === 'license.txt' || item.name.toLowerCase() === 'license')
                );
                
                let folderLicense = null;
                if (licenseFile) {
                    try {
                        const licenseResponse = await fetch(licenseFile.download_url);
                        if (licenseResponse.ok) {
                            folderLicense = await licenseResponse.text();
                            console.log(`‚úì License found in: ${path}`);
                        }
                    } catch (err) {
                        console.error(`Error fetching license from ${path}:`, err);
                    }
                }
                
                // Process items in current folder
                for (const item of items) {
                    if (item.type === 'file' && item.name.toLowerCase().endsWith('.stlproject')) {
                        // Found a project file
                        
                        // Get download URL from GitHub API
                        const apiDownloadUrl = item.download_url;
                        
                        // Also construct manual download URL as backup
                        // Format: https://raw.githubusercontent.com/{owner}/{repo}/{branch}/{path}/{filename}
                        const encodedPath = path ? path.split('/').map(encodeURIComponent).join('/') + '/' : '';
                        const encodedFilename = encodeURIComponent(item.name);
                        const manualDownloadUrl = `https://raw.githubusercontent.com/${owner}/${repo}/main/${encodedPath}${encodedFilename}`;
                        
                        console.log(`‚úì Found project: ${item.name} in ${path}`);
                        console.log(`  API URL: ${apiDownloadUrl}`);
                        console.log(`  Manual URL: ${manualDownloadUrl}`);
                        console.log(`  URLs match: ${apiDownloadUrl === manualDownloadUrl}`);
                        
                        projects.push({
                            name: item.name,
                            downloadUrl: apiDownloadUrl,
                            manualUrl: manualDownloadUrl, // Store both
                            folderPath: path,
                            license: folderLicense,
                            displayName: path ? `${path}/${item.name}` : item.name
                        });
                    } else if (item.type === 'dir') {
                        // Recursively search subdirectory
                        const subPath = path ? `${path}/${item.name}` : item.name;
                        const subProjects = await findAllProjectsRecursive(owner, repo, subPath, depth + 1, maxDepth);
                        projects.push(...subProjects);
                    }
                }
                
            } catch (error) {
                console.error(`Error searching ${path}:`, error);
            }
            
            return projects;
        }
        
        async function refreshGitHubProjects() {
            const dropdown = document.getElementById('github-project-dropdown');
            const settings = getGitHubSettings();
            
            if (!dropdown) return;
            
            // Clear dropdown
            dropdown.innerHTML = '<option value="">Loading...</option>';
            dropdown.disabled = true;
            
            console.log('=== Fetching GitHub Projects (Recursive) ===');
            console.log('Settings:', settings);
            console.log('Starting path:', settings.path);
            
            try {
                // Recursively search for all .stlproject files
                const allProjects = await findAllProjectsRecursive(
                    settings.owner,
                    settings.repo,
                    settings.path,
                    0, // start depth
                    5  // max depth
                );
                
                console.log('Total projects found:', allProjects.length);
                console.log('Projects:', allProjects.map(p => p.displayName));
                
                // Store for later use
                currentFolderPath = settings.path;
                
                // Populate dropdown
                dropdown.innerHTML = '<option value="">Select a project...</option>';
                
                if (allProjects.length === 0) {
                    dropdown.innerHTML += `<option value="" disabled>No .stlproject files found in "${settings.path}" or subfolders</option>`;
                    showToast(`‚ö†Ô∏è No projects found in this folder tree`);
                } else {
                    // Group projects by folder
                    const projectsByFolder = {};
                    allProjects.forEach(project => {
                        if (!projectsByFolder[project.folderPath]) {
                            projectsByFolder[project.folderPath] = [];
                        }
                        projectsByFolder[project.folderPath].push(project);
                    });
                    
                    // Add projects grouped by folder
                    const folders = Object.keys(projectsByFolder).sort();
                    folders.forEach(folder => {
                        // Add folder separator
                        if (folders.length > 1) {
                            const folderLabel = folder || '(root)';
                            const optgroup = document.createElement('optgroup');
                            optgroup.label = `üìÅ ${folderLabel}`;
                            dropdown.appendChild(optgroup);
                        }
                        
                        // Add projects in this folder
                        projectsByFolder[folder].forEach(project => {
                            const option = document.createElement('option');
                            option.value = project.downloadUrl;
                            option.textContent = project.name.replace('.stlproject', '');
                            
                            // Store manual URL as backup
                            if (project.manualUrl) {
                                option.setAttribute('data-manual-url', project.manualUrl);
                            }
                            
                            // Store license and folder path as data attributes
                            if (project.license) {
                                option.setAttribute('data-license', project.license);
                            }
                            option.setAttribute('data-folder-path', project.folderPath);
                            
                            if (folders.length > 1) {
                                // Append to optgroup
                                dropdown.lastChild.appendChild(option);
                            } else {
                                // Append directly
                                dropdown.appendChild(option);
                            }
                        });
                    });
                    
                    // Count folders with licenses
                    const foldersWithLicenses = allProjects.filter(p => p.license).length;
                    const licenseMsg = foldersWithLicenses > 0 ? ` (üìÑ ${foldersWithLicenses} with license)` : '';
                    showToast(`‚úì Found ${allProjects.length} project(s)${licenseMsg}`);
                }
                
                dropdown.disabled = false;
                
                // Update info display
                updateGitHubBrowserInfo();
                
                console.log('=== GitHub Fetch Complete ===');
                
            } catch (error) {
                console.error('=== Error fetching GitHub projects ===');
                console.error('Error:', error);
                console.error('Message:', error.message);
                console.error('Stack:', error.stack);
                
                dropdown.innerHTML = '<option value="">Error - Check settings</option>';
                dropdown.disabled = false;
                
                showToast('‚ö†Ô∏è ' + error.message.split('\n')[0]);
                
                // Update info display
                const infoSpan = document.getElementById('github-repo-info');
                if (infoSpan) {
                    infoSpan.innerHTML = `<span style="color: var(--accent-magenta);">‚úó</span> Error - Check console (F12)`;
                }
            }
        }
        
        // NEW: GitHub Folder Browser Functions
        async function refreshGitHubBrowser() {
            const settings = getGitHubSettings();
            githubBrowserCurrentPath = settings.path;
            githubBrowserCache = {};
            
            console.log('Refreshing GitHub browser, starting at:', githubBrowserCurrentPath);
            await navigateToFolder(githubBrowserCurrentPath);
        }
        
        async function navigateToFolder(path) {
            githubBrowserCurrentPath = path;
            console.log('Navigating to folder:', path);
            
            // Update breadcrumb
            renderBreadcrumb(path);
            
            // Show loading
            const listDiv = document.getElementById('github-browser-list');
            if (!listDiv) return;
            listDiv.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-secondary); font-size: 11px;">Loading...</div>';
            
            try {
                const settings = getGitHubSettings();
                
                // Fetch folder contents
                const contents = await fetchGitHubFolderContents(
                    settings.owner,
                    settings.repo,
                    path
                );
                
                // Cache results
                githubBrowserCache[path] = contents;
                
                // Render folder list
                renderFolderList(contents, path);
                
                // Update info
                updateGitHubBrowserInfo();
                
            } catch (error) {
                console.error('Error navigating to folder:', error);
                listDiv.innerHTML = `<div style="padding: 20px; text-align: center; color: var(--accent-magenta); font-size: 11px;">Error: ${error.message}</div>`;
                showToast('‚ö†Ô∏è ' + error.message);
            }
        }
        
        async function fetchGitHubFolderContents(owner, repo, path) {
            const url = `https://api.github.com/repos/${owner}/${repo}/contents/${path}`;
            console.log('Fetching:', url);
            
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`GitHub API error: ${response.status} ${response.statusText}`);
            }
            
            const data = await response.json();
            
            // Separate folders and files
            const folders = data.filter(item => item.type === 'dir').sort((a, b) => a.name.localeCompare(b.name));
            const files = data.filter(item => item.type === 'file').sort((a, b) => a.name.localeCompare(b.name));
            
            // Find LICENSE.txt
            const licenseFile = files.find(f => f.name.toLowerCase() === 'license.txt');
            let licenseText = null;
            
            if (licenseFile) {
                console.log('‚úì LICENSE.txt found in', path);
                try {
                    const licenseResponse = await fetch(licenseFile.download_url);
                    licenseText = await licenseResponse.text();
                } catch (err) {
                    console.error('Failed to fetch license:', err);
                }
            }
            
            // Store license for this folder
            currentFolderPath = path;
            currentFolderLicense = licenseText;
            
            // Filter .stlproject files
            const projects = files.filter(f => f.name.toLowerCase().endsWith('.stlproject'));
            
            return { folders, projects, license: licenseText };
        }
        
        function renderBreadcrumb(path) {
            const breadcrumbDiv = document.getElementById('github-breadcrumb');
            if (!breadcrumbDiv) return;
            
            const settings = getGitHubSettings();
            const parts = path.split('/').filter(p => p);
            const rootPath = settings.path;
            
            let html = '';
            let currentPath = '';
            
            // Home button (root)
            html += `<span onclick="navigateToFolder('${rootPath}')" style="cursor: pointer; padding: 4px 8px; background: rgba(138, 85, 247, 0.2); border-radius: 4px; font-size: 10px; color: var(--accent-purple); font-family: 'Azeret Mono', monospace; transition: background 0.2s;" onmouseover="this.style.background='rgba(138, 85, 247, 0.4)'" onmouseout="this.style.background='rgba(138, 85, 247, 0.2)'">üè† Root</span>`;
            
            // Build path segments
            parts.forEach((part, index) => {
                currentPath += (currentPath ? '/' : '') + part;
                const isLast = index === parts.length - 1;
                
                html += '<span style="color: var(--text-secondary); margin: 0 4px;">/</span>';
                
                if (isLast) {
                    // Current folder (not clickable)
                    html += `<span style="padding: 4px 8px; background: rgba(0, 245, 255, 0.2); border-radius: 4px; font-size: 10px; color: var(--accent-cyan); font-family: 'Azeret Mono', monospace; font-weight: 600;">üìÅ ${part}</span>`;
                } else {
                    // Clickable parent folder
                    html += `<span onclick="navigateToFolder('${currentPath}')" style="cursor: pointer; padding: 4px 8px; background: rgba(0, 245, 255, 0.1); border-radius: 4px; font-size: 10px; color: var(--accent-cyan); font-family: 'Azeret Mono', monospace; transition: background 0.2s;" onmouseover="this.style.background='rgba(0, 245, 255, 0.3)'" onmouseout="this.style.background='rgba(0, 245, 255, 0.1)'">üìÅ ${part}</span>`;
                }
            });
            
            breadcrumbDiv.innerHTML = html;
        }
        
        function renderFolderList(contents, path) {
            const listDiv = document.getElementById('github-browser-list');
            if (!listDiv) return;
            
            let html = '';
            
            // Add folders
            if (contents.folders.length > 0) {
                contents.folders.forEach(folder => {
                    const folderPath = path + '/' + folder.name;
                    html += `
                        <div onclick="navigateToFolder('${folderPath}')" style="
                            padding: 10px 12px;
                            border-bottom: 1px solid var(--border);
                            cursor: pointer;
                            transition: background 0.2s;
                            display: flex;
                            align-items: center;
                            gap: 8px;
                        " onmouseover="this.style.background='rgba(138, 85, 247, 0.1)'" onmouseout="this.style.background='transparent'">
                            <span style="font-size: 14px;">üìÅ</span>
                            <span style="font-size: 11px; font-family: 'Rajdhani', sans-serif; color: var(--text-primary); font-weight: 600;">${folder.name}</span>
                        </div>
                    `;
                });
            }
            
            // Add projects
            if (contents.projects.length > 0) {
                contents.projects.forEach(project => {
                    const projectName = project.name.replace('.stlproject', '');
                    const hasLicense = contents.license !== null;
                    html += `
                        <div onclick="loadGitHubProject('${project.download_url}', '${projectName}')" style="
                            padding: 10px 12px;
                            border-bottom: 1px solid var(--border);
                            cursor: pointer;
                            transition: background 0.2s;
                            display: flex;
                            align-items: center;
                            gap: 8px;
                        " onmouseover="this.style.background='rgba(0, 245, 255, 0.1)'" onmouseout="this.style.background='transparent'">
                            <span style="font-size: 14px;">üéØ</span>
                            <span style="flex: 1; font-size: 11px; font-family: 'Rajdhani', sans-serif; color: var(--accent-cyan); font-weight: 600;">${projectName}</span>
                            ${hasLicense ? '<span style="font-size: 10px; color: var(--accent-yellow);">üìÑ</span>' : ''}
                        </div>
                    `;
                });
            }
            
            // Empty state
            if (contents.folders.length === 0 && contents.projects.length === 0) {
                html = '<div style="padding: 20px; text-align: center; color: var(--text-secondary); font-size: 11px;">üì≠ This folder is empty</div>';
            }
            
            // License indicator
            if (contents.license) {
                html = `<div style="padding: 8px 12px; background: rgba(255, 193, 7, 0.1); border-bottom: 2px solid var(--accent-yellow); font-size: 10px; color: var(--accent-yellow); font-family: 'Azeret Mono', monospace;">üìÑ LICENSE.txt found in this folder</div>` + html;
            }
            
            listDiv.innerHTML = html;
        }
        
        async function loadGitHubProject(url, name) {
            console.log('=== Loading GitHub Project ===');
            console.log('Project URL:', url);
            console.log('Project Name:', name);
            
            // Check for unsaved changes first
            if (hasUnsavedChanges && parts.length > 0) {
                const projectName = currentProjectName || 'Current Project';
                const message = `You have unsaved changes in "${projectName}".\n\nClick OK to SAVE first, or Cancel to DISCARD and load "${name}".`;
                
                const saveFirst = confirm(message);
                
                if (saveFirst) {
                    // Save first
                    await saveProject();
                    const continueLoad = confirm('Project saved! Continue loading new project?');
                    if (!continueLoad) return;
                }
                
                // Will reset state when loading completes
                hasUnsavedChanges = false;
            }
            
            // Check if current folder has a license
            if (currentFolderLicense && currentFolderPath) {
                console.log('‚úì LICENSE.txt found in GitHub folder');
                console.log('License length:', currentFolderLicense.length, 'characters');
                console.log('Showing license modal before loading...');
                
                // Store URL for after license acceptance
                pendingProjectUrl = url;
                console.log('‚úì Stored pending project URL:', pendingProjectUrl);
                
                // Mark that we're showing license (to prevent double-show after load)
                licenseAlreadyShown = true;
                console.log('üö© Set licenseAlreadyShown = true (to prevent double-show)');
                
                // Show license modal
                showLicense(currentFolderLicense, `${name} - License Agreement`);
            } else {
                // No license, load directly
                console.log('No license in folder, loading project directly');
                licenseAlreadyShown = false;
                loadProjectFromURL(url);
            }
        }
        
        
        function loadSelectedGitHubProject() {
            const dropdown = document.getElementById('github-project-dropdown');
            const url = dropdown ? dropdown.value : '';
            
            if (!url) return;
            
            console.log('=== Loading GitHub Project ===');
            console.log('Project URL:', url);
            
            // Get project name, license, and manual URL from dropdown
            const selectedOption = dropdown.options[dropdown.selectedIndex];
            const projectName = selectedOption ? selectedOption.textContent : 'Project';
            const projectLicense = selectedOption ? selectedOption.getAttribute('data-license') : null;
            const folderPath = selectedOption ? selectedOption.getAttribute('data-folder-path') : '';
            const manualUrl = selectedOption ? selectedOption.getAttribute('data-manual-url') : null;
            
            console.log('Project name:', projectName);
            console.log('Folder path:', folderPath);
            console.log('Has license:', !!projectLicense);
            console.log('Manual URL:', manualUrl);
            
            // Store for license modal
            currentFolderLicense = projectLicense;
            currentFolderPath = folderPath;
            
            // If LICENSE.txt exists for this project, show it before loading
            if (currentFolderLicense) {
                console.log('‚úì LICENSE.txt found in GitHub folder');
                console.log('Showing license modal before loading...');
                
                // Store the URL to load after license acceptance
                pendingProjectUrl = url;
                pendingManualUrl = manualUrl;
                console.log('‚úì Stored pending project URL:', url);
                console.log('‚úì Stored pending manual URL:', manualUrl);
                
                // Mark that we're showing license (to prevent double-show after load)
                licenseAlreadyShown = true;
                console.log('üö© Set licenseAlreadyShown = true (to prevent double-show)');
                
                // Show license modal
                showLicense(currentFolderLicense, `${projectName} - License Agreement`);
            } else {
                // No license, load directly
                licenseAlreadyShown = false;
                loadProjectFromURL(url, manualUrl);
            }
            
            // Reset dropdown selection
            setTimeout(() => {
                if (dropdown) dropdown.value = '';
            }, 500);
        }
        
        // Initialize GitHub browser on page load
        function initGitHubBrowser() {
            loadGitHubSettings();
            refreshGitHubBrowser();
        }

        function loadSTLFromBuffer(arrayBuffer, partData, projectVersion = "1.0") {
            return new Promise((resolve, reject) => {
                try {
                    console.log(`Loading STL buffer for ${partData.name}, size: ${arrayBuffer.byteLength} bytes`);
                    
                    // Validate the arrayBuffer
                    if (!arrayBuffer || arrayBuffer.byteLength === 0) {
                        throw new Error(`Invalid or empty STL data for ${partData.name}`);
                    }
                    
                    // Parse the STL geometry
                    const geometry = loader.parse(arrayBuffer);
                    
                    if (!geometry || !geometry.attributes || !geometry.attributes.position) {
                        throw new Error(`Failed to parse STL geometry for ${partData.name}`);
                    }
                    
                    console.log(`Geometry loaded: ${geometry.attributes.position.count} vertices`);
                    
                    // Center geometry for version 1.1+ (enables rotation on the spot)
                    // Keep uncentered for version 1.0 (maintains exact original positions)
                    const shouldCenter = projectVersion !== "1.0";
                    let centerOffset = { x: 0, y: 0, z: 0 };
                    
                    if (shouldCenter) {
                        // v1.1: Center the geometry
                        const offset = new THREE.Vector3();
                        geometry.computeBoundingBox();
                        geometry.boundingBox.getCenter(offset);
                        console.log(`Geometry center BEFORE centering for ${partData.name}:`, offset);
                        geometry.center();
                        centerOffset = { x: offset.x, y: offset.y, z: offset.z };
                        console.log(`Geometry centered for ${partData.name}, offset:`, centerOffset);
                    } else {
                        // v1.0: Don't center, but calculate offset for when we save as v1.1
                        const offset = new THREE.Vector3();
                        geometry.computeBoundingBox();
                        geometry.boundingBox.getCenter(offset);
                        centerOffset = { x: offset.x, y: offset.y, z: offset.z };
                        console.log(`v1.0 part ${partData.name} - keeping uncentered, centerOffset:`, centerOffset);
                    }
                    
                    const material = new THREE.MeshStandardMaterial({
                        color: partData.color,
                        metalness: 0.3,
                        roughness: 0.4,
                        flatShading: false
                    });
                    
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.userData = {
                        name: partData.name,
                        visible: partData.visible !== undefined ? partData.visible : true,
                        color: partData.color,
                        position: partData.position || { x: 0, y: 0, z: 0 },
                        rotation: partData.rotation || { x: 0, y: 0, z: 0 },
                        locked: partData.locked || false,
                        centerOffset: centerOffset
                    };

                    // Apply transformations
                    if (shouldCenter) {
                        // v1.1: geometry is centered, use logical + offset
                        mesh.position.set(
                            mesh.userData.position.x + centerOffset.x,
                            mesh.userData.position.y + centerOffset.y,
                            mesh.userData.position.z + centerOffset.z
                        );
                        console.log(`Applied position for ${partData.name} (v1.1):`, 
                            `logical=(${mesh.userData.position.x},${mesh.userData.position.y},${mesh.userData.position.z})`,
                            `+ offset=(${centerOffset.x},${centerOffset.y},${centerOffset.z})`,
                            `= render=(${mesh.position.x},${mesh.position.y},${mesh.position.z})`);
                    } else {
                        // v1.0: geometry is NOT centered, use absolute position directly
                        mesh.position.set(
                            mesh.userData.position.x,
                            mesh.userData.position.y,
                            mesh.userData.position.z
                        );
                        console.log(`Applied position for ${partData.name} (v1.0):`, 
                            `absolute=(${mesh.userData.position.x},${mesh.userData.position.y},${mesh.userData.position.z})`);
                    }

                    mesh.rotation.set(
                        mesh.userData.rotation.x * (Math.PI / 180),
                        mesh.userData.rotation.y * (Math.PI / 180),
                        mesh.userData.rotation.z * (Math.PI / 180)
                    );

                    mesh.visible = mesh.userData.visible;
                    
                    modelGroup.add(mesh);
                    parts.push(mesh);
                    
                    addPartControl(parts.length - 1);
                    updatePartCount();
                    updateBoundingBox();
                    updateCoordinates(parts.length - 1);

                    // Apply locked state if needed
                    if (mesh.userData.locked) {
                        setTimeout(() => {
                            const lockBtn = document.getElementById(`lock-btn-${parts.length - 1}`);
                            const card = document.getElementById(`part-card-${parts.length - 1}`);
                            if (lockBtn && card) {
                                lockBtn.classList.add('locked');
                                lockBtn.textContent = 'üîí';
                                card.classList.add('locked');
                            }
                        }, 100);
                    }
                    
                    // Apply hidden state if needed
                    if (!mesh.userData.visible) {
                        setTimeout(() => {
                            const visBtn = document.getElementById(`vis-btn-${parts.length - 1}`);
                            const card = document.getElementById(`part-card-${parts.length - 1}`);
                            if (visBtn && card) {
                                visBtn.classList.add('hidden-btn');
                                visBtn.classList.remove('visibility');
                                visBtn.textContent = '‚®Ø';
                                card.classList.add('hidden-part');
                            }
                        }, 100);
                    }

                    console.log(`Part ${partData.name} loaded successfully`);
                    resolve();
                    
                } catch (err) {
                    console.error(`Error loading part ${partData.name}:`, err);
                    reject(err);
                }
            });
        }

        function clearAllSilent() {
            console.log('Clearing all parts with proper disposal...');
            
            // Dispose of all parts properly
            parts.forEach(part => {
                // Remove from scene first
                modelGroup.remove(part);
                
                // Dispose geometry
                if (part.geometry) {
                    part.geometry.dispose();
                }
                
                // Dispose material and textures
                if (part.material) {
                    if (part.material.map) part.material.map.dispose();
                    if (part.material.lightMap) part.material.lightMap.dispose();
                    if (part.material.bumpMap) part.material.bumpMap.dispose();
                    if (part.material.normalMap) part.material.normalMap.dispose();
                    if (part.material.specularMap) part.material.specularMap.dispose();
                    if (part.material.envMap) part.material.envMap.dispose();
                    part.material.dispose();
                }
            });
            
            // Clear arrays completely
            parts.length = 0;
            partFiles = {};
            selectedParts.clear();
            groups.length = 0;
            selectedGroup = null;
            
            // Reset project name
            const projectNameInput = document.getElementById('project-name');
            if (projectNameInput) {
                projectNameInput.value = 'Untitled Project';
            }
            
            // Note: Don't reset GitHub/license state here
            // That's handled by the load functions or clearAll()
            // This keeps clearAllSilent focused on just clearing the scene
            
            // Rebuild UI
            rebuildUI();
            updatePartCount();
            updateBoundingBox();
            renderGroupSelector();
            
            console.log('All parts cleared and memory freed');
        }

        // Part Selection for Group Creation
        function togglePartSelection(index) {
            console.log('Toggle part selection:', index);
            
            const checkbox = document.getElementById(`checkbox-${index}`);
            const card = document.getElementById(`part-card-${index}`);
            
            if (!checkbox || !card) {
                console.error('Could not find checkbox or card!');
                return;
            }
            
            // If a group is selected, manage group membership
            if (selectedGroup) {
                if (selectedGroup.parts.has(index)) {
                    // Remove from group
                    selectedGroup.parts.delete(index);
                    checkbox.classList.remove('checked');
                    checkbox.textContent = '';
                    card.classList.remove('selected');
                    showToast(`‚úì Removed from "${selectedGroup.name}"`);
                } else {
                    // Add to group
                    selectedGroup.parts.add(index);
                    checkbox.classList.add('checked');
                    checkbox.textContent = '‚úì';
                    card.classList.add('selected');
                    
                    // Apply group color if it has one
                    if (selectedGroup.color && parts[index]) {
                        animatePartColorChange(parts[index], selectedGroup.color);
                        parts[index].userData.color = selectedGroup.color;
                        
                        // Update dropdown
                        const colorDropdown = document.getElementById(`part-color-dropdown-${index}`);
                        if (colorDropdown) {
                            colorDropdown.value = selectedGroup.color;
                            colorDropdown.style.backgroundColor = selectedGroup.color;
                            colorDropdown.style.color = '#fff';
                            colorDropdown.style.borderColor = selectedGroup.color;
                            colorDropdown.style.borderWidth = '2px';
                        }
                    }
                    
                    showToast(`‚úì Added to "${selectedGroup.name}"`);
                }
                
                // Update group selector to show new part count
                renderGroupSelector();
                
                console.log('Group updated:', selectedGroup.name, 'Parts:', Array.from(selectedGroup.parts));
            } else {
                // No group selected - normal selection for creating new group
                if (selectedParts.has(index)) {
                    selectedParts.delete(index);
                    checkbox.classList.remove('checked');
                    checkbox.textContent = '';
                    card.classList.remove('selected');
                } else {
                    selectedParts.add(index);
                    checkbox.classList.add('checked');
                    checkbox.textContent = '‚úì';
                    card.classList.add('selected');
                }
                
                console.log('Selected parts:', Array.from(selectedParts));
            }
        }

        // Group Management Functions
        function createGroup() {
            const nameInput = document.getElementById('new-group-name');
            const name = nameInput.value.trim();
            
            if (!name) {
                showToast('‚ö†Ô∏è Enter a group name first');
                return;
            }
            
            if (selectedParts.size === 0) {
                showToast('‚ö†Ô∏è Select parts first (use checkboxes ‚úì)');
                return;
            }
            
            // Avoid duplicates
            if (groups.some(g => g.name === name)) {
                showToast('‚ö†Ô∏è Group "' + name + '" already exists');
                return;
            }
            
            // Get color from dropdown
            const colorDropdown = document.getElementById('group-color-dropdown');
            const selectedColor = colorDropdown ? colorDropdown.value : '#ffffff';
            
            if (!selectedColor || selectedColor === '') {
                showToast('‚ö†Ô∏è Select a colour from the dropdown first');
                return;
            }
            
            // Create new group with current selection and color
            const groupPartsCount = selectedParts.size;
            groups.push({ 
                name, 
                parts: new Set(selectedParts),
                color: selectedColor
            });
            
            nameInput.value = '';
            
            // Reset dropdown appearance
            if (colorDropdown) {
                colorDropdown.value = '';
                colorDropdown.style.backgroundColor = 'var(--bg-primary)';
                colorDropdown.style.color = 'var(--text-primary)';
                colorDropdown.style.borderColor = 'var(--border)';
            }
            
            // Clear selection visually
            selectedParts.forEach(index => {
                const checkbox = document.getElementById(`checkbox-${index}`);
                const card = document.getElementById(`part-card-${index}`);
                if (checkbox) {
                    checkbox.classList.remove('checked');
                    checkbox.textContent = '';
                }
                if (card) {
                    card.classList.remove('selected');
                }
            });
            
            // Store selected parts before clearing
            const partsInNewGroup = Array.from(selectedParts);
            selectedParts.clear();
            
            renderGroupSelector();
            
            showToast(`‚úì Group "${name}" created with ${groupPartsCount} part(s)`);
            
            console.log('Group created:', name, 'Color:', selectedColor);
        }

        function renderGroupSelector() {
            const selector = document.getElementById('group-selector');
            if (!selector) return;
            
            // Remember current selection
            const currentIndex = selector.value;
            
            selector.innerHTML = '<option value="">Select a group...</option>';
            
            groups.forEach((group, i) => {
                const color = group.color || '#ffffff';
                const option = document.createElement('option');
                option.value = i;
                option.textContent = `üî∑ ${group.name} (${group.parts.size} parts)`;
                option.style.color = color;
                option.style.fontWeight = 'bold';
                selector.appendChild(option);
            });
            
            // Restore selection if it was set
            if (selectedGroup && currentIndex !== '') {
                // Find the index of the currently selected group
                const index = groups.findIndex(g => g.name === selectedGroup.name);
                if (index !== -1) {
                    selector.value = index;
                }
            }
            
            console.log('Group selector rendered with', groups.length, 'groups');
        }

        function selectGroup(index) {
            const deleteBtn = document.getElementById('delete-group-btn');
            const colorDropdown = document.getElementById('group-color-dropdown');
            
            if (index === '' || index === null) {
                selectedGroup = null;
                
                // Clear all checkboxes when no group selected
                parts.forEach((part, idx) => {
                    const checkbox = document.getElementById(`checkbox-${idx}`);
                    const card = document.getElementById(`part-card-${idx}`);
                    if (checkbox) {
                        checkbox.classList.remove('checked');
                        checkbox.textContent = '';
                    }
                    if (card) {
                        card.classList.remove('selected');
                    }
                });
                
                // Reset dropdown
                if (colorDropdown) {
                    colorDropdown.value = '';
                    colorDropdown.style.backgroundColor = 'var(--bg-primary)';
                    colorDropdown.style.color = 'var(--text-primary)';
                    colorDropdown.style.borderColor = 'var(--border)';
                    colorDropdown.style.borderWidth = '1px';
                    // Keep dropdown enabled for creating new groups
                }
                
                if (deleteBtn) deleteBtn.disabled = true;
                return;
            }
            
            selectedGroup = groups[parseInt(index)];
            console.log('Group selected:', selectedGroup.name, 'Parts:', Array.from(selectedGroup.parts), 'Color:', selectedGroup.color);
            
            // Check/uncheck parts based on group membership
            parts.forEach((part, idx) => {
                const checkbox = document.getElementById(`checkbox-${idx}`);
                const card = document.getElementById(`part-card-${idx}`);
                
                if (selectedGroup.parts.has(idx)) {
                    // Part is in group - check it
                    if (checkbox) {
                        checkbox.classList.add('checked');
                        checkbox.textContent = '‚úì';
                    }
                    if (card) {
                        card.classList.add('selected');
                    }
                } else {
                    // Part is not in group - uncheck it
                    if (checkbox) {
                        checkbox.classList.remove('checked');
                        checkbox.textContent = '';
                    }
                    if (card) {
                        card.classList.remove('selected');
                    }
                }
            });
            
            // Enable colour dropdown for this group
            if (colorDropdown) {
                colorDropdown.disabled = false;
                
                // Load the group's current colour if it has one
                if (selectedGroup.color) {
                    colorDropdown.value = selectedGroup.color;
                    colorDropdown.style.backgroundColor = selectedGroup.color;
                    colorDropdown.style.color = '#fff';
                    colorDropdown.style.fontWeight = '600';
                    colorDropdown.style.borderColor = selectedGroup.color;
                    colorDropdown.style.borderWidth = '2px';
                } else {
                    // No colour yet - reset to default
                    colorDropdown.value = '';
                    colorDropdown.style.backgroundColor = 'var(--bg-primary)';
                    colorDropdown.style.color = 'var(--text-primary)';
                    colorDropdown.style.borderColor = 'var(--border)';
                    colorDropdown.style.borderWidth = '1px';
                }
            }
            
            // Enable delete button
            if (deleteBtn) {
                deleteBtn.disabled = false;
            }
        }

        function animatePartColorChange(mesh, targetColor, duration = 500) {
            const start = mesh.material.color.clone();
            const end = new THREE.Color(targetColor);
            const startTime = performance.now();

            function animate() {
                const elapsed = performance.now() - startTime;
                const t = Math.min(1, elapsed / duration);
                mesh.material.color.r = start.r + (end.r - start.r) * t;
                mesh.material.color.g = start.g + (end.g - start.g) * t;
                mesh.material.color.b = start.b + (end.b - start.b) * t;

                if (t < 1) requestAnimationFrame(animate);
            }
            animate();
        }

        function applyColorToGroup() {
            if (!selectedGroup) {
                showToast('‚ö†Ô∏è Select a group first');
                return;
            }
            
            const colorDropdown = document.getElementById('group-color-dropdown');
            const selectedColor = colorDropdown ? colorDropdown.value : '#ff006b';
            
            if (!selectedColor || selectedColor === '') {
                showToast('‚ö†Ô∏è Select a colour from the dropdown first');
                return;
            }
            
            console.log('=== Manual Re-apply Color to Group ===');
            console.log('Group:', selectedGroup.name);
            console.log('Color value:', selectedColor);
            
            let successCount = 0;
            
            selectedGroup.parts.forEach(idx => {
                if (parts[idx]) {
                    animatePartColorChange(parts[idx], selectedColor);
                    parts[idx].userData.color = selectedColor;
                    
                    // Update dropdown
                    const dropdown = document.getElementById(`part-color-dropdown-${idx}`);
                    if (dropdown) {
                        dropdown.value = selectedColor;
                        dropdown.style.backgroundColor = selectedColor;
                        dropdown.style.color = '#fff';
                        dropdown.style.borderColor = selectedColor;
                        dropdown.style.borderWidth = '2px';
                    }
                    successCount++;
                }
            });
            
            // Save color to group
            selectedGroup.color = selectedColor;
            renderGroupSelector();
            
            markAsModified(); // Project has been changed
            showToast(`‚úì Re-applied ${selectedColor.toUpperCase()} to "${selectedGroup.name}" (${successCount} parts)`);
            console.log('Color re-applied successfully');
        }

        function updateGroupColorFromDropdown() {
            const dropdown = document.getElementById('group-color-dropdown');
            
            if (!dropdown) {
                console.warn('Colour dropdown not found');
                return;
            }
            
            const color = dropdown.value;
            
            if (!color) {
                // Reset to default when no color selected
                dropdown.style.backgroundColor = 'var(--bg-primary)';
                dropdown.style.color = 'var(--text-primary)';
                dropdown.style.borderColor = 'var(--border)';
                return;
            }

            // Set dropdown background to selected color
            dropdown.style.backgroundColor = color;
            dropdown.style.color = 'white';
            dropdown.style.borderColor = color;
            dropdown.style.borderWidth = '2px';

            // AUTO-APPLY: If a group is selected, apply colour immediately!
            if (selectedGroup) {
                console.log('Auto-applying colour to group:', selectedGroup.name);
                
                let successCount = 0;
                
                // Apply to all parts in the group
                selectedGroup.parts.forEach(idx => {
                    if (parts[idx]) {
                        animatePartColorChange(parts[idx], color);
                        parts[idx].userData.color = color;
                        
                        // Update dropdown
                        const dropdown = document.getElementById(`part-color-dropdown-${idx}`);
                        if (dropdown) {
                            dropdown.value = color;
                            dropdown.style.backgroundColor = color;
                            dropdown.style.color = '#fff';
                            dropdown.style.borderColor = color;
                            dropdown.style.borderWidth = '2px';
                        }
                        successCount++;
                    }
                });
                
                // Save color to group
                selectedGroup.color = color;
                renderGroupSelector();
                
                showToast(`‚úì ${color.toUpperCase()} applied to "${selectedGroup.name}" (${successCount} parts)`);
            }
            
            console.log('Colour selected from dropdown:', color);
        }

        function colorAllGroupsRandomly() {
            if (groups.length === 0) {
                showToast('‚ö†Ô∏è No groups created yet');
                return;
            }
            
            groups.forEach(group => {
                const randomColor = presetColors[Math.floor(Math.random() * presetColors.length)];
                group.color = randomColor;
                
                group.parts.forEach(idx => {
                    if (parts[idx]) {
                        animatePartColorChange(parts[idx], randomColor);
                        parts[idx].userData.color = randomColor;

                        // Update dropdown
                        const dropdown = document.getElementById(`part-color-dropdown-${idx}`);
                        if (dropdown) {
                            dropdown.value = randomColor;
                            dropdown.style.backgroundColor = randomColor;
                            dropdown.style.color = '#fff';
                            dropdown.style.borderColor = randomColor;
                            dropdown.style.borderWidth = '2px';
                        }
                    }
                });
            });
            
            renderGroupSelector();
            showToast('üé≤ All groups coloured randomly!');
            console.log('All groups randomized');
        }

        function deleteGroup() {
            if (!selectedGroup) {
                showToast('‚ö†Ô∏è Select a group first');
                return;
            }
            
            const groupName = selectedGroup.name;
            const index = groups.findIndex(g => g.name === groupName);
            
            if (index !== -1) {
                // Clear checkboxes for parts in this group
                selectedGroup.parts.forEach(partIndex => {
                    const checkbox = document.getElementById(`checkbox-${partIndex}`);
                    const card = document.getElementById(`part-card-${partIndex}`);
                    if (checkbox) {
                        checkbox.classList.remove('checked');
                        checkbox.textContent = '';
                    }
                    if (card) {
                        card.classList.remove('selected');
                    }
                });
                
                groups.splice(index, 1);
                selectedGroup = null;
                renderGroupSelector();
                
                const deleteBtn = document.getElementById('delete-group-btn');
                const colorDropdown = document.getElementById('group-color-dropdown');
                
                if (deleteBtn) deleteBtn.disabled = true;
                if (colorDropdown) {
                    colorDropdown.disabled = true;
                    colorDropdown.value = '';
                    colorDropdown.style.backgroundColor = 'var(--bg-primary)';
                    colorDropdown.style.color = 'var(--text-primary)';
                    colorDropdown.style.borderColor = 'var(--border)';
                    colorDropdown.style.borderWidth = '1px';
                }
                
                // Reset group selector
                const selector = document.getElementById('group-selector');
                if (selector) selector.value = '';
                
                showToast(`üóë Group "${groupName}" deleted`);
                console.log('Group deleted:', groupName);
            }
        }

        // Populate dropdown and setup event listeners on load
        window.addEventListener('load', () => {
            const dropdown = document.getElementById('group-color-dropdown');
            if (dropdown) {
                // Populate with preset colors
                presetColors.forEach(color => {
                    const option = document.createElement('option');
                    option.value = color;
                    option.textContent = color.toUpperCase();
                    option.style.backgroundColor = color;
                    option.style.color = '#fff';
                    option.style.fontWeight = '600';
                    option.style.padding = '4px 8px';
                    dropdown.appendChild(option);
                });
                
                console.log('Color dropdown populated with', presetColors.length, 'colors');
            }
        });

        // Expand/Collapse All Parts
        function expandAllParts() {
            parts.forEach((part, index) => {
                const card = document.getElementById(`part-card-${index}`);
                const collapseBtn = document.getElementById(`part-collapse-${index}`);
                if (card && card.classList.contains('minimized')) {
                    card.classList.remove('minimized');
                    if (collapseBtn) collapseBtn.textContent = '‚àí';
                }
            });
            showToast('All parts expanded');
        }

        function collapseAllParts() {
            parts.forEach((part, index) => {
                const card = document.getElementById(`part-card-${index}`);
                const collapseBtn = document.getElementById(`part-collapse-${index}`);
                if (card && !card.classList.contains('minimized')) {
                    card.classList.remove('expanded');
                    const transformBtn = document.getElementById(`transform-btn-${index}`);
                    const transformDiv = document.getElementById(`transform-${index}`);
                    if (transformBtn) transformBtn.classList.remove('active');
                    if (transformDiv) transformDiv.classList.remove('show');
                    
                    card.classList.add('minimized');
                    if (collapseBtn) collapseBtn.textContent = '+';
                }
            });
            showToast('All parts collapsed');
        }
        
        // Filter parts based on search query
        function filterParts(query) {
            query = query.toLowerCase().trim();
            let visibleCount = 0;
            let hiddenCount = 0;
            
            parts.forEach((part, index) => {
                const card = document.getElementById(`part-card-${index}`);
                if (!card) return;
                
                const partName = part.userData.name.toLowerCase();
                
                if (query === '' || partName.includes(query)) {
                    // Show matching parts
                    card.style.display = '';
                    visibleCount++;
                } else {
                    // Hide non-matching parts
                    card.style.display = 'none';
                    hiddenCount++;
                }
            });
            
            // Update search results count
            const resultsDiv = document.getElementById('search-results-count');
            if (resultsDiv) {
                if (query === '') {
                    resultsDiv.textContent = '';
                } else {
                    resultsDiv.textContent = `Showing ${visibleCount} of ${parts.length} parts`;
                    if (visibleCount === 0) {
                        resultsDiv.style.color = 'var(--accent-magenta)';
                        resultsDiv.textContent += ' - No matches found';
                    } else {
                        resultsDiv.style.color = 'var(--text-secondary)';
                    }
                }
            }
            
            console.log(`Filter: "${query}" - Showing ${visibleCount}, Hidden ${hiddenCount}`);
        }
        
        // Clear search filter
        function clearPartSearch() {
            const searchInput = document.getElementById('part-search');
            if (searchInput) {
                searchInput.value = '';
                filterParts('');
            }
        }
        
        // Scroll parts list to top
        function scrollPartsToTop() {
            const sidebar = document.querySelector('.sidebar');
            if (sidebar) {
                sidebar.scrollTo({
                    top: 0,
                    behavior: 'smooth'
                });
            }
        }
        
        // Setup sticky header floating detection
        function setupStickyHeaderDetection() {
            const sidebar = document.querySelector('.sidebar');
            const stickyHeader = document.querySelector('.part-section-sticky-header');
            
            if (!sidebar || !stickyHeader) return;
            
            // Detect scroll and add floating class when scrolled
            sidebar.addEventListener('scroll', () => {
                if (sidebar.scrollTop > 10) {
                    stickyHeader.classList.add('is-floating');
                } else {
                    stickyHeader.classList.remove('is-floating');
                }
            });
        }
        
        function lockAllParts() {
            let lockedCount = 0;
            parts.forEach((part, index) => {
                if (!part.userData.locked) {
                    part.userData.locked = true;
                    const btn = document.getElementById(`lock-btn-${index}`);
                    const card = document.getElementById(`part-card-${index}`);
                    const transformDiv = document.getElementById(`transform-${index}`);
                    
                    if (btn) {
                        btn.classList.add('locked');
                        btn.textContent = 'üîí';
                    }
                    if (card) {
                        card.classList.add('locked');
                    }
                    if (transformDiv && transformDiv.classList.contains('show')) {
                        transformDiv.classList.add('disabled');
                    }
                    lockedCount++;
                }
            });
            
            if (lockedCount > 0) {
                showToast(`üîí Locked ${lockedCount} part(s)`);
            } else {
                showToast('All parts already locked');
            }
        }
        
        function unlockAllParts() {
            let unlockedCount = 0;
            parts.forEach((part, index) => {
                if (part.userData.locked) {
                    part.userData.locked = false;
                    const btn = document.getElementById(`lock-btn-${index}`);
                    const card = document.getElementById(`part-card-${index}`);
                    const transformDiv = document.getElementById(`transform-${index}`);
                    
                    if (btn) {
                        btn.classList.remove('locked');
                        btn.textContent = 'üîì';
                    }
                    if (card) {
                        card.classList.remove('locked');
                    }
                    if (transformDiv) {
                        transformDiv.classList.remove('disabled');
                    }
                    unlockedCount++;
                }
            });
            
            if (unlockedCount > 0) {
                showToast(`üîì Unlocked ${unlockedCount} part(s)`);
            } else {
                showToast('All parts already unlocked');
            }
        }

        function togglePartCollapse(index) {
            const card = document.getElementById(`part-card-${index}`);
            const btn = document.getElementById(`part-collapse-${index}`);
            
            if (!card || !btn) {
                console.warn('Card or button not found for index:', index);
                return;
            }
            
            if (card.classList.contains('minimized')) {
                card.classList.remove('minimized');
                btn.textContent = '‚àí';
            } else {
                card.classList.remove('expanded');
                const transformBtn = document.getElementById(`transform-btn-${index}`);
                const transformDiv = document.getElementById(`transform-${index}`);
                if (transformBtn) transformBtn.classList.remove('active');
                if (transformDiv) transformDiv.classList.remove('show');
                
                card.classList.add('minimized');
                btn.textContent = '+';
            }
        }

        // Color Management
        function renderColorGrid() {
            const grid = document.getElementById('color-grid');
            grid.innerHTML = '';
            
            presetColors.forEach((color, index) => {
                const item = document.createElement('div');
                item.className = 'color-item';
                item.style.background = color;
                item.dataset.color = color; // Store color in data attribute
                
                // Restore selection if this was the selected color
                if (selectedColor && selectedColor.toLowerCase() === color.toLowerCase()) {
                    item.classList.add('selected');
                }
                
                // Fix: Use arrow function to capture 'item' reference correctly
                item.onclick = () => {
                    selectColor(color, item);
                    console.log('Color grid item clicked:', color);
                };
                
                const removeBtn = document.createElement('div');
                removeBtn.className = 'color-remove';
                removeBtn.textContent = '√ó';
                removeBtn.onclick = (e) => {
                    e.stopPropagation();
                    removeColor(index);
                };
                
                item.appendChild(removeBtn);
                grid.appendChild(item);
            });
            
            console.log('Color grid rendered with', presetColors.length, 'colors');
        }

        function selectColor(color, element) {
            console.log('=== Select Palette Color ===');
            console.log('Color:', color);
            console.log('Element:', element);
            console.log('Previously selected color:', selectedColor);
            
            selectedColor = color;
            
            // Remove selected class from all color items
            document.querySelectorAll('.color-item').forEach(el => {
                el.classList.remove('selected');
            });
            
            // Add selected class to clicked item
            if (element) {
                element.classList.add('selected');
                console.log('Added selected class to element');
            } else {
                // If no element provided, find it by color
                document.querySelectorAll('.color-item').forEach(el => {
                    if (el.dataset.color && el.dataset.color.toLowerCase() === color.toLowerCase()) {
                        el.classList.add('selected');
                        console.log('Found and selected element by color match');
                    }
                });
            }
            
            // Update the header indicator
            const indicator = document.getElementById('selected-color-indicator');
            if (indicator) {
                indicator.style.display = 'inline-block';
                indicator.style.background = color;
                indicator.textContent = color;
                indicator.style.color = 'white';
                indicator.style.textShadow = '0 1px 2px rgba(0,0,0,0.5)';
            }
            
            updateApplyButton();
            
            // Show feedback that color was selected
            showToast(`‚úì Palette colour selected - now select parts (‚úì)`);
            
            console.log('Selected palette color set to:', selectedColor);
            console.log('Selected parts count:', selectedParts.size);
            console.log('============================');
        }

        function addNewColor() {
            const newColorInput = document.getElementById('new-color-input');
            const newColor = newColorInput.value;
            
            console.log('Adding new color to palette:', newColor);
            
            // Check if color already exists (case insensitive)
            const colorExists = presetColors.some(c => c.toLowerCase() === newColor.toLowerCase());
            
            if (colorExists) {
                showToast('‚ö†Ô∏è Colour already in palette');
                // Flash the existing color
                const existingItem = document.querySelector(`.color-item[data-color="${newColor}"]`);
                if (existingItem) {
                    existingItem.style.transform = 'scale(1.2)';
                    existingItem.style.boxShadow = '0 0 20px ' + newColor;
                    setTimeout(() => {
                        existingItem.style.transform = '';
                        existingItem.style.boxShadow = '';
                    }, 500);
                }
                return;
            }
            
            // Add the new color
            presetColors.push(newColor);
            renderColorGrid();
            
            // Update all part preset color pickers
            parts.forEach((part, index) => {
                const presetsContainer = document.getElementById(`presets-${index}`);
                if (presetsContainer) {
                    presetsContainer.innerHTML = '';
                    presetColors.forEach(color => {
                        const preset = document.createElement('div');
                        preset.className = 'preset-color';
                        preset.style.background = color;
                        preset.onclick = () => updateColor(index, color);
                        presetsContainer.appendChild(preset);
                    });
                }
            });
            
            // Flash the new color in the palette
            setTimeout(() => {
                const newItem = document.querySelector(`.color-item[data-color="${newColor}"]`);
                if (newItem) {
                    newItem.style.transform = 'scale(1.2)';
                    newItem.style.boxShadow = '0 0 20px ' + newColor;
                    setTimeout(() => {
                        newItem.style.transform = '';
                        newItem.style.boxShadow = '';
                    }, 500);
                }
            }, 50);
            
            showToast(`‚úì Colour ${newColor} added to palette!`);
            console.log('New color added. Total colors:', presetColors.length);
        }

        function removeColor(index) {
            if (presetColors.length > 1) {
                presetColors.splice(index, 1);
                renderColorGrid();
                showToast('Colour removed from palette');
            } else {
                showToast('‚ö†Ô∏è Must keep at least one colour');
            }
        }

        function toggleColorPanel() {
            const content = document.getElementById('color-content');
            const btn = document.getElementById('color-collapse-btn');
            content.classList.toggle('collapsed');
            btn.textContent = content.classList.contains('collapsed') ? '+' : '‚àí';
        }

        function applyColorToSelected() {
            console.log('=== Apply Palette Color Debug ===');
            console.log('Selected palette color:', selectedColor);
            console.log('Selected parts:', Array.from(selectedParts));
            
            // Make absolutely sure we're using the palette selected color
            if (!selectedColor || selectedColor === '') {
                showToast('‚ö†Ô∏è Click a colour in the PALETTE first (the coloured squares)');
                console.log('ERROR: No palette color selected!');
                
                // Visual hint - flash the palette
                const palette = document.querySelector('.color-grid');
                if (palette) {
                    palette.style.border = '2px solid var(--accent-magenta)';
                    setTimeout(() => {
                        palette.style.border = '';
                    }, 1000);
                }
                return;
            }
            
            if (selectedParts.size === 0) {
                showToast('‚ö†Ô∏è Select parts first using the checkboxes (‚úì)');
                console.log('ERROR: No parts selected!');
                return;
            }
            
            // Apply the PALETTE color to all selected parts
            let successCount = 0;
            selectedParts.forEach(index => {
                console.log(`Applying palette color ${selectedColor} to part ${index}`);
                if (parts[index]) {
                    // Update the part's color with animation
                    animatePartColorChange(parts[index], selectedColor);
                    parts[index].userData.color = selectedColor;
                    
                    // Update the dropdown
                    const dropdown = document.getElementById(`part-color-dropdown-${index}`);
                    if (dropdown) {
                        dropdown.value = selectedColor;
                        dropdown.style.backgroundColor = selectedColor;
                        dropdown.style.color = '#fff';
                        dropdown.style.borderColor = selectedColor;
                        dropdown.style.borderWidth = '2px';
                    }
                    
                    successCount++;
                } else {
                    console.error(`Part ${index} not found!`);
                }
            });
            
            console.log(`Successfully applied palette color to ${successCount} parts`);
            showToast(`‚úì Applied ${selectedColor} to ${successCount} part(s)!`);
        }

        function updateApplyButton() {
            const btn = document.getElementById('apply-color-btn');
            if (!btn) {
                console.warn('Apply color button not found!');
                return;
            }
            
            const shouldEnable = selectedColor && selectedParts.size > 0;
            
            btn.disabled = !shouldEnable;
            
            // Show the actual palette color that will be applied
            if (selectedParts.size > 0 && selectedColor) {
                btn.textContent = `Apply Palette Colour to ${selectedParts.size} Part(s)`;
                btn.style.cursor = 'pointer';
                btn.style.background = `linear-gradient(135deg, ${selectedColor} 0%, ${selectedColor}88 100%)`;
                btn.style.borderColor = selectedColor;
                btn.style.color = '#ffffff';
            } else if (selectedParts.size > 0) {
                btn.textContent = 'Click a PALETTE Colour First';
                btn.style.cursor = 'not-allowed';
                btn.style.background = 'rgba(0, 255, 136, 0.1)';
                btn.style.borderColor = 'var(--accent-green)';
                btn.style.color = 'var(--accent-green)';
            } else if (selectedColor) {
                btn.textContent = 'Select Parts First (‚úì checkboxes)';
                btn.style.cursor = 'not-allowed';
                btn.style.background = 'rgba(0, 255, 136, 0.1)';
                btn.style.borderColor = 'var(--accent-green)';
                btn.style.color = 'var(--accent-green)';
            } else {
                btn.textContent = 'Select Color & Parts First';
                btn.style.cursor = 'not-allowed';
                btn.style.background = 'rgba(0, 255, 136, 0.1)';
                btn.style.borderColor = 'var(--accent-green)';
                btn.style.color = 'var(--accent-green)';
            }
            
            console.log('Apply button updated - Color:', selectedColor, 'Parts:', selectedParts.size, 'Enabled:', shouldEnable);
        }

        // Part Selection

        function updateSelectionInfo() {
            const info = document.getElementById('selection-info');
            if (selectedParts.size > 0) {
                info.textContent = `(${selectedParts.size} selected)`;
            } else {
                info.textContent = '';
            }
        }

        // Part Locking
        function toggleLock(index) {
            if (!parts[index]) return;
            
            parts[index].userData.locked = !parts[index].userData.locked;
            const btn = document.getElementById(`lock-btn-${index}`);
            const card = document.getElementById(`part-card-${index}`);
            const transformDiv = document.getElementById(`transform-${index}`);
            
            if (parts[index].userData.locked) {
                btn.classList.add('locked');
                btn.textContent = 'üîí';
                card.classList.add('locked');
                if (transformDiv && transformDiv.classList.contains('show')) {
                    transformDiv.classList.add('disabled');
                }
            } else {
                btn.classList.remove('locked');
                btn.textContent = 'üîì';
                card.classList.remove('locked');
                if (transformDiv) {
                    transformDiv.classList.remove('disabled');
                }
            }
            
            markAsModified(); // Lock state changed
        }

        function setupFileUpload() {
            const fileInput = document.getElementById('file-input');
            const uploadZone = document.getElementById('upload-zone');
            
            fileInput.addEventListener('change', (e) => {
                handleFiles(e.target.files);
            });
            
            uploadZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadZone.classList.add('drag-over');
            });
            
            uploadZone.addEventListener('dragleave', () => {
                uploadZone.classList.remove('drag-over');
            });
            
            uploadZone.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadZone.classList.remove('drag-over');
                handleFiles(e.dataTransfer.files);
            });
        }

        async function handleFiles(files) {
            // Separate STL files from project files
            const stlFiles = [];
            const projectFiles = [];
            
            for (const file of files) {
                if (file.name.toLowerCase().endsWith('.stlproject')) {
                    projectFiles.push(file);
                } else if (file.name.toLowerCase().endsWith('.stl')) {
                    stlFiles.push(file);
                } else {
                    showToast('‚ö†Ô∏è Please upload .stl or .stlproject files');
                }
            }
            
            // Load project files sequentially (they clear the scene)
            for (const file of projectFiles) {
                const zip = await JSZip.loadAsync(file);
                const projectJsonFile = zip.file("project.json");
                if (projectJsonFile) {
                    const projectData = JSON.parse(await projectJsonFile.async("text"));
                    
                    clearAllSilent();
                    document.getElementById('project-name').value = projectData.projectName;
                    currentProjectName = projectData.projectName;
                    hasUnsavedChanges = false; // Fresh project load
                    clearGitHubProjectStatus(); // Not a GitHub project - unlock name
                    resetGitHubFolderState(); // Clear any GitHub folder state
                    updateProjectDisplay();
                    
                    if (projectData.colors) {
                        presetColors = projectData.colors;
                        renderColorGrid();
                    }
                    
                    // Determine if project is encrypted
                    const isProtected = projectData.protected === true;
                    const folderName = isProtected ? "data" : "stl_files";
                    const encryptionKey = isProtected ? generateEncryptionKey(projectData.projectName) : null;
                    
                    const stlFolder = zip.folder(folderName);
                    for (const partData of projectData.parts) {
                        const stlFile = stlFolder.file(partData.fileName);
                        if (stlFile) {
                            let arrayBuffer = await stlFile.async("arraybuffer");
                            
                            // Decrypt if protected
                            if (isProtected) {
                                arrayBuffer = decryptBuffer(arrayBuffer, encryptionKey);
                            }
                            
                            await loadSTLFromBuffer(arrayBuffer, partData, projectData.version || "1.0");
                        }
                    }
                    
                    // Restore groups if present
                    if (projectData.groups && Array.isArray(projectData.groups)) {
                        groups = projectData.groups.map(g => ({
                            name: g.name,
                            parts: new Set(g.parts),
                            color: g.color || '#ffffff'
                        }));
                        renderGroupSelector();
                        console.log('Groups restored:', groups.length);
                    }
                    
                    // Restore assembly rotation if present
                    if (projectData.assemblyRotation) {
                        modelGroup.rotation.set(
                            projectData.assemblyRotation.x,
                            projectData.assemblyRotation.y,
                            projectData.assemblyRotation.z
                        );
                        console.log('Assembly rotation restored:', projectData.assemblyRotation);
                    } else {
                        // No rotation saved, reset to default
                        modelGroup.rotation.set(0, 0, 0);
                    }
                    
                    // Display license if present
                    // (Always show for drag & drop since they don't go through GitHub browser)
                    licenseAlreadyShown = false; // Reset flag
                    if (projectData.license) {
                        console.log('‚úì License found in project');
                        setTimeout(() => {
                            showLicense(projectData.license, `${projectData.projectName} - License`);
                        }, 500);
                    }
                    
                    frameModel();
                    showToast(`üìÇ Project "${projectData.projectName}" loaded!`);
                }
            }
            
            // Load STL files in parallel for speed
            if (stlFiles.length > 0) {
                if (stlFiles.length > 1) {
                    showToast(`‚è≥ Loading ${stlFiles.length} files in parallel...`);
                }
                
                const startTime = Date.now();
                
                // Load all files in parallel
                const loadPromises = stlFiles.map(file => loadSTLAsync(file));
                
                try {
                    await Promise.all(loadPromises);
                    const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
                    showToast(`‚úì Loaded ${stlFiles.length} file(s) in ${elapsed}s`);
                    
                    // Frame all parts after loading
                    if (parts.length > 0) {
                        frameModel();
                    }
                    
                    // Initialize history after loading
                    initializeHistory();
                } catch (error) {
                    console.error('Error loading files:', error);
                    showToast('‚ùå Some files failed to load');
                }
            }
        }
        
        // Async STL loader with Promise
        function loadSTLAsync(file) {
            return new Promise((resolve, reject) => {
                console.log('Loading STL file:', file.name);
                
                const reader = new FileReader();
                
                reader.onerror = (error) => {
                    console.error('File read error:', error);
                    showToast('‚ùå Error reading file: ' + file.name);
                    reject(error);
                };
                
                reader.onload = (e) => {
                    try {
                        console.log('File loaded, parsing geometry:', file.name);
                        const geometry = loader.parse(e.target.result);
                        console.log('Geometry parsed successfully');
                        
                        // Center geometry for rotation on the spot (version 1.1 behavior)
                        const centerOffset = new THREE.Vector3();
                        geometry.computeBoundingBox();
                        geometry.boundingBox.getCenter(centerOffset);
                        geometry.center();
                        
                        const randomColor = presetColors[Math.floor(Math.random() * presetColors.length)];
                        
                        const material = new THREE.MeshStandardMaterial({
                            color: randomColor,
                            metalness: 0.3,
                            roughness: 0.4,
                            flatShading: false
                        });
                        
                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.userData = {
                            name: file.name.replace('.stl', ''),
                            visible: true,
                            color: randomColor,
                            position: { x: 0, y: 0, z: 0 },
                            rotation: { x: 0, y: 0, z: 0 },
                            locked: false,
                            centerOffset: { x: centerOffset.x, y: centerOffset.y, z: centerOffset.z }
                        };
                        
                        // Set position with offset (newly uploaded files start centered)
                        mesh.position.set(centerOffset.x, centerOffset.y, centerOffset.z);
                        
                        // Store file for export
                        partFiles[file.name] = file;
                        
                        console.log('Adding mesh to scene...');
                        modelGroup.add(mesh);
                        parts.push(mesh);
                        
                        console.log('Creating UI controls...');
                        addPartControl(parts.length - 1);
                        updatePartCount();
                        updateBoundingBox();
                        updateCoordinates(parts.length - 1);
                        
                        markAsModified(); // New part added to project
                        console.log('‚úì STL loaded:', file.name);
                        resolve();
                    } catch (error) {
                        console.error('Error processing STL:', error);
                        showToast('‚ùå Error loading: ' + file.name);
                        reject(error);
                    }
                };
                
                console.log('Starting file read...');
                reader.readAsArrayBuffer(file);
            });
        }

        function loadSTL(file) {
            console.log('Loading STL file:', file.name);
            
            try {
                const reader = new FileReader();
                
                reader.onerror = (error) => {
                    console.error('File read error:', error);
                    showToast('‚ùå Error reading file: ' + file.name);
                };
                
                reader.onload = (e) => {
                    try {
                        console.log('File loaded, parsing geometry...');
                        const geometry = loader.parse(e.target.result);
                        console.log('Geometry parsed successfully');
                        
                        // Center geometry for rotation on the spot (version 1.1 behavior)
                        const centerOffset = new THREE.Vector3();
                        geometry.computeBoundingBox();
                        geometry.boundingBox.getCenter(centerOffset);
                        geometry.center();
                        
                        const randomColor = presetColors[Math.floor(Math.random() * presetColors.length)];
                        
                        const material = new THREE.MeshStandardMaterial({
                            color: randomColor,
                            metalness: 0.3,
                            roughness: 0.4,
                            flatShading: false
                        });
                        
                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.userData = {
                            name: file.name.replace('.stl', ''),
                            visible: true,
                            color: randomColor,
                            position: { x: 0, y: 0, z: 0 },
                            rotation: { x: 0, y: 0, z: 0 },
                            locked: false,
                            centerOffset: { x: centerOffset.x, y: centerOffset.y, z: centerOffset.z }
                        };
                        
                        // Set position with offset (newly uploaded files start centered)
                        mesh.position.set(centerOffset.x, centerOffset.y, centerOffset.z);
                        
                        console.log('Adding mesh to scene...');
                        modelGroup.add(mesh);
                        parts.push(mesh);
                        
                        console.log('Creating UI controls...');
                        addPartControl(parts.length - 1);
                        updatePartCount();
                        updateBoundingBox();
                        updateCoordinates(parts.length - 1);
                        
                        if (parts.length === 1) {
                            frameModel();
                        }
                        
                        showToast(`‚úì Loaded: ${file.name}`);
                        markAsModified(); // New part added to project
                        console.log('STL loaded successfully:', file.name);
                    } catch (error) {
                        console.error('Error processing STL:', error);
                        showToast('‚ùå Error loading: ' + file.name);
                    }
                };
                
                console.log('Starting file read...');
                reader.readAsArrayBuffer(file);
            } catch (error) {
                console.error('Error in loadSTL:', error);
                showToast('‚ùå Failed to load: ' + file.name);
            }
        }

        function addPartControl(index) {
            try {
                console.log('Adding part control for index:', index);
                const container = document.getElementById('parts-container');
                
                if (!container) {
                    console.error('Parts container not found!');
                    return;
                }
                
                // Remove existing card if it exists (prevent duplicates)
                const existingCard = document.getElementById(`part-card-${index}`);
                if (existingCard) {
                    console.log('Removing existing card for index:', index);
                    existingCard.remove();
                }
                
                if (parts.length === 1) {
                    container.innerHTML = '';
                }
                
                if (!parts[index]) {
                    console.error('Part not found at index:', index);
                    return;
                }
                
                const part = parts[index];
                const card = document.createElement('div');
                card.className = 'part-card';
                card.style.animationDelay = `${index * 0.1}s`;
                card.id = `part-card-${index}`;
                
                card.innerHTML = `
                <div class="part-header">
                    <div class="part-name-section">
                        <div class="select-checkbox" id="checkbox-${index}" onclick="togglePartSelection(${index})" title="Select for multi-color"></div>
                        <div class="part-name">${part.userData.name}</div>
                    </div>
                    <div class="part-actions">
                        <button class="collapse-btn" onclick="togglePartCollapse(${index})" id="part-collapse-${index}">‚àí</button>
                        <button class="icon-btn lock-btn" onclick="toggleLock(${index})" title="Lock/Unlock" id="lock-btn-${index}">
                            üîì
                        </button>
                        <button class="icon-btn visibility" onclick="toggleVisibility(${index})" title="Toggle visibility" id="vis-btn-${index}">
                            üëÅ
                        </button>
                        <button class="icon-btn" onclick="toggleTransform(${index})" title="Transform controls" id="transform-btn-${index}">‚öô</button>
                        <button class="icon-btn danger" onclick="removePart(${index})" title="Remove part">√ó</button>
                    </div>
                </div>
                
                <div class="part-content">
                    <div class="coordinate-display" ondblclick="focusOnPart(${index})" title="Double-click to focus in 3D view">
                        <div class="coord-title">Current Position</div>
                        <div class="coord-values">
                            <div class="coord-item">
                                <div class="coord-label">X</div>
                                <div class="coord-value" id="coord-x-${index}">0.0</div>
                            </div>
                            <div class="coord-item">
                                <div class="coord-label">Y</div>
                                <div class="coord-value" id="coord-y-${index}">0.0</div>
                            </div>
                            <div class="coord-item">
                                <div class="coord-label">Z</div>
                                <div class="coord-value" id="coord-z-${index}">0.0</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="color-picker-container">
                        <div style="font-size: 9px; color: var(--text-secondary); font-family: 'Azeret Mono', monospace; text-transform: uppercase; margin-bottom: 4px;">Part Colour:</div>
                        <select id="part-color-dropdown-${index}" onchange="updateColorFromDropdown(${index})" style="width: 100%; padding: 10px; border-radius: 6px; background: var(--bg-primary); border: 1px solid var(--border); color: var(--text-primary); font-family: 'Rajdhani', sans-serif; cursor: pointer; font-size: 12px; transition: all 0.3s ease;">
                            <option value="">Pick a colour</option>
                        </select>
                    </div>
                    
                    <div class="transform-controls" id="transform-${index}">
                        <div class="transform-section">
                            <div class="transform-label">Position (mm)</div>
                            <div class="transform-sliders">
                                ${['x', 'y', 'z'].map(axis => `
                                <div class="slider-row">
                                    <span class="slider-label">${axis.toUpperCase()}</span>
                                    <div class="slider-container">
                                        <input type="range" min="-500" max="500" value="0" step="0.1" 
                                               oninput="updateTransform(${index}, 'position', '${axis}', this.value)" id="pos-${axis}-${index}">
                                        <div class="input-controls">
                                            <button class="arrow-btn" onclick="adjustValue(${index}, 'position', '${axis}', -1)">‚àí</button>
                                            <input type="number" class="number-input" value="0" step="0.1"
                                                   onchange="setTransformDirect(${index}, 'position', '${axis}', this.value)" id="input-pos-${axis}-${index}">
                                            <button class="arrow-btn" onclick="adjustValue(${index}, 'position', '${axis}', 1)">+</button>
                                        </div>
                                    </div>
                                </div>
                                `).join('')}
                            </div>
                        </div>
                        
                        <div class="transform-section">
                            <div class="transform-label">Rotation (degrees)</div>
                            <div class="transform-sliders">
                                ${['x', 'y', 'z'].map(axis => `
                                <div class="slider-row">
                                    <span class="slider-label rotation">${axis.toUpperCase()}</span>
                                    <div class="slider-container">
                                        <input type="range" class="rotation" min="-180" max="180" value="0" step="1" 
                                               oninput="updateTransform(${index}, 'rotation', '${axis}', this.value)" id="rot-${axis}-${index}">
                                        <div class="input-controls">
                                            <button class="arrow-btn" onclick="adjustValue(${index}, 'rotation', '${axis}', -5)">‚àí</button>
                                            <input type="number" class="number-input" value="0" step="1"
                                                   onchange="setTransformDirect(${index}, 'rotation', '${axis}', this.value)" id="input-rot-${axis}-${index}">
                                            <button class="arrow-btn" onclick="adjustValue(${index}, 'rotation', '${axis}', 5)">+</button>
                                        </div>
                                    </div>
                                </div>
                                `).join('')}
                            </div>
                        </div>
                        
                        <button class="transform-reset" onclick="resetTransform(${index})">Reset Transform</button>
                    </div>
                </div>
            `;
            
            container.appendChild(card);
            
            // Populate the color dropdown for this part
            const partColorDropdown = document.getElementById(`part-color-dropdown-${index}`);
            if (partColorDropdown) {
                presetColors.forEach(color => {
                    const option = document.createElement('option');
                    option.value = color;
                    option.textContent = color.toUpperCase();
                    option.style.backgroundColor = color;
                    option.style.color = '#fff';
                    option.style.fontWeight = '600';
                    option.style.padding = '4px 8px';
                    partColorDropdown.appendChild(option);
                });
                
                // Set current color
                partColorDropdown.value = part.userData.color;
                partColorDropdown.style.backgroundColor = part.userData.color;
                partColorDropdown.style.color = '#fff';
                partColorDropdown.style.fontWeight = '600';
                partColorDropdown.style.borderColor = part.userData.color;
                partColorDropdown.style.borderWidth = '2px';
            }
            
            console.log('Part control added successfully for index:', index);
            } catch (error) {
                console.error('Error in addPartControl:', error);
                showToast('‚ùå Error creating part controls');
            }
        }

        function toggleTransform(index) {
            if (parts[index] && parts[index].userData.locked) {
                showToast('‚ö†Ô∏è Part is locked. Unlock to edit.');
                return;
            }
            
            const transformDiv = document.getElementById(`transform-${index}`);
            const btn = document.getElementById(`transform-btn-${index}`);
            const card = document.getElementById(`part-card-${index}`);
            
            transformDiv.classList.toggle('show');
            btn.classList.toggle('active');
            card.classList.toggle('expanded');
        }

        function updateColor(index, color) {
            if (parts[index]) {
                animatePartColorChange(parts[index], color);
                parts[index].userData.color = color;
                
                // Update dropdown if it exists
                const dropdown = document.getElementById(`part-color-dropdown-${index}`);
                if (dropdown) {
                    dropdown.value = color;
                    dropdown.style.backgroundColor = color;
                    dropdown.style.color = '#fff';
                    dropdown.style.borderColor = color;
                    dropdown.style.borderWidth = '2px';
                }
            }
        }
        
        function updateColorFromDropdown(index) {
            const dropdown = document.getElementById(`part-color-dropdown-${index}`);
            
            if (!dropdown) {
                console.warn('Color dropdown not found for part:', index);
                return;
            }
            
            const color = dropdown.value;
            
            if (!color) {
                // Reset to default when no color selected
                dropdown.style.backgroundColor = 'var(--bg-primary)';
                dropdown.style.color = 'var(--text-primary)';
                dropdown.style.borderColor = 'var(--border)';
                dropdown.style.borderWidth = '1px';
                return;
            }

            // Set dropdown visual feedback
            dropdown.style.backgroundColor = color;
            dropdown.style.color = '#fff';
            dropdown.style.borderColor = color;
            dropdown.style.borderWidth = '2px';

            // Apply color to part immediately
            if (parts[index]) {
                animatePartColorChange(parts[index], color);
                parts[index].userData.color = color;
                showToast(`‚úì ${color.toUpperCase()} applied to "${parts[index].userData.name}"`);
            }
        }

        function updateTransform(index, type, axis, value) {
            if (!parts[index] || parts[index].userData.locked) return;
            
            const val = parseFloat(value);
            
            if (type === 'position') {
                // Update logical position
                parts[index].userData.position[axis] = val;
                
                // Apply with center offset
                const offset = parts[index].userData.centerOffset || { x: 0, y: 0, z: 0 };
                parts[index].position[axis] = val + offset[axis];
                
                document.getElementById(`input-pos-${axis}-${index}`).value = val.toFixed(1);
                updateCoordinates(index);
            } else if (type === 'rotation') {
                const radians = val * (Math.PI / 180);
                parts[index].rotation[axis] = radians;
                parts[index].userData.rotation[axis] = val;
                document.getElementById(`input-rot-${axis}-${index}`).value = val.toFixed(0);
            }
            
            updateBoundingBox();
        }

        function setTransformDirect(index, type, axis, value) {
            if (!parts[index] || parts[index].userData.locked) return;
            
            const val = parseFloat(value);
            
            if (type === 'position') {
                const clamped = Math.max(-500, Math.min(500, val));
                
                // Update logical position
                parts[index].userData.position[axis] = clamped;
                
                // Apply with center offset
                const offset = parts[index].userData.centerOffset || { x: 0, y: 0, z: 0 };
                parts[index].position[axis] = clamped + offset[axis];
                
                document.getElementById(`pos-${axis}-${index}`).value = clamped;
                document.getElementById(`input-pos-${axis}-${index}`).value = clamped.toFixed(1);
                updateCoordinates(index);
            } else if (type === 'rotation') {
                const clamped = Math.max(-180, Math.min(180, val));
                const radians = clamped * (Math.PI / 180);
                parts[index].rotation[axis] = radians;
                parts[index].userData.rotation[axis] = clamped;
                document.getElementById(`rot-${axis}-${index}`).value = clamped;
                document.getElementById(`input-rot-${axis}-${index}`).value = clamped.toFixed(0);
            }
            
            updateBoundingBox();
        }

        function adjustValue(index, type, axis, delta) {
            if (!parts[index] || parts[index].userData.locked) return;
            
            if (type === 'position') {
                // Use logical position
                const current = parts[index].userData.position[axis];
                const newVal = Math.max(-500, Math.min(500, current + delta));
                setTransformDirect(index, type, axis, newVal);
            } else if (type === 'rotation') {
                const current = parts[index].userData.rotation[axis];
                const newVal = Math.max(-180, Math.min(180, current + delta));
                setTransformDirect(index, type, axis, newVal);
            }
        }

        function updateCoordinates(index) {
            if (!parts[index]) return;
            
            // Display logical position (not render position)
            const pos = parts[index].userData.position;
            document.getElementById(`coord-x-${index}`).textContent = pos.x.toFixed(1);
            document.getElementById(`coord-y-${index}`).textContent = pos.y.toFixed(1);
            document.getElementById(`coord-z-${index}`).textContent = pos.z.toFixed(1);
        }

        function resetTransform(index) {
            if (parts[index] && !parts[index].userData.locked) {
                // Reset logical position
                parts[index].userData.position = { x: 0, y: 0, z: 0 };
                parts[index].userData.rotation = { x: 0, y: 0, z: 0 };
                
                // Apply with center offset
                const offset = parts[index].userData.centerOffset || { x: 0, y: 0, z: 0 };
                parts[index].position.set(offset.x, offset.y, offset.z);
                parts[index].rotation.set(0, 0, 0);
                
                ['x', 'y', 'z'].forEach(axis => {
                    document.getElementById(`pos-${axis}-${index}`).value = 0;
                    document.getElementById(`input-pos-${axis}-${index}`).value = 0;
                    document.getElementById(`rot-${axis}-${index}`).value = 0;
                    document.getElementById(`input-rot-${axis}-${index}`).value = 0;
                });
                
                updateCoordinates(index);
                updateBoundingBox();
                showToast('Transform reset');
            }
        }

        function toggleVisibility(index) {
            if (parts[index]) {
                parts[index].visible = !parts[index].visible;
                parts[index].userData.visible = parts[index].visible;
                
                const btn = document.getElementById(`vis-btn-${index}`);
                const card = document.getElementById(`part-card-${index}`);
                
                if (parts[index].visible) {
                    btn.classList.remove('hidden-btn');
                    btn.classList.add('visibility');
                    btn.textContent = 'üëÅ';
                    card.classList.remove('hidden-part');
                } else {
                    btn.classList.add('hidden-btn');
                    btn.classList.remove('visibility');
                    btn.textContent = '‚®Ø';
                    card.classList.add('hidden-part');
                }
                
                markAsModified(); // Visibility changed
                updateBoundingBox();
            }
        }

        function removePart(index) {
            if (parts[index]) {
                const part = parts[index];
                
                // Remove from scene
                modelGroup.remove(part);
                
                // Dispose geometry
                if (part.geometry) {
                    part.geometry.dispose();
                }
                
                // Dispose material and textures
                if (part.material) {
                    if (part.material.map) part.material.map.dispose();
                    if (part.material.lightMap) part.material.lightMap.dispose();
                    if (part.material.bumpMap) part.material.bumpMap.dispose();
                    if (part.material.normalMap) part.material.normalMap.dispose();
                    if (part.material.specularMap) part.material.specularMap.dispose();
                    if (part.material.envMap) part.material.envMap.dispose();
                    part.material.dispose();
                }
                
                // Remove from array
                parts.splice(index, 1);
                
                // Update selected parts indices
                selectedParts.delete(index);
                const newSelected = new Set();
                selectedParts.forEach(i => {
                    if (i > index) newSelected.add(i - 1);
                    else if (i < index) newSelected.add(i);
                });
                selectedParts = newSelected;
                
                rebuildUI();
                updatePartCount();
                updateBoundingBox();
                showToast('Part removed');
                
                console.log('Part removed with proper disposal, remaining parts:', parts.length);
            }
        }

        function rebuildUI() {
            const container = document.getElementById('parts-container');
            container.innerHTML = '';
            
            if (parts.length === 0) {
                container.innerHTML = '<div class="empty-state">No parts loaded yet.<br>Upload STL files or load a project.</div>';
            } else {
                parts.forEach((part, index) => {
                    addPartControl(index);
                    
                    const colorInput = document.querySelector(`#preview-${index} input`);
                    if (colorInput) colorInput.value = part.userData.color;
                    
                    ['x', 'y', 'z'].forEach(axis => {
                        const posSlider = document.getElementById(`pos-${axis}-${index}`);
                        const posInput = document.getElementById(`input-pos-${axis}-${index}`);
                        const rotSlider = document.getElementById(`rot-${axis}-${index}`);
                        const rotInput = document.getElementById(`input-rot-${axis}-${index}`);
                        
                        if (posSlider && posInput) {
                            posSlider.value = part.userData.position[axis];
                            posInput.value = part.userData.position[axis].toFixed(1);
                        }
                        if (rotSlider && rotInput) {
                            rotSlider.value = part.userData.rotation[axis];
                            rotInput.value = part.userData.rotation[axis].toFixed(0);
                        }
                    });
                    
                    updateCoordinates(index);
                    
                    if (!part.visible) {
                        const btn = document.getElementById(`vis-btn-${index}`);
                        const card = document.getElementById(`part-card-${index}`);
                        btn.classList.add('hidden-btn');
                        btn.classList.remove('visibility');
                        btn.textContent = '‚®Ø';
                        card.classList.add('hidden-part');
                    }
                    
                    if (part.userData.locked) {
                        const btn = document.getElementById(`lock-btn-${index}`);
                        const card = document.getElementById(`part-card-${index}`);
                        btn.classList.add('locked');
                        btn.textContent = 'üîí';
                        card.classList.add('locked');
                    }
                    
                    // Restore selection state
                    if (selectedParts.has(index)) {
                        const checkbox = document.getElementById(`checkbox-${index}`);
                        const card = document.getElementById(`part-card-${index}`);
                        if (checkbox) {
                            checkbox.classList.add('checked');
                            checkbox.textContent = '‚úì';
                        }
                        if (card) {
                            card.classList.add('selected');
                        }
                    }
                });
            }
        }

        function randomizeColors() {
            parts.forEach((part, index) => {
                const randomColor = presetColors[Math.floor(Math.random() * presetColors.length)];
                updateColor(index, randomColor);
            });
            showToast('üé® Colours randomized!');
        }

        function clearAll() {
            console.log('=== clearAll() called ===');
            console.log('Parts count:', parts.length);
            console.log('Groups count:', groups.length);
            
            // Check if there are unsaved changes
            if (hasUnsavedChanges && parts.length > 0) {
                const projectName = currentProjectName || 'Current Project';
                const saveMessage = `You have unsaved changes in "${projectName}".\n\nClick OK to SAVE before starting new project, or Cancel to DISCARD and start fresh.`;
                
                const saveFirst = confirm(saveMessage);
                
                if (saveFirst) {
                    // User wants to save first
                    console.log('User chose to save before new project');
                    saveProject().then(() => {
                        const continueNew = confirm('Project saved! Continue with new project?');
                        if (continueNew) {
                            performNewProject();
                        }
                    });
                    return; // Exit early, will continue in promise
                } else {
                    // User chose to discard and start new
                    console.log('User chose to discard and start new project');
                    performNewProject();
                }
            } else {
                // No unsaved changes, just confirm
                const message = parts.length > 0 
                    ? `Start a new project? This will clear all ${parts.length} part(s) and ${groups.length} group(s).`
                    : 'Start a new project?';
                
                console.log('Showing confirm dialog...');
                const userConfirmed = confirm(message);
                console.log('User confirmed:', userConfirmed);
                
                if (userConfirmed) {
                    performNewProject();
                } else {
                    console.log('User cancelled');
                }
            }
        }
        
        function performNewProject() {
            console.log('Performing new project setup...');
            clearAllSilent();
            
            // Reset all GitHub and project state
            clearGitHubProjectStatus(); // Unlock name, remove badge
            resetGitHubFolderState(); // Clear folder license state
            hasUnsavedChanges = false; // Reset unsaved flag
            currentProjectName = null; // Clear project name tracking
            clearHistory(); // Clear undo/redo history
            
            console.log('‚úì Project state fully reset');
            console.log('‚úì Name unlocked and editable');
            console.log('‚úì GitHub folder state cleared');
            console.log('‚úì Undo/redo history cleared');
            showToast('‚úì New project started');
        }

        function highlightPartInSidebar(partIndex) {
            const card = document.getElementById(`part-card-${partIndex}`);
            
            if (!card) {
                console.warn('Part card not found:', partIndex);
                return;
            }
            
            // Expand part if it's collapsed
            if (card.classList.contains('minimized')) {
                const collapseBtn = document.getElementById(`part-collapse-${partIndex}`);
                if (collapseBtn) {
                    card.classList.remove('minimized');
                    collapseBtn.textContent = '‚àí';
                }
            }
            
            // Scroll to the part card smoothly
            card.scrollIntoView({ 
                behavior: 'smooth', 
                block: 'center'
            });
            
            // Add highlight effect
            card.style.transition = 'all 0.3s ease';
            card.style.transform = 'scale(1.02)';
            card.style.boxShadow = '0 0 20px rgba(0, 245, 255, 0.6), 0 0 40px rgba(0, 245, 255, 0.3)';
            card.style.borderColor = 'var(--accent-cyan)';
            card.style.borderWidth = '2px';
            
            // Show toast
            const partName = parts[partIndex]?.userData?.name || `Part ${partIndex + 1}`;
            showToast(`üìç Found: ${partName}`);
            
            // Remove highlight after 2 seconds
            setTimeout(() => {
                card.style.transform = '';
                card.style.boxShadow = '';
                card.style.borderColor = '';
                card.style.borderWidth = '';
            }, 2000);
            
            console.log('Highlighted part in sidebar:', partIndex, partName);
        }

        function focusOnPart(partIndex) {
            if (!parts[partIndex]) {
                console.warn('Part not found:', partIndex);
                return;
            }
            
            const part = parts[partIndex];
            const partName = part.userData.name || `Part ${partIndex + 1}`;
            
            // Get part's bounding box
            const box = new THREE.Box3().setFromObject(part);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            
            // Calculate distance based on part size
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            const distance = Math.abs(maxDim / Math.sin(fov / 2)) * 1.5;
            
            // Position camera to look at part
            const direction = new THREE.Vector3(1, 1, 1).normalize();
            camera.position.copy(center).add(direction.multiplyScalar(distance));
            camera.lookAt(center);
            
            // Highlight the part temporarily
            const originalEmissive = part.material.emissive.clone();
            part.material.emissive.setHex(0x00f5ff);
            part.material.emissiveIntensity = 0.3;
            
            setTimeout(() => {
                part.material.emissive.copy(originalEmissive);
                part.material.emissiveIntensity = 0;
            }, 1500);
            
            showToast(`üîç Focused on: ${partName}`);
            console.log('Focused on part:', partIndex, partName);
        }

        function frameModel() {
            if (parts.length === 0) return;
            
            // Create bounding box that includes the entire modelGroup with rotation
            const box = new THREE.Box3().setFromObject(modelGroup);
            
            const center = new THREE.Vector3();
            box.getCenter(center);
            
            const size = new THREE.Vector3();
            box.getSize(size);
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
            cameraZ *= 2.2; // Slightly more padding
            
            camera.position.set(center.x + cameraZ * 0.5, center.y + cameraZ * 0.5, center.z + cameraZ);
            camera.lookAt(center);
            
            console.log('‚úì Frame All: Model centered in view');
        }

        function resetCamera() {
            camera.position.set(0, 50, 150);
            camera.lookAt(0, 0, 0);
            modelGroup.rotation.set(0, 0, 0);
        }
        
        // Toggle control panel minimize/expand
        let controlPanelMinimized = false;
        function toggleControlPanel() {
            const rotateSection = document.getElementById('rotate-section');
            const viewContent = document.getElementById('view-controls-content');
            const panel = document.getElementById('control-panel');
            
            // Check if elements exist - if not, silently return (panels might not be loaded yet)
            if (!rotateSection || !viewContent || !panel) {
                return;
            }
            
            // Get toggle button - from event if clicked, or find it if keyboard triggered
            let toggleBtn = null;
            try {
                if (typeof event !== 'undefined' && event && event.target) {
                    toggleBtn = event.target;
                } else {
                    // Find the button when triggered by keyboard
                    if (panel) {
                        toggleBtn = panel.querySelector('button[onclick*="toggleControlPanel"]');
                    }
                }
            } catch (e) {
                // Silently handle error
            }
            
            controlPanelMinimized = !controlPanelMinimized;
            
            if (controlPanelMinimized) {
                // Minimize
                rotateSection.style.display = 'none';
                viewContent.style.display = 'none';
                panel.style.maxWidth = 'auto';
                if (toggleBtn) {
                    toggleBtn.textContent = '+';
                    toggleBtn.title = 'Expand';
                }
            } else {
                // Expand
                rotateSection.style.display = 'block';
                viewContent.style.display = 'block';
                panel.style.maxWidth = '240px';
                if (toggleBtn) {
                    toggleBtn.textContent = '‚àí';
                    toggleBtn.title = 'Minimize';
                }
            }
        }
        
        // Info overlay toggle
        let infoOverlayMinimized = false;
        
        function toggleInfoOverlay() {
            const overlay = document.getElementById('info-overlay');
            const toggleBtn = overlay ? overlay.querySelector('.info-toggle-btn') : null;
            
            // If overlay doesn't exist, silently return (might not be loaded yet)
            if (!overlay) {
                return;
            }
            
            infoOverlayMinimized = !infoOverlayMinimized;
            
            if (infoOverlayMinimized) {
                // Minimize
                overlay.classList.add('minimized');
                if (toggleBtn) {
                    toggleBtn.textContent = '+';
                    toggleBtn.title = 'Expand';
                }
            } else {
                // Expand
                overlay.classList.remove('minimized');
                if (toggleBtn) {
                    toggleBtn.textContent = '‚àí';
                    toggleBtn.title = 'Minimize';
                }
            }
        }
        
        // UNDO/REDO SYSTEM
        
        // Capture current state
        function captureState() {
            if (isApplyingHistory) return; // Don't capture during undo/redo
            
            const state = {
                parts: parts.map((part, idx) => ({
                    name: part.userData.name,
                    color: part.userData.color,
                    visible: part.userData.visible,
                    locked: part.userData.locked,
                    position: { ...part.userData.position },
                    rotation: { ...part.userData.rotation }
                })),
                groups: groups.map(g => ({
                    name: g.name,
                    parts: Array.from(g.parts),
                    color: g.color
                })),
                selectedGroup: selectedGroup ? selectedGroup.name : null,
                modelRotation: {
                    x: modelGroup.rotation.x,
                    y: modelGroup.rotation.y,
                    z: modelGroup.rotation.z
                }
            };
            
            return state;
        }
        
        // Save current state to history
        function saveState() {
            if (isApplyingHistory) return; // Don't save during undo/redo
            if (parts.length === 0) return; // Don't save empty states
            
            const state = captureState();
            
            // Remove any future states if we're not at the end
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }
            
            // Add new state
            history.push(state);
            
            // Limit history size
            if (history.length > MAX_HISTORY) {
                history.shift();
            } else {
                historyIndex++;
            }
            
            updateUndoRedoButtons();
            console.log(`üíæ State saved (${historyIndex + 1}/${history.length})`);
        }
        
        // Apply a state from history
        function applyState(state) {
            isApplyingHistory = true;
            
            try {
                // Restore part properties
                parts.forEach((part, idx) => {
                    if (state.parts[idx]) {
                        const savedPart = state.parts[idx];
                        
                        // Restore color
                        if (part.userData.color !== savedPart.color) {
                            part.userData.color = savedPart.color;
                            part.material.color.setStyle(savedPart.color);
                        }
                        
                        // Restore visibility
                        if (part.userData.visible !== savedPart.visible) {
                            part.userData.visible = savedPart.visible;
                            part.visible = savedPart.visible;
                        }
                        
                        // Restore lock
                        part.userData.locked = savedPart.locked;
                        
                        // Note: Position/rotation restoration would need more complex handling
                        // as it involves the actual mesh transforms
                    }
                });
                
                // Restore groups
                groups = state.groups.map(g => ({
                    name: g.name,
                    parts: new Set(g.parts),
                    color: g.color
                }));
                renderGroupSelector();
                
                // Restore selected group
                if (state.selectedGroup) {
                    const groupIndex = groups.findIndex(g => g.name === state.selectedGroup);
                    if (groupIndex !== -1) {
                        selectGroup(groupIndex);
                    }
                } else {
                    selectGroup('');
                }
                
                // Restore model rotation
                modelGroup.rotation.set(
                    state.modelRotation.x,
                    state.modelRotation.y,
                    state.modelRotation.z
                );
                
                // Rebuild UI to reflect changes
                rebuildUI();
                
            } finally {
                isApplyingHistory = false;
            }
        }
        
        // Undo
        function undo() {
            if (historyIndex <= 0) {
                showToast('‚ö†Ô∏è Nothing to undo');
                return;
            }
            
            historyIndex--;
            const state = history[historyIndex];
            applyState(state);
            updateUndoRedoButtons();
            
            showToast(`‚Ü∂ Undo (${history.length - historyIndex - 1} more available)`);
            console.log(`‚Ü∂ Undo to state ${historyIndex + 1}/${history.length}`);
        }
        
        // Redo
        function redo() {
            if (historyIndex >= history.length - 1) {
                showToast('‚ö†Ô∏è Nothing to redo');
                return;
            }
            
            historyIndex++;
            const state = history[historyIndex];
            applyState(state);
            updateUndoRedoButtons();
            
            showToast(`‚Ü∑ Redo (${historyIndex} more available)`);
            console.log(`‚Ü∑ Redo to state ${historyIndex + 1}/${history.length}`);
        }
        
        // Update undo/redo button states
        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');
            
            if (undoBtn) {
                undoBtn.disabled = historyIndex <= 0;
                undoBtn.style.opacity = historyIndex <= 0 ? '0.5' : '1';
                undoBtn.style.cursor = historyIndex <= 0 ? 'not-allowed' : 'pointer';
            }
            
            if (redoBtn) {
                redoBtn.disabled = historyIndex >= history.length - 1;
                redoBtn.style.opacity = historyIndex >= history.length - 1 ? '0.5' : '1';
                redoBtn.style.cursor = historyIndex >= history.length - 1 ? 'not-allowed' : 'pointer';
            }
        }
        
        // Clear history (when loading new project)
        function clearHistory() {
            history = [];
            historyIndex = -1;
            updateUndoRedoButtons();
            console.log('üóëÔ∏è History cleared');
        }
        
        // Initialize history with current state
        function initializeHistory() {
            if (parts.length > 0) {
                clearHistory();
                saveState();
                console.log('‚úì History initialized');
            }
        }
        
        // END UNDO/REDO SYSTEM
        
        function resetRotation() {
            modelGroup.rotation.set(0, 0, 0);
            markAsModified();
            showToast('‚úì Model rotation reset');
        }
        
        // Preset view functions
        function setTopView() {
            // Looking down from top
            modelGroup.rotation.set(-Math.PI / 2, 0, 0); // Pitch down 90¬∞
            markAsModified();
            showToast('üëÅÔ∏è Top view');
        }
        
        function setBottomView() {
            // Looking up from bottom
            modelGroup.rotation.set(Math.PI / 2, 0, 0); // Pitch up 90¬∞
            markAsModified();
            showToast('üëÅÔ∏è Bottom view');
        }
        
        function setFrontView() {
            // Default front view
            modelGroup.rotation.set(0, 0, 0);
            markAsModified();
            showToast('üëÅÔ∏è Front view');
        }
        
        function setBackView() {
            // Rotate 180¬∞ to see back
            modelGroup.rotation.set(0, Math.PI, 0);
            markAsModified();
            showToast('üëÅÔ∏è Back view');
        }
        
        function setSideView() {
            // Right side view
            modelGroup.rotation.set(0, Math.PI / 2, 0); // Rotate 90¬∞ right
            markAsModified();
            showToast('üëÅÔ∏è Side view (right)');
        }
        
        function setOtherSideView() {
            // Left side view
            modelGroup.rotation.set(0, -Math.PI / 2, 0); // Rotate 90¬∞ left
            markAsModified();
            showToast('üëÅÔ∏è Side view (left)');
        }
        
        // 90-degree rotation functions
        function rotateLeft90() {
            modelGroup.rotation.y -= Math.PI / 2; // 90 degrees left
            markAsModified();
            showToast('‚Ü∂ Rotated 90¬∞ left');
        }
        
        function rotateRight90() {
            modelGroup.rotation.y += Math.PI / 2; // 90 degrees right
            markAsModified();
            showToast('‚Ü∑ Rotated 90¬∞ right');
        }
        
        function rotateUp90() {
            modelGroup.rotation.x -= Math.PI / 2; // 90 degrees up
            markAsModified();
            showToast('‚Üë Rotated 90¬∞ up');
        }
        
        function rotateDown90() {
            modelGroup.rotation.x += Math.PI / 2; // 90 degrees down
            markAsModified();
            showToast('‚Üì Rotated 90¬∞ down');
        }
        
        // 15-degree fine rotation functions
        function rotateLeft15() {
            modelGroup.rotation.y -= Math.PI / 12; // 15 degrees left
            markAsModified();
            showToast('‚Ü∂ Rotated 15¬∞ left');
        }
        
        function rotateRight15() {
            modelGroup.rotation.y += Math.PI / 12; // 15 degrees right
            markAsModified();
            showToast('‚Ü∑ Rotated 15¬∞ right');
        }
        
        function rotateUp15() {
            modelGroup.rotation.x -= Math.PI / 12; // 15 degrees up
            markAsModified();
            showToast('‚Üë Rotated 15¬∞ up');
        }
        
        function rotateDown15() {
            modelGroup.rotation.x += Math.PI / 12; // 15 degrees down
            markAsModified();
            showToast('‚Üì Rotated 15¬∞ down');
        }
        
        // 30-degree rotation functions
        function rotateLeft30() {
            modelGroup.rotation.y -= Math.PI / 6; // 30 degrees left
            markAsModified();
            showToast('‚Ü∂ Rotated 30¬∞ left');
        }
        
        function rotateRight30() {
            modelGroup.rotation.y += Math.PI / 6; // 30 degrees right
            markAsModified();
            showToast('‚Ü∑ Rotated 30¬∞ right');
        }
        
        // 45-degree rotation functions
        function rotateLeft45() {
            modelGroup.rotation.y -= Math.PI / 4; // 45 degrees left
            markAsModified();
            showToast('‚Ü∂ Rotated 45¬∞ left');
        }
        
        function rotateRight45() {
            modelGroup.rotation.y += Math.PI / 4; // 45 degrees right
            markAsModified();
            showToast('‚Ü∑ Rotated 45¬∞ right');
        }
        
        // 60-degree rotation functions
        function rotateLeft60() {
            modelGroup.rotation.y -= Math.PI / 3; // 60 degrees left
            markAsModified();
            showToast('‚Ü∂ Rotated 60¬∞ left');
        }
        
        function rotateRight60() {
            modelGroup.rotation.y += Math.PI / 3; // 60 degrees right
            markAsModified();
            showToast('‚Ü∑ Rotated 60¬∞ right');
        }
        
        // Flip functions
        function flipHorizontal() {
            modelGroup.rotation.y += Math.PI; // 180 degrees
            markAsModified();
            showToast('‚Üî Flipped horizontal');
        }
        
        function flipVertical() {
            modelGroup.rotation.x += Math.PI; // 180 degrees
            markAsModified();
            showToast('‚Üï Flipped vertical');
        }

        function updatePartCount() {
            document.getElementById('part-count').textContent = parts.length;
        }

        function updateBoundingBox() {
            if (parts.length === 0) {
                document.getElementById('bounding-box-info').innerHTML = '';
                return;
            }
            
            const box = new THREE.Box3();
            parts.forEach(part => {
                if (part.visible) {
                    box.expandByObject(part);
                }
            });
            
            const size = new THREE.Vector3();
            box.getSize(size);
            
            const info = `
                <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(0, 245, 255, 0.15);">
                    <div style="color: var(--accent-yellow); margin-bottom: 4px;">Bounding Box:</div>
                    <div>X: ${size.x.toFixed(2)} mm</div>
                    <div>Y: ${size.y.toFixed(2)} mm</div>
                    <div>Z: ${size.z.toFixed(2)} mm</div>
                </div>
            `;
            
            document.getElementById('bounding-box-info').innerHTML = info;
        }

        function toggleMeasure() {
            measureMode = !measureMode;
            const btn = document.getElementById('measure-btn');
            const overlay = document.getElementById('measurement-overlay');
            
            if (measureMode) {
                btn.classList.add('active');
                overlay.classList.add('active');
                measurePoints = [];
                showToast('üìè Measurement mode active');
            } else {
                btn.classList.remove('active');
                overlay.classList.remove('active');
                clearMeasurementVisuals();
            }
        }

        function clearMeasurementVisuals() {
            document.querySelectorAll('.measurement-line, .measurement-point').forEach(el => el.remove());
        }

        function exportImage() {
            renderer.render(scene, camera);
            const imgData = renderer.domElement.toDataURL('image/png');
            const link = document.createElement('a');
            link.href = imgData;
            const projectName = document.getElementById('project-name').value.replace(/[^a-z0-9]/gi, '_');
            link.download = `${projectName}_preview.png`;
            link.click();
            showToast('üì∏ Image exported!');
        }

        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        let previousMousePosition = { x: 0, y: 0 };
        let isPanning = false;

        function setupControls() {
            const canvas = renderer.domElement;
            
            // Double-click to find part in sidebar
            canvas.addEventListener('dblclick', (e) => {
                const rect = canvas.getBoundingClientRect();
                mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(parts);
                
                if (intersects.length > 0) {
                    const clickedPart = intersects[0].object;
                    const partIndex = parts.indexOf(clickedPart);
                    
                    if (partIndex !== -1) {
                        highlightPartInSidebar(partIndex);
                    }
                }
            });
            
            canvas.addEventListener('mousedown', (e) => {
                if (measureMode) {
                    handleMeasureClick(e);
                    return;
                }
                
                const rect = canvas.getBoundingClientRect();
                mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                
                // Check if Shift is held for part movement
                if (e.shiftKey) {
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(parts);
                    
                    if (intersects.length > 0) {
                        const clickedPart = intersects[0].object;
                        
                        // Check if part is locked
                        if (clickedPart.userData.locked) {
                            showToast('üîí Part is locked - unlock to move');
                            return;
                        }
                        
                        draggedPart = clickedPart;
                        const intersection = intersects[0].point;
                        
                        if (e.button === 0) {
                            // Left click + Shift = horizontal movement (XZ plane)
                            dragMode = 'horizontal';
                            dragPlane.setFromNormalAndCoplanarPoint(
                                camera.getWorldDirection(dragPlane.normal).negate(),
                                intersection
                            );
                            canvas.style.cursor = 'move';
                        } else if (e.button === 2) {
                            // Right click + Shift = vertical movement (Y axis)
                            dragMode = 'vertical';
                            dragPlane.setFromNormalAndCoplanarPoint(
                                new THREE.Vector3(1, 0, 0),
                                intersection
                            );
                            canvas.style.cursor = 'ns-resize';
                        }
                        
                        if (raycaster.ray.intersectPlane(dragPlane, dragOffset)) {
                            dragOffset.sub(draggedPart.position);
                        }
                        
                        return;
                    }
                }
                
                // Normal camera controls
                if (e.button === 0) {
                    isDragging = true;
                } else if (e.button === 2) {
                    isPanning = true;
                }
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (draggedPart) {
                    // Part dragging mode
                    const rect = canvas.getBoundingClientRect();
                    mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                    
                    raycaster.setFromCamera(mouse, camera);
                    
                    if (raycaster.ray.intersectPlane(dragPlane, dragIntersection)) {
                        if (dragMode === 'horizontal') {
                            // Move in XZ plane (horizontal)
                            draggedPart.position.x = dragIntersection.x - dragOffset.x;
                            draggedPart.position.z = dragIntersection.z - dragOffset.z;
                        } else if (dragMode === 'vertical') {
                            // Move in Y axis (vertical)
                            draggedPart.position.y = dragIntersection.y - dragOffset.y;
                        }
                        
                        // Update stored position
                        draggedPart.userData.position = {
                            x: draggedPart.position.x,
                            y: draggedPart.position.y,
                            z: draggedPart.position.z
                        };
                    }
                    return;
                }
                
                // Normal camera controls
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                
                if (isDragging) {
                    // Rotation speed increased by 25% (0.01 * 1.25 = 0.0125)
                    modelGroup.rotation.y += deltaX * 0.0125;
                    modelGroup.rotation.x += deltaY * 0.0125;
                } else if (isPanning) {
                    // Panning speed increased to 4x original (0.1 * 4 = 0.4)
                    camera.position.x -= deltaX * 0.4;
                    camera.position.y += deltaY * 0.4;
                }
                
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            canvas.addEventListener('mouseup', () => {
                if (draggedPart) {
                    // Save state for undo/redo
                    markAsModified();
                    showToast(`‚úì Moved ${draggedPart.userData.name}`);
                    canvas.style.cursor = 'default';
                }
                
                draggedPart = null;
                dragMode = null;
                isDragging = false;
                isPanning = false;
            });
            
            canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });
            
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                
                // Get mouse position relative to canvas
                const rect = renderer.domElement.getBoundingClientRect();
                const mouseX = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                const mouseY = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                
                // Create a vector from camera through mouse position
                const vector = new THREE.Vector3(mouseX, mouseY, 0.5);
                vector.unproject(camera);
                const dir = vector.sub(camera.position).normalize();
                
                // Zoom distance (4x speed)
                const distance = e.deltaY * 0.4;
                
                // Move camera along the direction vector (zoom towards pointer)
                camera.position.addScaledVector(dir, distance);
                
                // Constrain camera distance from origin
                const distanceFromOrigin = camera.position.length();
                if (distanceFromOrigin < 10) {
                    camera.position.normalize().multiplyScalar(10);
                } else if (distanceFromOrigin > 1000) {
                    camera.position.normalize().multiplyScalar(1000);
                }
            });
            
            // Keyboard controls for rotation
            document.addEventListener('keydown', (e) => {
                // Check if user is typing in an input field
                const activeElement = document.activeElement;
                const isTyping = activeElement && (
                    activeElement.tagName === 'INPUT' || 
                    activeElement.tagName === 'TEXTAREA' ||
                    activeElement.isContentEditable
                );
                
                // Allow Undo/Redo shortcuts even when typing
                if ((e.ctrlKey || e.metaKey) && !e.shiftKey && e.key.toLowerCase() === 'z') {
                    e.preventDefault();
                    undo();
                    return;
                }
                if ((e.ctrlKey || e.metaKey) && (e.key.toLowerCase() === 'y' || (e.shiftKey && e.key.toLowerCase() === 'z'))) {
                    e.preventDefault();
                    redo();
                    return;
                }
                
                // Skip other shortcuts if user is typing in an input field
                if (isTyping) {
                    return;
                }
                
                const rotationSpeed = 0.05; // Rotation increment per key press
                
                // Preset views with number keys
                if (e.key >= '1' && e.key <= '6') {
                    e.preventDefault();
                    switch(e.key) {
                        case '1': setTopView(); return;
                        case '2': setFrontView(); return;
                        case '3': setSideView(); return;
                        case '4': setBottomView(); return;
                        case '5': setBackView(); return;
                        case '6': setOtherSideView(); return;
                    }
                }
                
                // 15-degree rotations with Ctrl + Arrow keys
                if (e.ctrlKey || e.metaKey) {
                    switch(e.key) {
                        case 'ArrowLeft':
                            e.preventDefault();
                            rotateLeft15();
                            return;
                        case 'ArrowRight':
                            e.preventDefault();
                            rotateRight15();
                            return;
                        case 'ArrowUp':
                            e.preventDefault();
                            rotateUp15();
                            return;
                        case 'ArrowDown':
                            e.preventDefault();
                            rotateDown15();
                            return;
                    }
                }
                
                // Snap rotations with Shift + Arrow keys
                if (e.shiftKey) {
                    switch(e.key) {
                        case 'ArrowLeft':
                            e.preventDefault();
                            rotateLeft90();
                            return;
                        case 'ArrowRight':
                            e.preventDefault();
                            rotateRight90();
                            return;
                        case 'ArrowUp':
                            e.preventDefault();
                            rotateUp90();
                            return;
                        case 'ArrowDown':
                            e.preventDefault();
                            rotateDown90();
                            return;
                    }
                }
                
                switch(e.key) {
                    case 'ArrowLeft':
                        e.preventDefault();
                        modelGroup.rotation.y -= rotationSpeed;
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        modelGroup.rotation.y += rotationSpeed;
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        modelGroup.rotation.x -= rotationSpeed;
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        modelGroup.rotation.x += rotationSpeed;
                        break;
                    case 'q':
                    case 'Q':
                        // Rotate counterclockwise around Z axis (roll left)
                        modelGroup.rotation.z -= rotationSpeed;
                        break;
                    case 'e':
                    case 'E':
                        // Rotate clockwise around Z axis (roll right)
                        modelGroup.rotation.z += rotationSpeed;
                        break;
                    case 'r':
                    case 'R':
                        // Reset rotation
                        resetRotation();
                        break;
                    case 'h':
                    case 'H':
                        // Flip horizontal
                        flipHorizontal();
                        break;
                    case 'v':
                    case 'V':
                        // Flip vertical
                        flipVertical();
                        break;
                    case 'm':
                    case 'M':
                        // Toggle both info overlay and control panel minimize/expand
                        e.preventDefault();
                        toggleInfoOverlay();
                        toggleControlPanel();
                        break;
                }
            });
        }

        function handleMeasureClick(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(parts);
            
            if (intersects.length > 0) {
                const point = intersects[0].point;
                measurePoints.push(point);
                
                const marker = document.createElement('div');
                marker.className = 'measurement-point';
                marker.style.left = event.clientX + 'px';
                marker.style.top = event.clientY + 'px';
                document.body.appendChild(marker);
                
                if (measurePoints.length === 2) {
                    const distance = measurePoints[0].distanceTo(measurePoints[1]);
                    document.getElementById('measurement-value').textContent = distance.toFixed(2) + ' mm';
                    
                    const line = document.createElement('div');
                    line.className = 'measurement-line';
                    const dx = event.clientX - (parseFloat(document.querySelectorAll('.measurement-point')[0].style.left));
                    const dy = event.clientY - (parseFloat(document.querySelectorAll('.measurement-point')[0].style.top));
                    const length = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                    
                    line.style.width = length + 'px';
                    line.style.left = document.querySelectorAll('.measurement-point')[0].style.left;
                    line.style.top = document.querySelectorAll('.measurement-point')[0].style.top;
                    line.style.transform = `rotate(${angle}deg)`;
                    document.body.appendChild(line);
                    
                    showToast(`Distance: ${distance.toFixed(2)} mm`);
                    
                    setTimeout(() => {
                        clearMeasurementVisuals();
                        measurePoints = [];
                        document.getElementById('measurement-value').textContent = '--';
                    }, 5000);
                }
            }
        }

        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        function stopAnimation() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
                console.log('Animation stopped');
            }
        }

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            if (!container) {
                return; // Silently return if container not found yet
            }
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        // Cleanup function to prevent memory leaks
        function cleanupResources() {
            console.log('Cleaning up resources...');
            
            // Stop animation loop
            stopAnimation();
            
            // Remove event listeners
            window.removeEventListener('resize', onWindowResize);
            
            // Clear all parts with proper disposal
            clearAllSilent();
            
            // Dispose renderer
            if (renderer) {
                renderer.dispose();
                renderer.forceContextLoss();
            }
            
            console.log('Cleanup complete');
        }

        // Make functions globally accessible for HTML onclick handlers
        window.scrollPartsToTop = scrollPartsToTop;
        window.clearPartSearch = clearPartSearch;
        window.filterParts = filterParts;
        window.expandAllParts = expandAllParts;
        window.collapseAllParts = collapseAllParts;
        window.lockAllParts = lockAllParts;
        window.unlockAllParts = unlockAllParts;
        window.loadProject = loadProject;
        window.saveProject = saveProject;
        window.clearAll = clearAll;
        window.exportImage = exportImage;
        window.loadProjectFromURL = loadProjectFromURL;
        window.loadGitHubProject = loadGitHubProject;
        window.acceptDisclaimer = acceptDisclaimer;
        window.declineDisclaimer = declineDisclaimer;
        window.acceptAndLoadProject = acceptAndLoadProject;
        window.hideLicense = hideLicense;
        window.resetCamera = resetCamera;
        window.frameModel = frameModel;
        window.toggleMeasure = toggleMeasure;
        window.undo = undo;
        window.redo = redo;
        window.toggleControlPanel = toggleControlPanel;
        window.resetRotation = resetRotation;
        window.setTopView = setTopView;
        window.setFrontView = setFrontView;
        window.setSideView = setSideView;
        window.setBottomView = setBottomView;
        window.setBackView = setBackView;
        window.setOtherSideView = setOtherSideView;
        window.rotateLeft90 = rotateLeft90;
        window.rotateRight90 = rotateRight90;
        window.rotateUp90 = rotateUp90;
        window.rotateDown90 = rotateDown90;
        window.rotateLeft15 = rotateLeft15;
        window.rotateRight15 = rotateRight15;
        window.rotateUp15 = rotateUp15;
        window.rotateDown15 = rotateDown15;
        window.rotateLeft30 = rotateLeft30;
        window.rotateRight30 = rotateRight30;
        window.rotateLeft45 = rotateLeft45;
        window.rotateRight45 = rotateRight45;
        window.rotateLeft60 = rotateLeft60;
        window.rotateRight60 = rotateRight60;
        window.flipHorizontal = flipHorizontal;
        window.flipVertical = flipVertical;
        window.createGroup = createGroup;
        window.deleteGroup = deleteGroup;
        window.colorAllGroupsRandomly = colorAllGroupsRandomly;
        window.adjustValue = adjustValue;
        window.navigateToFolder = navigateToFolder;
        window.randomizeColors = randomizeColors;
        window.refreshGitHubBrowser = refreshGitHubBrowser;
        window.removePart = removePart;
        window.resetTransform = resetTransform;
        window.updateTransform = updateTransform;
        window.selectGroup = selectGroup;
        window.setTransformDirect = setTransformDirect;
        window.updateColorFromDropdown = updateColorFromDropdown;
        window.updateGroupColorFromDropdown = updateGroupColorFromDropdown;
        window.focusOnPart = focusOnPart;
        window.togglePartSelection = togglePartSelection;
        window.togglePartCollapse = togglePartCollapse;
        window.toggleLock = toggleLock;
        window.toggleVisibility = toggleVisibility;
        window.toggleTransform = toggleTransform;
        window.saveGitHubSettings = saveGitHubSettings;
        window.testGitHubPath = testGitHubPath;
        window.showDisclaimer = showDisclaimer;
        window.applyColorToGroup = applyColorToGroup;
        window.loadSelectedGitHubProject = loadSelectedGitHubProject;
        window.toggleInfoOverlay = toggleInfoOverlay;

        window.addEventListener('load', init);
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', cleanupResources);
    </script>
</body>
</html>
